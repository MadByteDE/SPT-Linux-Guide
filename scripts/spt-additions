#!/usr/bin/env bash

# # # # # # # # # 
# SPT-ADDITIONS #
# # # # # # # # # 

# exit codes:
# 1: general error | 10: -d check failed | 11: -f check failed | 12: empty string | 13: m_7z failed
# 14: case char mismatch

# We don't want to run as root
if [[ "$( id -u )" -eq 0 ]]; then
    echo "This script is not supposed to be run as root!"
    exit 1
fi

# Shell options
shopt -s extglob

# Make sure to throw an error and exit on SIGINT
trap int INT; int() { warn "Interrupt received" && m_exit; }

TITLE="spt-additions"; AUTHOR="MadByte"; LICENSE="MIT"
VERSION="0.9.3"
DATE="2025-10-21"

# ANSI codes
BOLD="\e[1m"; UNDERLINE="\e[2m"; RESET="\e[0m"
RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[36m"
YELLOW="\e[33m"; GRAY="\e[90m"

# System directories
readonly SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" && pwd )"
readonly DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
readonly CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly DATA_DIR="${DATA_HOME}/${TITLE}"
readonly CACHE_DIR="${CACHE_HOME}/${TITLE}"
readonly CONFIG_DIR="${CONFIG_HOME}/${TITLE}"
readonly COMPAT_DIR="${DATA_HOME}/Steam/compatibilitytools.d"
readonly RUNTIME_DIR="${DATA_DIR}/runtime"
readonly TMP_DIR="$( mktemp -d "/tmp/spt-XXXXX" )"
readonly ICO_DIR="${DATA_HOME}/icons/hicolor/256x256/apps"
readonly APP_DIR="${DATA_HOME}/applications"

# Default setting variables
readonly DEFAULT_PROTONPATH="GE-Proton"
readonly DEFAULT_WINEPREFIX="${HOME}/Games/tarkov"
readonly DEFAULT_SPT_DIR="drive_c/SPTarkov"
readonly DEFAULT_INSTALL_MODE="native"

declare -A CONFIG ENV METADATA CACHE URL SHORTCUT

# File path variables
readonly LOG_PATH="${CACHE_DIR}/installer.log"
readonly UMU_PATH=$( command -v umu-run || echo "${RUNTIME_DIR}/umu-run" )
readonly CONFIG_PATH="${CONFIG_DIR}/app.conf"
readonly ENV_PATH="${CONFIG_DIR}/env.conf"
readonly METADATA_PATH="${CACHE_DIR}/metadata.conf"
readonly MOD_PATH="${CACHE_DIR}/spt.7z"
readonly LTS_MOD_PATH="${CACHE_DIR}/lts-spt.7z"
readonly PATCHER_PATH="${CACHE_DIR}/patcher.7z"
readonly LTS_PATCHER_PATH="${CACHE_DIR}/lts-patcher.7z"
readonly MOD_JSON_PATH="${CACHE_DIR}/release.json"
readonly PATCHER_JSON_PATH="${CACHE_DIR}/mirrors.json"

# Libraries / Tools
URL[umu-run]="https://github.com/Open-Wine-Components/umu-launcher/releases/download/1.2.9/umu-launcher-1.2.9-zipapp.tar"
URL[7zzs]="https://github.com/ip7z/7zip/releases/download/25.01/7z2501-linux-x64.tar.xz"
URL[hpatchz]="https://github.com/sisong/HDiffPatch/releases/download/v4.11.1/hdiffpatch_v4.11.1_bin_linux64.zip"
URL[jq]="https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-linux-amd64"
URL[xxd]="http://ftp.de.debian.org/debian/pool/main/v/vim/xxd_9.1.1846-1_amd64.deb"

# Installers
URL[bsg-launcher]="https://prod.escapefromtarkov.com/launcher/download"
URL[spt-installer]="https://ligma.waffle-lord.net/SPTInstaller.exe"
URL[aspnet-windows]="https://builds.dotnet.microsoft.com/dotnet/aspnetcore/Runtime/9.0.9/aspnetcore-runtime-9.0.9-win-x64.exe"

# Scripts
URL[installer-script]="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/main/scripts/${TITLE}"
URL[server-script]="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/main/scripts/launch-server.sh"

# Icons
URL[bsg-launcher-ico]="https://cdn2.steamgriddb.com/icon/33686c2d8930be81c843ffb7d4312605/32/256x256.png"
URL[spt-launcher-ico]="https://cdn2.steamgriddb.com/icon_thumb/ddd4f86cd0f978e85155cfa6c9f94e0c.png"
URL[spt-server-ico]="https://cdn2.steamgriddb.com/icon_thumb/9f7431ea593b8e57401c08f40adc6e34.png"

# Metadata
URL[patcher-json]="https://slugma.waffle-lord.net/mirrors.json"
URL[mod-json]="https://spt-releases.modd.in/release.json"
URL[metadata]="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/SPTv4-Dev/scripts/metadata.conf"

# Links
URL[spt-release]="https://github.com/sp-tarkov/build/releases"
URL[guide-repo]="https://github.com/MadByteDE/SPT-Linux-Guide"
URL[discord]="https://discord.com/invite/Xn9msqQZan"
URL[forge]="https://forge.sp-tarkov.com"
readonly -A URL

# Shortcut paths
SHORTCUT[bsg-launcher]="${APP_DIR}/BSG - Launcher.desktop"
SHORTCUT[spt-launcher]="${APP_DIR}/SPT - Launcher.desktop"
SHORTCUT[spt-server]="${APP_DIR}/SPT - Server.desktop"


# # # # # # # # # #
# Alias functions #
# # # # # # # # # #

m_exit() {
    local status=${1:-$?}
    if [[ ${BASH_SUBSHELL} -eq 0 ]]; then
        save_array config
        save_array env
        [[ -d "${TMP_DIR}" ]] && m_rm -r "${TMP_DIR}"
    fi
    exit "${status}"
}


m_chmod() { chmod "$@" &>> "${LOG_PATH}" || err "Command \"chmod $*\" failed" "$?"; }
m_mkdir() { mkdir -p "$@" &>> "${LOG_PATH}" || err "Command \"mkdir $*\" failed" "$?"; }
m_ls() { ls "$@" 2>> "${LOG_PATH}" || err "Command \"ls $*\" failed" "$?"; }
m_mv() { mv "$@" &>> "${LOG_PATH}" || err "Command \"mv $*\" failed" "$?"; }
m_curl() { curl --connect-timeout 30 -f "$@" || err "Command \"curl $*\" failed" "$?"; }
m_umu() { "${UMU_PATH}" "$@" 2>> "${LOG_PATH}" || err "Command \"umu-run $*\" failed" "$?"; }


m_rm() {
    local path="$( realpath -m "${@: -1}" )"
    [[ -z "${path}" ]] && err "${err_pfx} Path variable is empty"

    # Check for valid paths
    case "${path}" in
        *"${WINEPREFIX}"* | *"${DATA_DIR}"* | *"${CACHE_DIR}"* | \
        *"${CONFIG_DIR}"* | *"${ICO_DIR}"* | *"${APP_DIR}"* | *"${TMP_DIR}"*) ;;
        *) err "${err_pfx} Cannot remove file or directory \"${path}\"" ;;
    esac
    
    rm "$@" || warn "Command \"rm $*\" failed"
}


m_cp() {
    local source_path="${1}"; local target_path="${2}"

    # Check for valid paths
    case "${target_path}" in
        *"${WINEPREFIX}"* | *"${DATA_DIR}"* | *"${CACHE_DIR}"* | *"${HOME}/.local/bin"* | \
        *"${HOME}/bin"* | *"${CONFIG_DIR}"* | *"${ICO_DIR}"* | *"${APP_DIR}"* | *"${TMP_DIR}"*) ;;
        *) err "Invalid target directory \"${target_path}\"" ;;
    esac

    # Create missing directories
    m_mkdir "${target_path}"

    local files_total progress=1
    files_total=$( find "${source_path}" \( -type f -printf x \) | wc -c )

    if [[ -d "${source_path}" ]]; then
        # Iterate files & copy to target directory
        echo; find "${source_path}" \( -type f \) -print0 | while IFS= read -r -d '' source; do
            local filename="${source/#$source_path}"
            local output="${target_path}/${filename}"
            local progress_string="[${progress}/${files_total}]"
            msg -o "${progress_string} Copying: ${filename##*/}"
            [[ ! -d "${output%/*}" ]] && m_mkdir "${output%/*}"
            cp --reflink=auto "${source}" "${output}" &>> "${LOG_PATH}" || err "Command \"cp $*\" failed" "$?"
            progress=$((progress+1))
        done
    elif [[ -f "${source_path}" ]]; then
        cp --reflink=auto "${source_path}" "${target_path}" &>> "${LOG_PATH}" || err "Command \"cp $*\" failed" "$?"
    fi
}


m_7z() {
    archive_path="$(realpath -m "${1%/}")"; local target_path="$(realpath -m "${2%/}")"
    filename="${archive_path##*/}"
    7zzs x -aoa "${archive_path}" -o"${target_path}" 1>/dev/null
    [[ "$?" != 0 ]] && err "Failed to extract \"${filename}\""
}


# # # # # # # # # # #
# Helper functions  #
# # # # # # # # # # #

msg() {
    local mode filtered_str
    case "$1" in
        # Override mode
        -o) mode="o"; shift ;;
    esac

    local output="$*"
    filtered_str=$( echo -e "${output}" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' )

    # Print to terminal
    case ${NO_ANSI} in
        1) echo "${filtered_str}" ;;
        *)
            case ${mode} in
                o) echo -e "\r\033[1A\033[0K│ ${output}" ;;
                *) echo -e "│ ${output}" ;;
            esac
        ;;
    esac

    # Write to log file
    if [[ -d "${CACHE_DIR}" ]] && [[ "${mode}" != "o" ]] ; then
        echo "[$TITLE] ${filtered_str}" &>> "${LOG_PATH}"
    fi
}


warn() {
    msg "${YELLOW}Warn: ${RESET}$1"
}


err() {
    local message="$1"; local status="${2:-"1"}"
    local pfx="${BOLD}${RED}ERROR ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}${message} (Exit code: ${status})" 1>&2
    msg "${pfx}See \"${LOG_PATH}\" for more details.${RESET}" 1>&2
    m_exit "$status"
}


yesno() {
    msg "${BOLD}${BLUE}[Q] $*${RESET} [y/n] "
    if [[ $NO_PROMPT == 1 ]]; then
        msg "NO_PROMPT variable set - returning 0"
        return 0
    fi
    while true; do
        read -r -p "│ > " yn
        case $yn in
            [Yy]*) return 0 ;;  
            [Nn]*) return 1 ;;
        esac
    done
}


read_input() {
    read -e -r -p "│ > " input; printf "$input\n"
}


wrap_run() {
    printf "%s\n" "$( "$@" )"; local status=$?
    return $status
}


set_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key value
    key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"

    # Filter for invalid keys
    [[ -z "${key}" ]] && err "Missing key for array \"${array_name}\""
    [[ ! "${key}" =~ ^[A-Za-z0-9_-]+$ ]] && err "Key contains invalid characters: \"${key}\""

    # Set value
    case "${array_name}" in
        config)
            [[ -n "${value}" ]] && [[ ! "${value}" =~ ^[\ A-Za-z0-9/._-]+$ ]] && err "Value contains invalid characters: \"${value}\""
            [[ -z "${value}" ]] && err "Missing value for array \"${array_name}\""
            CONFIG[$key]="${value%/}"
        ;;
        env)
            [[ -n "${value}" ]] && [[ ! "${value}" =~ ^[A-Za-z0-9/.,_=-]+$ ]] && err "Value contains invalid characters: \"${value}\""
            ENV[$key]="${value%/}"
            export "${key}=${value%/}"  
        ;;
        metadata) METADATA[$key]="${value}" ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


unset_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key value
    key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"

    # Filter for invalid keys
    [[ -z "$key" ]] && err "Missing key: \"${array_name}\""

    # Unset key
    case "${array_name}" in
        config) unset CONFIG[$key] ;;
        env) unset ENV[$key]; unset "${key}" ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


load_array() {
    local path
    local array_name="${1}" || err "Missing argument: load_array [array_name]"
    case "${array_name}" in
        config) path="${CONFIG_PATH}" ;;
        env) path="${ENV_PATH}" ;;
        metadata) path="${METADATA_PATH}" ;;
        *) err "Invalid argument \"${array_name}\"";;
    esac

    # Warn if the file does not exist
    if [[ ! -f "${path}" ]]; then
        warn "Failed to load \"${path}\": File does not exist" && return
    fi

    # Read lines & load values
    while read -r line; do
        case "${line}" in
            *=*) set_value "${array_name}" "${line}" ;;
            *) err "Cannot load setting \"${line}\": Invalid format" ;;
        esac
    done < "${path}"
}


save_array() {
    local array_name="${1}" || err "Missing argument: \"array_name\""
    [[ ! -d "${CONFIG_DIR}" ]] && return 1
    case "${array_name}" in
        config)
            [[ -f "${CONFIG_PATH}" ]] && m_rm "${CONFIG_PATH}"
            for key in "${!CONFIG[@]}"; do
                echo "${key}=\"${CONFIG[$key]}\"" >> "${CONFIG_PATH}"
            done
        ;;
        env)
            [[ -f "${ENV_PATH}" ]] && m_rm "${ENV_PATH}"
            for key in "${!ENV[@]}"; do
                echo "${key}=\"${ENV[$key]}\"" >> "${ENV_PATH}"
            done
        ;;
        *) ;;
    esac
}


load_metadata() {
    # Get metadata
    local download=0
    if [[ ! -f "${METADATA_PATH}" ]] || ! check_ttl "${METADATA_PATH}" "7200"; then
        msg "Downloading \"LTS\" metadata..."
        m_curl -sL "${URL[metadata]}" -o "${METADATA_PATH}"
    fi
    load_array metadata
}


set_prefix() {
    # Validate path
    check_prefix_path "${1%/}"
    local path="$( realpath -m "${1%/}" )"
    [[ -z "${path}" ]] && err "Path argument is not set"

    # Update WINEPREFIX environment variable
    export WINEPREFIX="${path}"

    # Update prefix config
    set_value env "WINEPREFIX=${path}"

    # Update prefix paths
    check_spt_path "${CONFIG[spt-path]}"
    SPT_DIR="${WINEPREFIX%/}/${CONFIG[spt-path]%/}"
    BSG_DIR="${WINEPREFIX%/}/drive_c/Battlestate Games"
    EFT_DIR=$( get_eft_path )

    msg "Prefix path has been set to \"${WINEPREFIX}\""
}


get_env() {
    printf "$( for key in "${!ENV[@]}"; do printf "${key}=\"${ENV[$key]}\" "; done )\n"
}


get_hash() {
    md5sum "$@" | cut -d ' ' -f 1 | xxd -r -p | base64 2>/dev/null
}


get_file_version() {
    local filepath="${1}"
    [[ ! -f "${filepath}" ]] && exit 11
    $( 7zzs l "${filepath}" &>/dev/null ) || exit $?
    7zzs l "${filepath}" | grep -o "FileVersion:[^}]*" | head -1 | cut -d " " -f2
}


get_eft_path() {
    local entry path
    # get windows path
    [[ ! -f "${WINEPREFIX}/system.reg" ]] && exit 11
    entry=$( sed -n '/Uninstall\\\\EscapeFromTarkov/,/^$/p' "${WINEPREFIX}/system.reg" )
    path=$( echo "${entry}" | grep -o "\"InstallLocation\"=\"[^}]*" | cut -d "\"" -f4 2>/dev/null )
    [[ -z "${path}" ]] && exit 12
    # Replace backslashes with slashes
    path="${path//\\\\/\/}"
    # Finally assemble the full path & return it
    printf "%s/%s\n" "${WINEPREFIX}" "${path//C:/drive_c}"
}


get_patcher_urls() {
    local urls
    local json_path="${1:-"${PATCHER_JSON_PATH}"}"
    local index="${2}"
    urls=$( cat "${json_path}" | jq -r '.Mirrors[].Link' )
    [[ -z "${urls}" ]] && exit 12
    # Return single url
    if [[ -n "${index}" ]]; then
        echo "${urls}" | sed "${index}q;d" 2>/dev/null
        return 0
    fi
    # Return list
    printf "%s\n" "${urls}"
}


get_patcher_eft_version() {
    local path="${1}"
    local filename version
    # Split filename to get version infos from it
    filename=$( echo "${path##*/}" | tr "_." " " )
    version=$( echo "${filename}" | cut -d " " -f5 )
    printf "%s\n" "${version}"
}


init_prefix() {
    if [[ ! -d "${WINEPREFIX}" ]]; then
        msg "Initializing wine prefix..." && m_umu wineboot -u
    fi

    # WORKAROUND: Find and pin latest GE-Proton version if no custom path is set
    # Fixes umu-launcher always re-downloading the latest GE-Proton version
    if [[ -z "${ENV[PROTONPATH]}" ]] || [[ "${ENV[PROTONPATH]}" == "GE-Proton" ]]; then
        local proton_path="$( find "${COMPAT_DIR}" \( -name "${DEFAULT_PROTONPATH}*" -type d \) | tail -n 1 )"
        [[ -z "${proton_path}" ]] && proton_path="${DEFAULT_PROTONPATH}"
        msg "Setting Proton version to \"${proton_path##*/}\""
        set_value env "PROTONPATH=${proton_path##*/}"
        export PROTONPATH="${proton_path##*/}"
    fi
}


# # # # # # # # # # #
#  Check functions  #
# # # # # # # # # # #

check_verb() {
    [[ ! -d "${WINEPREFIX}" ]] && err "Prefix directory \"${WINEPREFIX}\" does not exist"
    if ! cat "${WINEPREFIX}/winetricks.log" 2>/dev/null | grep -q "$1"; then
        return 1
    fi
}


check_disk_space() {
    local total_gb=${1}; local path="${WINEPREFIX}"
    [[ -z "${path}" ]] && err "Missing path argument"
    # Get required values
    local free_kb total_kb eft_kb free_gb total_gb
    free_kb=$( df -k "${path}" | tail -1 | awk '{print $4}' )
    free_gb=$( echo "${free_kb}" | awk '{ free = $1/1024/1024 ; printf("%.2fGiB\n", free) }' )
    # If no total size is defined, use size of the EFT game files
    if [[ -n "${total_gb}" ]]; then
        total_kb=$(( 1024*1024*total_gb ))
    else
        local eft_kb=$( du -cs "${EFT_DIR}" | head -1 | cut -d$'\t' -f1 )
        total_kb=$((eft_kb + 1024*1024*10))
    fi
    total_gb=$( echo "${total_kb}" | awk '{ total = $1/1024/1024 ; printf("%.2fGiB\n", total) }' )
    # Check if there's enough space
    [[ $free_kb -le $total_kb ]] && err "Not enough free disk space! (${free_gb} free < ${total_gb} needed)"
    msg "Enough free disk space available! (${free_gb} free > ${total_gb} needed)"
}


check_prefix_path() {
    local status=0 path
    local prefix_path="${1%/}"
    [[ ! "${prefix_path:0:1}" =~ ^[./~]+$ ]] && err "Invalid path format: \"${prefix_path}\""
    prefix_path="$(realpath -m "${prefix_path}")"
    local check_paths=("${prefix_path}/system.reg" "${prefix_path}/dosdevices" "${prefix_path}/drive_c")

    while true; do
        [[ -f "${prefix_path}" ]] && status=1 && break

        # Check for write permissions
        local recursive_path="${prefix_path}"
        while [[ ! -d "${recursive_path}" ]]; do
            recursive_path="${recursive_path%/*}"
            [[ "${recursive_path}" == "" ]] && status=2 && break
        done
        [[ ! -w "${recursive_path}" ]] && status=3 && break

        # Check directory content
        if [[ -n "$( m_ls -A "${prefix_path}" 2>/dev/null )" ]]; then
            for path in "${check_paths[@]}"; do
                [[ ! -f "${path}" ]] && [[ ! -d "${path}" ]] && status=4 && break
            done
        fi
        break
    done

    if [[ $status != 0 ]]; then
        case $status in
            1) err "Given path is a file: \"${prefix_path}\"" ;;
            2) err "Failed to resolve prefix path: \"${prefix_path}\"" ;;
            3) err "No write permission for directory: \"${prefix_path}\"" ;;
            4) err "Given directory is not empty or the prefix is corrupted: \"${prefix_path}\"" ;;
        esac
    fi
}


check_spt_path() {
    local spt_path="${1%/}"
    if [[ "${spt_path}" != *"drive_c"* ]]; then
        # Reset to default path
        set_value config "spt-path=${DEFAULT_SPT_DIR}"
        err "Invalid spt path: \"${spt_path}\""
    fi
}


check_eft_installed() {
    EFT_DIR=$( get_eft_path )
    if [[ -z "${EFT_DIR}" ]] || [[ ! -d "${EFT_DIR}" ]] || [[ -z $( m_ls -A "${EFT_DIR}" ) ]]; then
        return 1
    fi
    return 0
}


check_flatpak_env() {
    [[ -z "${FLATPATK_SANDBOX_DIR}" ]] && return 1
}


check_aspnet() {
    if check_flatpak_env; then
        warn "Flatpak environment detected!"
        msg "   > Skipping native ASP.NET dependency check" & return 0
    fi
    if ! dotnet --list-runtimes 2>/dev/null | grep "AspNet" | grep "9.0" &>/dev/null; then
        warn "\"ASP.NET Runtime 9.0\" is not installed."
        msg "> ${YELLOW}Please install it first & retry running this script.${RESET}"
        err "\"ASP.NET Runtime 9.0\" is not installed"
    fi
}


check_native_deps() {
    local status
    local cmds=( "python3" "curl" "7zzs" "xxd" "hpatchz" "jq" "umu-run" )
    msg "Checking for native dependencies..."
    for cmd in "${cmds[@]}"; do
        if command -v "${cmd}" &>/dev/null; then continue; fi
        case ${cmd} in
            # Required tools / libraries
            python3|curl) warn "Cannot find \"${cmd}\"!"; status=1 ;;
            # Downloadable tools / libraries
            jq|hpatchz|xxd|7zzs|umu-run) wrap_run install_dep "${cmd}" "${URL[${cmd}]}" || status=1 ;;
        esac
    done
    [ "$status" = 1 ] && err "Please install all missing dependencies & try again."
}


check_eft_running() {
    local apps=( "BsgLauncher.exe" "EscapeFromTarko" )
    for app in "${apps[@]}"; do
        if [[ -z $( pidof "${app}" ) ]]; then continue; fi
        warn "It looks like \"${app}\" is currently running on your system!"
        msg "> ${YELLOW} Please close the application & retry.${RESET}"
        err "\"${app}\" process found"
    done
}


check_hash() {
    local file_hash
    local file_path="$(realpath -m "${1%/}")"; local expected_hash="${2}"
    # Check arguments
    [[ ! -f "${file_path}" ]] && err "File \"${file_path}\" does not exist"
    [[ -z "${expected_hash}" ]] && err "Missing \"expected_hash\" argument"
    # use file to calculate MD5 hash and ENCODE in base64
    msg "Calculating checksum for file: \"${file_path##*/}\""
    file_hash=$( get_hash "${file_path}" ) || err "Failed to calculate hash"
    [[ -z "${file_hash}" ]] && err "get_hash returned empty string"
    # Compare
    if [[ "${file_hash}" != "${expected_hash}" ]]; then
        warn "Hash check mismatch (File: \"${file_hash}\" != Expected: \"${expected_hash}\")"
        return 1
    fi
    msg "Hash check successful"
}


check_cached() {
    local cached_path="$(realpath -m "${1%/}")"; [[ -z "${cached_path}" ]] && err "Missing cached path argument"
    local expected_hash="${2}"
    # Make sure the path actually is in CACHE_PATH
    [[ "$cached_path" == *"${CACHE_DIR}"* ]] || err "File is not in \"${CACHE_DIR}\""
    # Verify the file is there and valid
    local filename=${cached_path##*/}
    if [[ -f "${cached_path}" ]]; then
        msg "Found \"${filename}\" in cache directory"
        if [[ -n "${expected_hash}" ]] && ! check_hash "${cached_path}" "${expected_hash}"; then
            msg "Removing cached file \"${filename}\""
            m_rm "${cached_path}"
            return 1
        fi
    else
        msg "\"${cached_path}\" is not cached"
        return 1
    fi
}


check_ttl() {
    local c_time m_time e_time
    local file_path="$(realpath -m "${1%/}")"; local ttl="${2:-"3600"}"
    # Check if file exists, if not - fail the check
    [[ ! -f "${file_path}" ]] && msg "File \"${file_path}\" does not exist" && return 1
    # Calculate time elapsed since last modified
    c_time=$( date +%s )
    m_time=$( date -r "${file_path}" +%s )
    ((e_time = c_time - m_time))
    # If elapsed time >= TTL - fail the check
    if [[ $e_time -ge $ttl ]]; then
        return 1
    fi
}


# # # # # # # # # # # # #
#  Installer functions  #
# # # # # # # # # # # # #

install_verb() {
    local verb="${1}"; local text="${2:-"Installing \"${verb}\""}"
    if check_verb "${verb}"; then
        msg "\"${verb}\" is already installed"
        return 1
    fi
    msg "${text}..."
    m_umu winetricks -q "${verb}" 1>> "${LOG_PATH}"
}


install_dep() {
    local cmd_name="$1"; local url="$2"; local filename="${url##*/}"
    local source_path="${3:-$TMP_DIR}"; local target_path="${4:-$RUNTIME_DIR}"
    
    # Download
    msg "Downloading \"${filename}\"..."
    cd "${TMP_DIR}" && m_curl -sL "${url}" -o "${filename}"

    case "${filename}" in
        # Extract archive
        *.zip*|*.7z*) m_7z "${filename}" "${TMP_DIR}" ;;
        *.tar*) tar -xf "${filename}" || err "Failed to extract tar archive" ;;
        *.deb*)
            m_7z "${filename}" "${TMP_DIR}"
            tar -xf "data.tar" || err "Failed to extract tar archive"
        ;;
        # Single file workarounds
        *jq-linux-amd64*) mv "jq-linux-amd64" "jq" || err "Failed to rename \"${filename}\"" ;;
        *) ;;
    esac

    # Search executable inside the extracted directory
    local file_path=$( find "${source_path}" \( -name "${cmd_name}" -type f \) | head -1 )
    [[ -z "${file_path}" ]] && err "Cannot find \"${cmd_name}\" in \"${source_path}\""

    # Change permissions
    m_chmod +x "${file_path}"

    # Move to target directory
    m_mv -f "${file_path}" "$target_path/${cmd_name}"
}


install_eft() {
    msg "Starting \"Escape from Tarkov\" setup..."
    check_disk_space 60

    # Install game dependencies
    install_verb "dotnet48" "Installing .NET 4.8 Runtime (this might take a while)"
    install_verb "vcrun2022" "Installing Microsoft Visual C++ 2015-2022 Redistributable"
    
    # Add mouse focus workaround
    msg "Adding mouse focus workaround..."
    m_umu reg add "HKCU\\Software\\Wine\\X11 Driver" /v "UseTakeFocus" /t "REG_SZ" /d "N" /f 1>> "${LOG_PATH}"
    
    # Download BSG Launcher setup file
    if [[ ! -f "${CACHE_DIR}/BsgLauncher.exe" ]]; then
        msg "Downloading BSG Launcher..."
        cd "${CACHE_DIR}" && m_curl -L "${URL[bsg-launcher]}" -o "BsgLauncher.exe"
    fi

    # Install BSG Launcher
    if [[ ! -d "${BSG_DIR}/BsgLauncher" ]]; then
        msg "Installing BSG Launcher..."
        m_umu "${CACHE_DIR}/BsgLauncher.exe" /VERYSILENT
    fi

    # Download icon to icons directory
    if [[ ! -f "${ICO_DIR}/bsg_launcher.png" ]]; then
        msg "Getting app icon from SteamGridDB..."
        cd "${ICO_DIR}" && m_curl -sL "${URL[bsg-launcher-ico]}" -o "bsg_launcher.png"
    fi

    # Create application shortcut
    opt_shortcut bsg-launcher

    msg "${GREEN}Done!${RESET}"
}


install_spt() {
    local install_mode="${CONFIG[install-mode]}"
    
    msg "Launching \"SPTarkov\" setup..."
    msg "Selected install mode is \"${install_mode}\"..."

    if ! check_eft_installed; then
        warn "Escape from Tarkov is not installed."
        msg "> ${YELLOW}make sure to install the game inside the BSG Launcher & try again!${RESET}"
        err "Escape from Tarkov not found."
    elif [[ -d "${SPT_DIR}" ]]; then
        warn "SPTarkov directory already exists."
        msg "> ${YELLOW}If you want to reinstall, make sure to remove the old installation first!${RESET}"
        err "SPTarkov directory already exists."
    fi

    check_eft_running;  check_aspnet;  check_disk_space
    
    # Install dependencies
    install_verb "dotnetdesktop6" "Installing .NET Desktop 6 Runtime"
    install_verb "dotnetdesktop8" "Installing .NET Desktop 8 Runtime"
    install_verb "dotnetdesktop9" "Installing .NET Desktop 9 Runtime"

    # Add DLL overrides
    msg "Adding \"winhttp\" DLL override..."
    m_umu reg add "HKCU\\Software\\Wine\\DllOverrides" /v "winhttp" /t "REG_SZ" /d "native,builtin" /f 1>> "${LOG_PATH}"

    # Add prefix update pop-up workaround
    msg "Adding \"RUNDLL32\" pop-up workaround..."
    m_umu reg add "HKLM\\Software\\Microsoft\\.NETFramework" /v "OnlyUseLatestCLR" /t "REG_DWORD" /d 0001 /f 1>> "${LOG_PATH}"

    # Install SPT
    case "$install_mode" in
        lts|native|lutris) install_spt_native ;;
        proton)
            # Download ASP.NET Runtime
            if ! [[ -f "${CACHE_DIR}/aspnetcore-runtime.exe" ]]; then
                msg "Downloading Microsoft ASP.NET Runtime 9..."
                cd "${CACHE_DIR}" && m_curl -L "${URL[aspnet-windows]}" -o "aspnetcore-runtime.exe"
            fi

            # Install ASP.NET Runtime
            msg "Installing Microsoft ASP.NET Runtime 9..."
            m_umu "${CACHE_DIR}/aspnetcore-runtime.exe" /q

            # Download SPT Installer
            if ! [[ -f "${CACHE_DIR}/SPTInstaller.exe" ]]; then
                msg "Downloading SPTInstaller.exe..."
                cd "${CACHE_DIR}" && m_curl -LO "${URL[spt-installer]}"
            fi

            # Symlink SPTInstaller cache directory to script cache directory
            local cache_dir="${WINEPREFIX}/drive_c/users/steamuser/Application Data/spt-installer/cache"
            if [[ -d "${cache_dir}" ]]; then
                [[ $(readlink "${cache_dir}") != "${CACHE_DIR}" ]] && m_rm -r "${cache_dir}"
            fi
            [[ ! -d "${cache_dir}" ]] && m_mkdir "${cache_dir%/*}"
            ln -s -n "${CACHE_DIR}" "${cache_dir}" &>> "${LOG_PATH}"
            
            # Convert SPT directory path to windows path
            local path="${CONFIG[spt-path]//\//\\}"
            path="${path//drive_c/C:}"

            # Run SPT Installer
            msg "Launching SPT Installer..."
            m_umu "${CACHE_DIR}/SPTInstaller.exe" installpath="${path}"

            # Make the Linux server executable
            m_chmod +x "${SPT_DIR}/SPT/SPT.Server.Linux"
        ;;
        ""|*) err "Invalid install mode \"${install_mode}\"" ;;
    esac

    # Set Windows version to 8.1
    msg "Setting Windows version to \"8.1\"..."
    m_umu winetricks -q "win81" 1>> "${LOG_PATH}"

    if [[ "${install_mode}" == "lts" ]]; then
        set_value env "PROTON_VERB=run"
    else
        # Install the latest server launch script
        msg "Downloading latest \"launch-server.sh\" script..."
        cd "${SPT_DIR}" && m_curl -sLO "${URL[server-script]}"
        m_chmod +x "${SPT_DIR}/launch-server.sh"

        # Create launcher shortcut inside the root directory
        ln -s "${SPT_DIR}/SPT/SPT.Launcher.exe" "${SPT_DIR}" &>> "${LOG_PATH}"\
        || warn "Failed to create symbolic link for \"SPT.Launcher.exe\""
    fi

    case "${install_mode}" in
        native|proton|lts)
            # Download icons to icons directory
            if [[ ! -f "${ICO_DIR}/spt_launcher.png" ]] || [[ ! -f "${ICO_DIR}/spt_server.png" ]]; then
                msg "Getting app icons from SteamGridDB..."
                cd "${ICO_DIR}" && m_curl -sL "${URL[spt-launcher-ico]}" -o "spt_launcher.png"
                cd "${ICO_DIR}" && m_curl -sL "${URL[spt-server-ico]}" -o "spt_server.png"
            fi

            # Create application shortcuts
            opt_shortcut spt
        ;;
        lutris) ;;
        ""|*) err "Invalid install mode \"${install_mode}\"" ;;
    esac

    msg "${GREEN}Done!${RESET}"
}


install_spt_native() {
    local installed_eft patcher_eft mod_eft mod_version urls
    local mod_url mod_hash patcher_hash patcher_url patcher_path
    local install_mode="${CONFIG[install-mode]}"
    
    # Pre-Checks
    check_native_deps

    # Fetch some juicy data
    installed_eft=$( get_file_version "${EFT_DIR}/EscapeFromTarkov.exe" ) || err "Failed to get EFT version" "$?"
    installed_eft=$( echo "${installed_eft}" | cut -d "." -f4 )

    case "${install_mode}" in
        # SPT 3.11.x
        lts)
            load_metadata
            # Mod
            mod_url="${METADATA[lts-spt-url]}"; [[ -z "${mod_url}" ]] && err "Failed to get mod url"
            mod_hash="${METADATA[lts-spt-hash]}"; [[ -z "${mod_hash}" ]] && err "Failed to get mod hash"
            mod_eft="$( echo "${mod_url##*/}" | cut -d "-" -f3 )"; [[ -z "${mod_eft}" ]] && err "Failed to get mod eft version"
            mod_version="$( echo "${mod_url##*/}" | cut -d "-" -f2 )"; [[ -z "${mod_version}" ]] && err "Failed to get mod version"
            mod_path="${LTS_MOD_PATH}"
            # Patcher
            patcher_hash="${METADATA[lts-patcher-hash]}"
            patcher_url="${METADATA[lts-patcher-url]}"
            patcher_eft=$( get_patcher_eft_version "${patcher_url}" ) || err "Failed to get required EFT version for patcher" "$?"
            patcher_path="${LTS_PATCHER_PATH}"
            msg "Installing SPT LTS version: \"${mod_version}\""
        ;;
        # SPT 4.x
        native)
            # Get metadata
            if ! check_ttl "${MOD_JSON_PATH}" || ! check_ttl "${PATCHER_JSON_PATH}"; then
                msg "Downloading \"RELEASE\" metadata..."
                m_curl -sL "${URL[mod-json]}" -o "${MOD_JSON_PATH}"
                m_curl -sL "${URL[patcher-json]}" -o "${PATCHER_JSON_PATH}"
            fi
            # Mod
            mod_url=$( jq -r '.Mirrors[].DownloadUrl' "${MOD_JSON_PATH}" ) || err "Failed to get SPT download url" "$?"
            mod_hash=$( jq -r '.Mirrors[].Hash' "${MOD_JSON_PATH}" ) || err "Failed to get mod hash" "$?"
            mod_eft=$( jq -r '.ClientVersion' "${MOD_JSON_PATH}" ) || err "Failed to get required EFT version for SPT" "$?"
            mod_version=$( jq -r '.AkiVersion' "${MOD_JSON_PATH}" ) || err "Failed to get SPT version" "$?"
            mod_path="${MOD_PATH}"
            # Patcher
            patcher_hash=$( jq -r '.Mirrors[].Hash' "${PATCHER_JSON_PATH}" | head -1 ) || err "Failed to get patcher hash" "$?"
            patcher_url=$( jq -r '.Mirrors[].Link' "${PATCHER_JSON_PATH}" | head -1 ) || err "Failed to get patcher download url" "$?"
            patcher_eft=$( get_patcher_eft_version "${patcher_url}" ) || err "Failed to get required EFT version for patcher" "$?"
            patcher_path="${PATCHER_PATH}"
            msg "Installing SPT release version: \"${mod_version}\""
        ;;
        *) err "Invalid install mode \"${install_mode}\"" ;;
    esac

    # Check if we need to patch the game files
    msg "Comparing installed EFT <--> required EFT versions"
    if [[ "${installed_eft}" -ne "${mod_eft}" ]]; then
        msg "Incompatible EFT version found - Checking patcher compatibility..."
        # Check if target EFT version is lower, greater or equal to required EFT version
        if [[ "${patcher_eft}" -lt "${installed_eft}" ]]; then
            # No patcher available yet!
            warn "Looks like there's no patcher available for your EFT version"
            msg "    > This usually happens when EFT has been updated recently."
            msg "    > Please wait for the SPT team to generate a new patcher."
            msg "    > Usually, this will take less then 24 hours."
            err "No patcher available"
            
        elif [[ "${patcher_eft}" -gt "${installed_eft}" ]]; then
            # EFT is outdated!
            warn "Looks like your installed EFT version is out-of-date"
            msg "    > Please update your live EFT installation & try again"
            err "EFT is out-of-date"

        elif [[ "${patcher_eft}" -eq "${installed_eft}" ]]; then
            # Downpatcher is compatible!
            msg "Patcher is compatible"

            # Download latest patcher if needed
            [[ -z "${patcher_hash}" ]] && err "Missing patcher hash argument"
            if ! check_cached "${patcher_path}" "${patcher_hash}"; then
                msg "Downloading \"${patcher_url##*/}\"..."
                m_curl -L "${patcher_url}" -o "${patcher_path}"
                check_hash "${patcher_path}" "${patcher_hash}" || err "File \"${patcher_path##*/}\" is corrupted"
            fi

            # Extract latest patcher to tmp directory
            local archive_name="${patcher_path##*/}"
            local patcher_tmp_dir="${TMP_DIR}/${archive_name%.*}"
            msg "Extracting \"${archive_name}\"..."
            m_7z "${patcher_path}" "${patcher_tmp_dir}"

            # Copy EFT files
            msg "Copying game files to \"${SPT_DIR}\""
            m_cp "${EFT_DIR}/" "${SPT_DIR}"

            # Move patcher files to install directory
            msg "Copying patch files to \"${SPT_DIR}\""
            local patch_dir="$(find "${patcher_tmp_dir}" -type d -name '*SPT_Patches*')"
            m_cp "${patch_dir}" "${SPT_DIR}/SPT_Patches" || err "Failed to copy patch files" 

            # Patch game files
            opt_patch "${SPT_DIR}"
        else
            msg "Installed EFT version is compatible with \"SPT ${mod_version}\""
            msg "Copying game files to \"${SPT_DIR}\""
            m_cp "${EFT_DIR}/" "${SPT_DIR}"
        fi
    fi

    # Check for cached mod archive
    if ! check_cached "${mod_path}" "${mod_hash}"; then
        msg "Downloading \"${mod_url##*/}\"..."
        m_curl -L "${mod_url}" -o "${mod_path}"
        check_hash "${mod_path}" "${mod_hash}" || err "File \"${mod_path##*/}\" is corrupted"
    fi

    # Extract mod archive to install directory
    msg "Extracting \"${mod_path##*/}\" archive..."
    m_7z "${mod_path}" "${SPT_DIR}"
}


# # # # # # # # # # # # #
#  Uninstall functions  #
# # # # # # # # # # # # #

uninstall_eft() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${BSG_DIR}" ]] && msg "EFT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"Escape from Tarkov\" from your system!${RESET}"
        msg "Prefix directory: ${UNDERLINE}${WINEPREFIX}${RESET}"
        yesno "Do you want to continue?" || m_exit 0
    fi

    msg "Uninstalling \"Escape from Tarkov\"..."
    m_rm -r "${BSG_DIR}"

    msg "Removing \"BSG Launcher\" shortcut..."
    [[ -f "${SHORTCUT[bsg-launcher]}" ]] && m_rm "${SHORTCUT[bsg-launcher]}"

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_spt() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${SPT_DIR}" ]] && msg "SPT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"SPTarkov\" from your system!${RESET}"
        msg "SPT directory: ${UNDERLINE}${SPT_DIR}${RESET}"
        yesno "Do you want to continue?" || m_exit 0
    fi

    msg "Uninstalling \"SPTarkov\"..."
    m_rm -r "${SPT_DIR}"

    msg "Removing \"SPTarkov\" shortcuts..."
    [[ -f "${SHORTCUT[spt-server]}" ]] && m_rm "${SHORTCUT[spt-server]}"
    [[ -f "${SHORTCUT[spt-launcher]}" ]] && m_rm "${SHORTCUT[spt-launcher]}"

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_prefix() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${WINEPREFIX}" ]] && msg "Prefix directory does not exist" && return 0
    msg "Removing Prefix directory: \"${WINEPREFIX}\""
    m_rm -r "${WINEPREFIX}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


# # # # # # # # # # # #
#   Option functions  #
# # # # # # # # # # # #

opt_install() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov install spt 
    local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) install_eft ;;
        spt|sptarkov) install_spt "${CONFIG[install-mode]}" ;;
        help|-h|--help) opt_help "install";;
        "") err "Option \"install\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_uninstall() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov uninstall spt 
    local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) uninstall_eft ;;
        spt|sptarkov) uninstall_spt ;;
        all)
            # Ask for confirmation
            if ! [ "${NO_PROMPT}" = 1 ]; then
                msg "${BOLD}This action will remove the installed wine prefix!${RESET}"
                msg "The following directory will be deleted ${BOLD}permanently${RESET}:"
                msg "${UNDERLINE}${WINEPREFIX}${RESET}"
                yesno "Do you want to continue?" || m_exit 0
            fi
            uninstall_prefix 1
            for shortcut in "${!SHORTCUT[@]}"; do
                msg "Removing \"${shortcut}\" shortcut..."
                [[ -f "${SHORTCUT[${shortcut}]}" ]] && m_rm "${SHORTCUT[${shortcut}]}"
            done
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        help|-h|--help) opt_help "uninstall";;
        "") err "Option \"uninstall\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_update() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov update spt 
    # TODO: Gotta check somehow if a BLEEDING EDGE version is installed!
    # TODO: Add a `-f / --force` switch to force updates
    local option="$1" && shift
    case "${option}" in
        spt|sptarkov)
            local inst_eft inst_mod_eft inst_spt
            local upd_eft upd_version upd_url upd_hash
            local major minor patch

            # Check if EFT & SPT are installed
            if ! check_eft_installed; then err "Escape from Tarkov is not installed"; fi
            if [[ -z "${SPT_DIR}" ]] || [[ ! -d "${SPT_DIR}" ]]; then msg "SPTarkov is not installed" && m_exit 0; fi

            # Check if an older SPT version is installed
            if [[ ! -d "${SPT_DIR}/SPT" && -d "${SPT_DIR}/SPT_Data" ]]; then
                warn "Looks like a \"LTS\" SPT version is installed!"
                msg "   > Updating \"LTS\" versions is not support."
                err "Unsupported SPT version"
            fi

            # Get required metadata for mod release
            if ! check_ttl "${MOD_JSON_PATH}"; then
                msg "Downloading \"RELEASE\" metadata..."
                m_curl -sL "${URL[mod-json]}" -o "${MOD_JSON_PATH}"
            fi

            # Get infos about the current SPT installation
            inst_spt=$( get_file_version "${SPT_DIR}/SPT/SPT.Server.exe" ) || err "Failed to get installed SPT version" "$?"
            inst_spt=$( echo "${inst_spt}" | cut -d "." -f1-3 )
            inst_mod_eft=$( get_file_version "${SPT_DIR}/EscapeFromTarkov.exe" ) || err "Failed to get mod EFT version" "$?"
            inst_mod_eft=$( echo "${inst_mod_eft}" | cut -d "." -f4 )

            # Get infos about the latest SPT version
            upd_eft=$( jq -r '.ClientVersion' "${MOD_JSON_PATH}" ) || err "Failed to get required EFT version for SPT" "$?"
            upd_version=$( jq -r '.AkiVersion' "${MOD_JSON_PATH}" ) || err "Failed to get remote SPT version" "$?"
            upd_url=$( jq -r '.Mirrors[].DownloadUrl' "${MOD_JSON_PATH}" ) || err "Failed to get SPT download url" "$?"
            upd_hash=$( jq -r '.Mirrors[].Hash' "${MOD_JSON_PATH}" ) || err "Failed to get SPT archive hash" "$?"

            msg "Installed SPT version is \"${inst_spt}\""
            msg "Latest SPT version is \"${upd_version}\""

            if [[ $( echo "${upd_version}" | cut -d "." -f1 ) -gt $( echo "${inst_spt}" | cut -d "." -f1 ) ]]; then major=1; fi
            if [[ $( echo "${upd_version}" | cut -d "." -f2 ) -gt $( echo "${inst_spt}" | cut -d "." -f2 ) ]]; then minor=1; fi
            if [[ $( echo "${upd_version}" | cut -d "." -f3 ) -gt $( echo "${inst_spt}" | cut -d "." -f3 ) ]]; then patch=1; fi

            if [[ "${upd_version}" == "${inst_spt}" ]]; then
                msg "${BOLD}SPT is up-to-date.${RESET}" && m_exit 0
            elif [[ $major == 1 ]]; then
                {   msg "${BOLD}${YELLOW}A new major release is available!${RESET}"
                    msg "   > ${BOLD}${YELLOW}NOTE${RESET}: User profiles & mods usually are not compatible for major updates."
                    msg
                    msg "   ${BOLD}Please check out the release notes & re-install SPT manually:${RESET}"
                    msg "   > ${URL[spt-release]}/tag/${upd_version}"
                    msg
                    msg "   1. Update the additions script with: ${BOLD}${TITLE} self-update${RESET}"
                    msg "   2. Backup or delete your old SPTarkov directory in \"${SPT_DIR}\""
                    msg "   3. Update Escape from Tarkov inside the BSG Launcher"
                    msg "   4. Re-install the latest SPT version with: ${BOLD}${TITLE} install spt${RESET}"
                } | more
            elif [[ $minor == 1 ]]; then
                {   msg "${BOLD}${YELLOW}A new minor release is available!${RESET}"
                    msg "   > ${BOLD}${YELLOW}NOTE${RESET}: User profiles & mods might not be compatible."
                    msg
                    msg "   ${BOLD}Please check out the release notes & update / re-install SPT manually:${RESET}"
                    msg "   > ${URL[spt-release]}/tag/${upd_version}"
                    msg
                    msg "   ${BOLD}How to update:${RESET}"
                    msg "   1. Download the latest release archive: ${upd_url}"
                    msg "   2. Extract its content into \"${SPT_DIR}\" & override when asked"
                    msg
                    msg "   ${BOLD}How to re-install:${RESET}"
                    msg "   1. Backup or delete your old SPTarkov directory in \"${SPT_DIR}\""
                    msg "   2. Update Escape from Tarkov inside the BSG Launcher"
                    msg "   3. Re-install the latest SPT version with: ${BOLD}${TITLE} install spt${RESET}"
                }
            elif [[ $patch == 1 ]]; then
                {   msg "${BOLD}${YELLOW}A new patch release is available!${RESET}"
                    msg "   ${BOLD}Please check out the release notes:${RESET}"
                    msg "   > ${URL[spt-release]}/tag/${upd_version}"
                    yesno "Do you want to install the update?" || m_exit 0
                }
                msg "${BOLD}Updating SPT to version \"${upd_version}\" ...${RESET}"
                
                # Check for cached mod archive
                if ! check_cached "${MOD_PATH}" "${upd_hash}"; then
                    # Download archive
                    msg "Downloading mod archive..."
                    m_curl -L "${upd_url}" -o "${MOD_PATH}"

                    # Make sure the file is good to use
                    check_hash "${MOD_PATH}" "${upd_hash}" || err "File \"${MOD_PATH}\" is corrupted"
                fi

                # Extract mod archive to install directory
                msg "Extracting \"mod\" archive..."
                m_7z "${MOD_PATH}" "${SPT_DIR}"

                msg "${GREEN}${BOLD}Update successful!${RESET}"
            else
                err "Unhandled exception"
            fi
        ;;
        additions|script) opt_selfupdate ;;
        help|-h|--help) opt_help "update";;
        "") err "Option \"update\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_patch() {
    msg "Patching game files..."
    local files_total
    local target_path="${1:-"${SPT_DIR}"}"
    local source_path="${2:-"${target_path}"}"
    target_path=$( realpath -m "${target_path%/}" )
    source_path=$( realpath -m "${source_path%/}" )

    # Fail if the target director does not exist
    [[ -z "${target_path}" ]] && err "Target path is not set"
    [[ ! -d "${target_path}" ]] && err "Target directory \"${target_path}\" does not exist"

    # Make sure all native dependencies are installed
    check_native_deps

    # Search in optional SOURCE directory
    if [ "$( find "${source_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        source_path="${source_path}"
    # Search in TARGET directory
    elif [ "$( find "${target_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        source_path="${target_path}"
    else
        err "Unable to locate \"SPT_Patches\" directory in \"${source_path}\""
    fi

    local progress=1
    files_total=$( find "${source_path}/SPT_Patches" \( -type f -printf x \) | wc -c )

    # Iterate files
    echo; find "${source_path}/SPT_Patches" \( -type f \) -print0 | while IFS= read -r -d '' source; do 
        local progress_string="[${progress}/${files_total}]"
        # Isolate the operation extension
        local extension="${source##*.}"
        # Isolate sub-directories of SPT_Patches
        local trimmed="${source#*SPT_Patches/}"
        # Remove operation extension to get actual file name
        trimmed="${trimmed%.*}"

        local output="${target_path}/${trimmed}"
        local target="${output}.decoded"
        local dir_path="${output%/*}"

        case "$extension" in
            "delta")
                msg -o "${progress_string} (*) Patching: ${trimmed##*/}"
                hpatchz "${output}" "${source}" "${target}" >/dev/null 2>> "${LOG_PATH}" || return 1
                # Remove old file and replace with .decoded file
                [[ ! -f "${target}" ]] && return 1
                rm "${output}" || return 1
                m_mv "${target}" "${output}" || return 1
            ;;
            "del")
                msg -o "${progress_string} (-) Deleting: ${trimmed##*/}"
                rm "${output}" || return 1
                if [[ -z "$( m_ls -A "${dir_path}" )" ]]; then
                    msg -o "${progress_string} (-) Deleting directory: ${dir_path##*/}"
                    rm -r "${dir_path}" || return 1
                fi
            ;;
            "new")
                msg -o "${progress_string} (+) Adding: ${trimmed##*/}"
                if [[ ! -d "${dir_path}" ]]; then
                    msg -o "${progress_string} (+) Adding directory: ${dir_path##*/}"
                    m_mkdir "${dir_path}"
                fi
                cp "${source}" "${output}" || return 1
            ;;
            *)
                return 1
            ;;
        esac
        progress=$((progress+1))
    done

    local status=$?
    if [[ "$status" -ne "0" ]]; then
        # Failed patching
        m_rm -r "${SPT_DIR}" && err "Failed to patch game files" $status
    fi
    
    # Clean up patcher files
    if [[ "${target_path}" == *"${source_path}"* ]]; then
        msg "Cleaning up patch files..."
        [[ -d "${source_path}/SPT_Patches" ]] && rm -r "${source_path}/SPT_Patches"
        [[ -f "${source_path}/patcher.exe" ]] && rm -r "${source_path}/patcher.exe"
    fi

    msg "Done patching game files!"
}


opt_guided_install() {
    local input prefix_path
    # Overview
    {
        msg "░█▀▀░█▀█░▀█▀░░░█▀█░█▀▄░█▀▄░▀█▀░▀█▀░▀█▀░█▀█░█▀█░█▀▀"
        msg "░▀▀█░█▀▀░░█░░░░█▀█░█░█░█░█░░█░░░█░░░█░░█░█░█░█░▀▀█"
        msg "░▀▀▀░▀░░░░▀░░░░▀░▀░▀▀░░▀▀░░▀▀▀░░▀░░▀▀▀░▀▀▀░▀░▀░▀▀▀"
        opt_version
        msg
        msg "${BOLD}${BLUE}Hello mercenary!${RESET}"
        msg
        msg "${BOLD}${YELLOW}This CLI installer will perform the following steps:${RESET}"
        msg " ~> Install latest GE-Proton (if not installed already)"
        msg " ~> Setup the wine prefix, install dependencies & apply game specific workarounds"
        msg " ~> Install the BSG Launcher"
        msg " ~> Install SPTarkov"
        msg " ~> Add application menu shortcuts"
        msg
    } | more
    
    while true; do
        # Choose a custom prefix install location
        msg "${BOLD}${BLUE}[Q] Where do you want to install the wine prefix (Leave blank for \"${WINEPREFIX}\")${RESET}"
        msg "(Enter ${BOLD}q${RESET} or press ${BOLD}ctrl-c${RESET} to cancel)"
        input=$(read_input)
        if [[ -n "$input" ]]; then
            # HACK: Special input check for canceling the action
            [[ "${input:0:1}" =~ ^[Qq]+$ ]] && m_exit
            prefix_path="${input//[~]/"$HOME"}"
        fi

        # Set and check the prefix path
        set_prefix "${prefix_path:-${WINEPREFIX}}"

        # Perform some checks
        check_eft_running;  check_native_deps; check_aspnet

        # Initialize the prefix if needed
        init_prefix
        
        local install_eft=0
         # Ask to skip EFT installation if it's already installed
        if check_eft_installed; then
            msg; yesno "\"Escape from Tarkov\" is already installed. Do you want to skip this step?"
            [[ "$?" == 0 ]] && install_eft=1
        fi

        # Install EFT
        if [[ "$install_eft" == 0 ]]; then
            opt_install eft
            # Interactive - Users need to manually install the game client inside the BSG Launcher
            msg "${BOLD}${BLUE}Please log-in to your BSG account, install Escape from Tarkov & close the launcher to continue...${RESET}"
            opt_run bsg-launcher || err "Failed to launch \"BSG Launcher\""
            # Update EFT path
            if ! check_eft_installed; then
                warn "Looks like EFT is not installed."
                msg "${YELLOW}> Make sure you installed the game & you can see the \"Play\" button inside the BSG Launcher.${RESET}"
                err "Failed to get EFT install path"
            fi
        fi

        # Install SPT
        opt_install spt

        # Ask to install the script for ease of use
        msg; opt_selfinstall

        # All done!
        msg; msg "${BOLD}${GREEN}All done! ※\(^o^)/※${RESET}"
        msg
        msg "${BOLD}${BLUE}You need help or just wanna hang out with ${GREEN}THE NERDS${RESET}?:${RESET}"
        msg "   ${URL[discord]}"
        msg
        msg "${BOLD}${BLUE}Get your favorite mods from ${GREEN}THE FORGE${RESET}:"
        msg "   ${URL[forge]}"
        return 0
    done
}


opt_run() {
    # SYNTAX: spt-additions -e MANGOHUD=1 run spt-launcher 
    local option="$1" && shift
    [[ -z "${option}" ]] && err "Option \"run\" requires an argument"
    
    case "${option}" in
        eft|tarkov|bsg|bsg-launcher)
            local args="--disable-software-rasterizer"
            msg "Launching BSG Launcher..."
            cd "${BSG_DIR}/BsgLauncher" && m_umu "BsgLauncher.exe" "$args" "$@"
        ;;
        launcher)
            check_eft_running
            msg "Launching SPT Launcher..."
            cd "${SPT_DIR}" && m_umu "SPT.Launcher.exe" "$@"
        ;;
        server)
            check_eft_running
            msg "Launching SPT Server..."
            cd "${SPT_DIR}" && "./launch-server.sh" "$@"
        ;;
        help|-h|--help) opt_help "run";;
        "") err "Option \"run\" requires an argument" ;;
        *)
            local cmd="$( echo "${option} $@" | xargs )"
            msg "Running command: \"${cmd}\"..."
            m_umu "${option}" "$@"
        ;;
    esac
}


opt_dlloverride() {
    local dll_name="${1}"; local override_type="${2:-"native,builtin"}"
    [[ -z "${dll_name}" ]] && err "Option \"dlloverride\" requires a DLL name as first argument"
    [[ ! "${dll_name}" =~ ^[A-Za-z0-9_-]+$ ]] && err "DLL name contains invalid characters: \"${dll_name}\""
    case "${override_type}" in
        n|native) override_type="native" ;;
        b|builtin) override_type="builtin" ;;
        d|disabled) override_type="disabled" ;;
        native,builtin|n,b) override_type="native,builtin" ;;
        builtin,native|b,n) override_type="builtin,native" ;;
        *) err "Invalid override type \"${override_type}\"" ;;
    esac
    msg "Setting \"${dll_name}\" DLL override (${override_type})..."
    m_umu reg add "HKCU\\Software\\Wine\\DllOverrides" /v "${dll_name}" /t "REG_SZ" /d "${override_type}" /f 1>> "${LOG_PATH}"
}


opt_env() {
    # SYNTAX: spt-additions env add MANGOHUD=1
    local key value
    local option="$1"; local keyval="$2" && shift 2
    key=$( echo "${keyval}" | cut -d "=" -f1 )
    value=$( echo "${keyval}" | cut -d "=" -f 2- )
    [[ "${key}" == "${value}" ]] && unset value

    # If the key begins with a '-' we actually wanna unset it!
    if [[ $key == -* ]]; then
        key="${key:1}"
        opt_env unset "${key}"
        return
    fi

    case "${option}" in
        set|add)
            if [[ "${ENV[$key]}" ]]; then msg "Updating environment variable: \"${keyval}\""
            else msg "Adding environment variable: \"${keyval}\""; fi
            set_value env "${key}=${value}"
        ;;
        unset|remove)
            [[ ! "${ENV[$key]}" ]] && msg "Environment variable \"${key}\" is not set" && return
            msg "Removing environment variable: \"$keyval\""
            unset_value env "${key}"
        ;;
        list|-l) get_env ;;
        help|h|-h|--help) opt_help "env" ;;
        "") err "Option \"env\" requires an argument" ;;
        *) err "Invalid switch \"${option}\"" ;;
    esac
}


add_app_shortcut() {
    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "app-shortcut" ]] && err "Failed to load shortcut data from cache array"
    if [[ -f "${CACHE[path]}" ]]; then msg "Updating \"${CACHE[name]}\" application shortcut..."
    else msg "Creating \"${CACHE[name]}\" application shortcut..."; fi

    # Remove existing shortcut
    [[ -f "${CACHE[path]}" ]] && m_rm "${CACHE[path]}"

    # Prepare environment string
    local env_string
    [[ -n "${CACHE[env]}" ]] && env_string="env ${CACHE[env]}"

    # Generate the exec string
    local exec_string
    case "${CACHE[exe_path]}" in
        *exe*|*bat*|*msi*) exec_string="Exec=${env_string}\"${UMU_PATH}\" \"${CACHE[exe_path]}\" ${CACHE[args]}" ;;
        *) exec_string="Exec=${env_string}\"${CACHE[working_dir]}/${CACHE[exe_path]}\" ${CACHE[args]}" ;;
    esac

    # Write desktop file
    {   echo "[Desktop Entry]"
        echo "Categories=Game;ActionGame;Simulation"
        echo "Path=${CACHE[working_dir]}"
        echo "${exec_string}"
        echo "Name=${CACHE[name]}"
        echo "Icon=${CACHE[icon]}"
        echo "Type=Application"
    } > "${CACHE[path]}" && m_chmod +x "${CACHE[path]}"
}


opt_shortcut() {
    # SYNTAX: spt-additions -p "" -e "" -a "" shortcut spt-launcher
    local option="$1" && shift
    local env=$( get_env )

    case "${option}" in
        eft|bsg|bsg-launcher)
            CACHE[_id]="app-shortcut"
            CACHE[name]="BSG - Launcher"
            CACHE[exe_path]="BsgLauncher.exe"
            CACHE[env]="${env}"
            CACHE[args]="--disable-software-rasterizer"
            CACHE[working_dir]="${BSG_DIR}/BsgLauncher"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="bsg_launcher"
            add_app_shortcut
        ;;
        launcher)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Launcher"
            CACHE[exe_path]="SPT.Launcher.exe"
            CACHE[env]="${env}"
            CACHE[args]=""
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_launcher"
            add_app_shortcut
        ;;
        server)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Server"
            CACHE[exe_path]="launch-server.sh"
            CACHE[env]=""
            CACHE[args]=""
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_server"
            add_app_shortcut
        ;;
        lts-server)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Server"
            CACHE[exe_path]="SPT.Server.exe"
            CACHE[env]="${env}"
            CACHE[args]=""
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_server"
            add_app_shortcut
        ;; 
        spt|sptarkov)
            opt_shortcut launcher
            if [[ "${CONFIG[install-mode]}" == "lts" ]]; then
                opt_shortcut lts-server
            else
                opt_shortcut server
            fi
        ;;
        all)
            opt_shortcut bsg-launcher;  opt_shortcut launcher
            if [[ "${CONFIG[install-mode]}" == "lts" ]]; then
                opt_shortcut lts-server
            else
                opt_shortcut server
            fi
        ;;
        help|-h|--help) opt_help "shortcut";;
        "") err "Option \"shortcut\" requires an argument" ;;
        *)
            # Create custom shortcut
            local exe_path=$( realpath -m "${option}" )
            [[ ! -f "${exe_path}" ]] && err "File \""${exe_path}"\" does not exist"
            local name="${option##*/}"; name="${name%.*}"
            local working_dir="${option%/*}"
            CACHE[_id]="app-shortcut"
            CACHE[name]="${name}"
            CACHE[exe_path]="${exe_path}"
            CACHE[env]="${env}"
            CACHE[args]="$*"
            CACHE[working_dir]="${working_dir}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]=$( echo "${CACHE[name]}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' )
            add_app_shortcut
        ;;
    esac
}


opt_clean() {
    # SYNTAX: spt-additions clean all --no-prompt
    local option="$1" && shift
    local dir_path

    case "${option}" in
        cache) dir_path="${CACHE_DIR}" ;;
        config) dir_path="${CONFIG_DIR}" ;;
        data) dir_path="${DATA_DIR}" ;;
        all)
            # Warn user before continuing
            {   msg "${BOLD}This action will remove all configs & cached files!${RESET}"
                msg "The following directories will be deleted ${BOLD}permanently${RESET}:"
                msg "    > ${UNDERLINE}${DATA_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CACHE_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CONFIG_DIR}${RESET}"
            } | more
            yesno "Do you want to continue?" || m_exit 0
            export NO_PROMPT=1
            opt_clean data;  opt_clean config;  opt_clean cache
            msg "${GREEN}Done!${RESET}"
            m_exit 0
        ;;
        help|-h|--help) opt_help "clean"; m_exit 0 ;;
        "") err "Option \"clean\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac

    # Warn user before continuing
    if [[ -n "${dir_path}" ]]; then
        if [[ "${NO_PROMPT}" != 1 ]]; then
            {   msg "${BOLD}This action will remove the following directory:${RESET}"
                msg "    > ${UNDERLINE}${dir_path}${RESET}"
            } | more
            yesno "Do you want to continue?" || m_exit 0
        fi
        msg "Removing ${option} directory: \"${dir_path}\"..."
        [[ -d "${dir_path}" ]] && m_rm -r "${dir_path}"
    fi
}


opt_selfinstall() {
    local bin_paths=( "${HOME}/.local/bin" "${HOME}/bin" )
    [[ -n "${XDG_BIN_HOME}" ]] && bin_paths+=( "${XDG_BIN_HOME}" )

    # Check if PATH contains any of the user bin paths
    for path in "${bin_paths[@]}"; do
        if [[ -n $( echo "${PATH}" | grep "${path}" ) ]]; then break; fi
        msg "${BOLD}${GREEN}${TITLE}${YELLOW} provides useful CLI commands for managing your wine prefix!${RESET}"
        msg "   > Consider adding the script to your PATH variable for ease of use!"
        msg "   > Run \"${GREEN}${TITLE} -h${RESET}\" after installing it for more details."
        return 0
    done

    # Check if the script is already installed
    for path in "${bin_paths[@]}"; do
        if [[ -f "${path}/${TITLE}" ]]; then
            msg "${BOLD}${GREEN}${TITLE}${RESET} is already installed in:"
            msg "   > ${path}"
            return 0
        fi
    done

    # Load required metadata
    load_metadata

    # Search for bin paths in the PATH environment variable
    for path in "${bin_paths[@]}"; do
        msg "${BOLD}Remote hash${RESET}:   ${METADATA[additions-hash]}"
        if [[ -z $( echo "${PATH}" | grep "${path}" ) ]]; then continue; fi

        # Found a user bin path
        msg "${BOLD}${YELLOW}Found \"${path}\" in the PATH environment variable.${RESET}"
        msg "   > ${GREEN}${TITLE}${RESET} provides useful CLI commands to manage your wine prefix."
        yesno "Do you want to install ${TITLE} into the user bin directory (\"${path}\")?"

        if [[ "$?" == 0 ]]; then
            [[ ! -d "${path}" ]] && m_mkdir "${path}"
            msg "Downloading ${TITLE}..."
            cd "${TMP_DIR}" && m_curl -sLO "${URL[installer-script]}"
            if ! check_hash "${TMP_DIR}/${TITLE}" "${METADATA[additions-hash]}"; then
                err "Downloaded script is corrupted"
            fi
            msg "Installing ${TITLE}..."
            m_mv "${TMP_DIR}/${TITLE}" "${path}/${TITLE}"
            m_chmod +x "${path}/${TITLE}"
            msg "${GREEN}${BOLD}Done! ※\(^o^)/※${RESET}"
            installed=1
            return 0
        else
            break
        fi
    done
}


opt_selfupdate() {
    local current_hash=$( get_hash "${SCRIPT_DIR}/${TITLE}" ) || err "Failed to get script hash"

    # Load required metadata
    load_metadata

    msg "${BOLD}Current hash${RESET}:  ${current_hash}"
    msg "${BOLD}Remote hash${RESET}:   ${METADATA[additions-hash]}"
    if [[ "${current_hash}" == "${METADATA[additions-hash]}" ]]; then
        msg "${BOLD}The script is up-to-date.${RESET}"
        return 0
    else
        if [[ "${NO_PROMPT}" != 1 ]]; then
            msg "> ${BOLD}The script will attempt to download the latest version from:${RESET}"
            msg "> ${UNDERLINE}${URL[installer-script]}${RESET}"
            msg
            yesno "Do you want to continue?" || m_exit 0
        fi
        msg "Downloading ${TITLE}..."
        cd "${TMP_DIR}" && m_curl -sLO "${URL[installer-script]}"
        if ! check_hash "${TMP_DIR}/${TITLE}" "${METADATA[additions-hash]}"; then
            err "Downloaded script is corrupted"
        fi
        msg "Installing ${TITLE}..."
        m_mv "${TMP_DIR}/${TITLE}" "${SCRIPT_DIR}/${TITLE}"
        m_chmod +x "${SCRIPT_DIR}/${TITLE}"
        msg "${GREEN}${BOLD}Done! ※\(^o^)/※${RESET}"
    fi
}


opt_version() {
    msg "${BOLD}Version: ${RESET}${VERSION} (${DATE})"
    local script_hash=$( get_hash "${SCRIPT_DIR}/${TITLE}" ) || err "Failed to get script hash"
    msg "${BOLD}Hash: ${RESET}${script_hash}"
}


opt_help() {
    local option="${1}"
    case "${option}" in
        install)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|tarkov                 - Install the BSG Launcher"
                msg "spt|sptarkov                   - Install SPTarkov"
                msg 
                msg "Available install modes for SPTarkov:"
                msg "${BOLD}native${RESET}          - Uses a native install method to install the latest SPTarkov release"
                msg "${BOLD}proton${RESET}          - Uses Proton to install the latest SPTarkov release"
                msg "${BOLD}lts${RESET}             - Installs the long-term-support (LTS) version of SPTarkov"
                opt_help switches
            } | more
        ;;
        uninstall)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|tarkov                 - Uninstall the BSG Launcher"
                msg "spt|sptarkov                   - Uninstall SPTarkov"
                msg "all                            - Uninstall everything (prefix, EFT & SPT)"
                opt_help switches
            } | more
        ;;
        update)
            {   msg "${BOLD}Available options:${RESET}"
                msg "spt|sptarkov                   - Update SPTarkov"
                msg "additions|script               - Update this additions script"
                opt_help switches
            } | more
        ;;
        patch)
            {   msg "Downpatch EFT game files to a supported version for SPTarkov"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE patch [target_path] [source_path]${RESET}"
                msg
                msg "target_path - Destination install directory (defaults to \"${DEFAULT_SPT_DIR}\")"
                msg "source_path - Directory containing SPT_Patches (defaults to target_path)"
                msg
                msg "Example: ${YELLOW}$TITLE patch \"${DEFAULT_SPT_DIR}\" \"~/Downloads/patcher\"${RESET}"
                opt_help switches
            } | more
        ;;
        run)
            {   msg "Run EFT/SPT or custom commands inside the prefix"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] run [eft|launcher|server|custom_command] [ARGS...]${RESET}"
                msg
                msg "${BOLD}Examples:${RESET}"
                msg "${YELLOW}$TITLE run launcher${RESET}"
                msg "${YELLOW}$TITLE run winecfg${RESET}"
                msg "${YELLOW}$TITLE run winetricks [VERBS...]${RESET}"
                msg "${YELLOW}$TITLE run ./custom.exe --example-arg${RESET}"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|bsg-launcher           - Run the BSG Launcher"
                msg "launcher                       - Run the SPT Launcher"
                msg "server                         - Run the SPT Server"
                msg "custom_command                 - Run a custom command inside the prefix"
                opt_help switches
            } | more
        ;;
        dlloverride)
            {   msg "Add a DLL override to the wine prefix"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] dlloverride [DLL_NAME] [override_type]${RESET}"
                msg
                msg "${BOLD}Example:${RESET}"
                msg "${YELLOW}$TITLE dlloverride d3d11 n,b${RESET}"
                opt_help switches
            } | more
        ;;
        env)
            {   msg "Set, unset and list environment variables for the wine prefix"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "set|add [KEY=VALUE]            - Set or add an environment variable"
                msg "unset|remove [KEY]             - Unset or remove an environment variable"
                msg "list|-l                        - List all active environment variables"
                opt_help switches
            } | more
        ;;
        shortcut)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|bsg-launcher           - Create/update BSG Launcher shortcut"
                msg "launcher                       - Create/update SPT Launcher shortcut"
                msg "server                         - Create/update SPT Server shortcut"
                msg "spt|sptarkov                   - Create/update all SPT shortcuts"
                msg "all                            - Create/update all available shortcuts"
                msg "custom_executable              - Create/update custom shortcuts"
                opt_help switches
            } | more
        ;;
        clean)
            {   msg "Clean installer and prefix files"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "cache                          - Remove cached files"
                msg "config                         - Remove configuration files"
                msg "data                           - Remove installer data files"
                msg "all                            - Remove all of the above"
                opt_help switches
            } | more
        ;;
        self-install)
            {   msg "Install this additions script to a local bin directory for ease of use"
                msg 
            } | more
        ;;
        self-update)
            {   msg "Update this additions script to the latest version"
                msg
            } | more
        ;;
        switches)
            {   msg "${BOLD}Available switches:${RESET}"
                msg "-p <path>                      - Specify a custom wine prefix path"
                msg "-e <KEY=VALUE>                 - Set an environment variable for the prefix"
                msg "-m <mode>                      - Set the install mode for SPTarkov (native, proton, lutris)"
                msg "--no-prompt                    - Disable all prompts and assume \"yes\" as answer"
                msg "--no-ansi                      - Disable ANSI colors in output"
                msg "-h|--help                      - Show help message"
                msg "-v|--version                   - Show version info"
            } | more
        ;;
        "") 
            {   msg "${BOLD}${TITLE} - Standalone EFT/SPTarkov installer & configuration tool${RESET}"
                msg
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] <option> [ARGS...]${RESET}"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "install                        - Install EFT/SPT"
                msg "uninstall                      - Uninstall EFT/SPT"
                msg "update                         - Update EFT/SPT or this script"
                msg "run                            - Run EFT/SPT or custom commands inside the prefix"
                msg "dlloverride                    - Add a DLL override to the wine prefix"
                msg "env                            - Set, unset and list environment variables for the wine prefix"
                msg "shortcut                       - Create application menu shortcuts"
                msg "patch                          - Downpatch EFT game files to a supported version for SPTarkov"
                msg "clean                          - Clean installer and prefix files"
                msg "self-install                   - Install this script to a local bin directory for ease of use"
                msg "self-update                    - Update this script to the latest version"
                msg "version                        - Print the VERSION info message"
                msg "help                           - Print this help message or help for a specific option"
                msg
                msg "Run \"${BOLD}$TITLE help <option>${RESET}\" for more information about a specific option."
            } | more
        ;;
        *) msg "Invalid option: ${option}" ;;
    esac
}


# # # # # # # # # # # #
# Main loop functions #
# # # # # # # # # # # #

handle_opts() {
    # Handle switches
    while getopts ":p:e:a:m:h:v:-:" subopt; do
        case ${subopt} in
            p) set_prefix "${OPTARG}" ;;
            e) opt_env set "${OPTARG}" ;;
            m)
                case "${OPTARG}" in
                    native|proton|lts|lutris)
                        msg "Setting install mode to \"${OPTARG}\"..."
                        set_value config "install-mode=${OPTARG}"
                    ;;
                    *) err "Invalid mode: ${OPTARG}" ;;
                esac
            ;;
            v) opt_version ;;
            h) opt_help ;;
            -*)
                case "${OPTARG}" in
                    no-prompt) export NO_PROMPT=1; msg "\"NO_PROMPT\" option set" ;;
                    no-ansi) export NO_ANSI=1; msg "\"NO_ANSI\" option set" ;;
                    self-install) opt_selfinstall ;;
                    self-update) opt_selfupdate ;;
                    version) opt_version ;;
                    help) opt_help ;;
                    *) err "Invalid switch: --${OPTARG}" ;;
                esac
            ;;
            :)
                case "${OPTARG}" in
                    h) opt_help ;;
                    v) opt_version ;;
                    *) err "Switch \"${OPTARG}\" requires an argument" ;;
                esac
            ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done
    shift $((OPTIND-1))

    local option="${1}" && shift
    
    case "${option}" in
        install|run|update|dlloverride)
            check_native_deps
            # Check & set the prefix path
            set_prefix "${WINEPREFIX}" 1>/dev/null
            # Initialize the prefix if it doesn't exist yet
            init_prefix
        ;;
        uninstall|shortcut) set_prefix "${WINEPREFIX}" 1>/dev/null ;;
    esac

    # Handle options
    case "${option}" in
        install) opt_install "$@" ;;
        uninstall) opt_uninstall "$@" ;;
        update) opt_update "$@" ;;
        patch) opt_patch "$@" ;;
        run) opt_run "$@" ;;
        dlloverride) opt_dlloverride "$@" ;;
        env) opt_env "$@" ;;
        shortcut) opt_shortcut "$@" ;;
        clean) opt_clean "$@" ;;
        self-update) opt_selfupdate ;;
        self-install) opt_selfinstall ;;
        version) opt_version ;;
        help) opt_help "$@";;
        "") [[ $OPTIND -eq 1 ]] && opt_guided_install ;;
        *) err "Invalid option: ${option}" ;;
    esac
}


main() {
    # Create dirs
    local dirs=( "${DATA_DIR}" "${RUNTIME_DIR}" "${CACHE_DIR}" "${CONFIG_DIR}" "${TMP_DIR}" "${ICO_DIR}" )
    for dir in "${dirs[@]}"; do [[ ! -d "${dir}" ]] && mkdir -p "${dir}"; done

    # Set default config variables
    if [[ ! -f "${CONFIG_PATH}" ]]; then
        set_value config "spt-path=${DEFAULT_SPT_DIR}"
        set_value config "install-mode=${DEFAULT_INSTALL_MODE}"
        save_array config
    fi

    # Set default environment variables
    if [[ ! -f "${ENV_PATH}" ]]; then
        set_value env "WINEPREFIX=${WINEPREFIX:-${DEFAULT_WINEPREFIX}}"
        set_value env "PROTONPATH=${PROTONPATH:-${DEFAULT_PROTONPATH}}"
        set_value env "DOTNET_ROOT="
        set_value env "DOTNET_BUNDLE_EXTRACT_BASE_DIR="
        set_value env "PROTON_USE_XALIA=0"
        save_array env
    fi

    # Remove old log file
    [[ -f "${LOG_PATH}" ]] && m_rm "${LOG_PATH}"

    # Load config files
    [[ -f "${CONFIG_PATH}" ]] && load_array config
    [[ -f "${ENV_PATH}" ]] && load_array env

    # Export paths
    export WINEDEBUG="${WINEDEBUG:-"+debugstr,err+all,fixme+all"}"
    export WINEPREFIX="${ENV[WINEPREFIX]:-${DEFAULT_WINEPREFIX}}"
    export PROTONPATH="${ENV[PROTONPATH]:-${DEFAULT_PROTONPATH}}"
    export PATH=$RUNTIME_DIR:$PATH

    # Handle command line arguments
    handle_opts "$@"
    m_exit 0
}

# Main entry
main "$@"
