#!/usr/bin/env bash

# # # # # # # # # 
# SPT-ADDITIONS #
# # # # # # # # # 

# MIT License
# Copyright (c) 2025 MadByte
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to
# do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# exit codes:
# 1: general error | 10: -d check failed | 11: -f check failed | 12: -z check failed | 13: m_7z failed
# 14: case char mismatch

# We don't want to run as root
if [[ "$( id -u )" -eq 0 ]]; then
    echo "This script is not supposed to be run as root!"
    exit 1
fi

# Shell options
shopt -s extglob

# Make sure to throw an error and exit on SIGINT
trap int INT; int() { warn "Interrupt received" && m_exit; }

readonly TITLE="spt-additions"
readonly VERSION="1.1.1"
readonly DATE="2026-01-04"

# ANSI codes
BOLD="\e[1m"; UNDERLINE="\e[2m"; RESET="\e[0m"
RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[36m"
YELLOW="\e[33m"; GRAY="\e[90m"

declare -A CONFIG ENV METADATA CACHE SHORTCUT

# System directories
readonly SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" && pwd )"
# Data dirs
readonly DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
readonly DATA_DIR="${DATA_HOME}/${TITLE}"
readonly ICO_DIR="${DATA_HOME}/icons/hicolor/256x256/apps"
readonly APP_DIR="${DATA_HOME}/applications"
readonly RUNTIME_DIR="${DATA_DIR}/runtime"
# Steam data dirs
readonly STEAM_DIR="${DATA_HOME}/Steam"
readonly COMPAT_DIR="${STEAM_DIR}/compatibilitytools.d"
# Cache dirs
readonly CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly CACHE_DIR="${CACHE_HOME}/${TITLE}"
readonly FILES_DIR="${CACHE_DIR}/files"
readonly METADATA_DIR="${CACHE_DIR}/metadata"
readonly TMP_DIR="${CACHE_DIR}/tmp"
# Config dirs
readonly CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly CONFIG_DIR="${CONFIG_HOME}/${TITLE}"

# Default setting variables
readonly DEFAULT_INSTALL_MODE="latest"
readonly DEFAULT_PROTONPATH="GE-Proton"
readonly DEFAULT_WINEPREFIX="${HOME}/Games/tarkov"
readonly DEFAULT_SPT_DIR="${HOME}/Games/SPTarkov"
readonly DEFAULT_STEAM_LIBRARY_PATH="${STEAM_DIR}/steamapps"

# File path variables
readonly SCRIPT_PATH="${SCRIPT_DIR}/${TITLE}"
readonly LOG_PATH="${CACHE_DIR}/installer.log"
readonly UMU_PATH=$( command -v umu-run || echo "${RUNTIME_DIR}/umu-run" )
readonly CONFIG_PATH="${CONFIG_DIR}/app.conf"
readonly ENV_PATH="${CONFIG_DIR}/env.conf"
readonly METADATA_PATH="${METADATA_DIR}/metadata.conf"
readonly MOD_PATH="${FILES_DIR}/spt.7z"
readonly LEGACY_MOD_PATH="${FILES_DIR}/legacy-spt.7z"
readonly PATCHER_PATH="${FILES_DIR}/patcher.7z"
readonly LEGACY_PATCHER_PATH="${FILES_DIR}/legacy-patcher.7z"
readonly MOD_JSON_PATH="${METADATA_DIR}/release.json"
readonly PATCHER_JSON_PATH="${METADATA_DIR}/mirrors.json"

# Metadata file
readonly METADATA_URL="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/main/scripts/metadata.conf"

# Shortcut paths
SHORTCUT[bsg-launcher]="${APP_DIR}/BSG - Launcher.desktop"
SHORTCUT[spt-launcher]="${APP_DIR}/SPT - Launcher.desktop"
SHORTCUT[spt-server]="${APP_DIR}/SPT - Server.desktop"


# # # # # # # # # #
# Alias functions #
# # # # # # # # # #

m_exit() {
    local status=${1:-$?}
    if [[ ${BASH_SUBSHELL} -eq 0 ]]; then
        save_array config;  save_array env
        [[ -d "${TMP_DIR}" ]] && m_rm -r "${TMP_DIR}"
    fi
    exit "${status}"
}


m_chmod() { chmod "$@" &>> "${LOG_PATH}" || err "Command \"chmod $*\" failed" "$?"; }
m_mkdir() { mkdir -p "$@" &>> "${LOG_PATH}" || err "Command \"mkdir -p $*\" failed" "$?"; }
m_ls() { ls "$@" 2>> "${LOG_PATH}" || err "Command \"ls $*\" failed" "$?"; }
m_mv() { mv "$@" &>> "${LOG_PATH}" || err "Command \"mv $*\" failed" "$?"; }
m_curl() { curl --connect-timeout 30 -f "$@" || err "Command \"curl --connect-timeout 30 -f $*\" failed" "$?"; }
m_umu() { "${UMU_PATH}" "$@" 2>> "${LOG_PATH}" || err "Command \"umu-run $*\" failed" "$?"; }
m_7z() { 7zzs "$@" 2>> "${LOG_PATH}" || err "Command \"7zzs $*\" failed" "$?"; }
m_tar() { tar "$@" 2>> "${LOG_PATH}" || err "Command \"tar $*\" failed" "$?"; }


m_rm() {
    local target_path; target_path="${@: -1}"
    [[ -z "${target_path}" ]] && err "Path variable is empty"
    check_target_path "${target_path}"
    rm "$@" || warn "Command \"rm $*\" failed"
}


m_cp() {
    local source_path="${1}"; local target_path="${2}"
    check_target_path "${target_path}"

    local progress=1
    local files_total; files_total=$( find "${source_path}" \( -type f -printf x \) | wc -c )

    if [[ -d "${source_path}" ]]; then
        # Iterate files & copy to target directory
        echo; find "${source_path}" \( -type f \) -print0 | while IFS= read -r -d '' source; do
            local filename="${source/#$source_path}"
            local output="${target_path}/${filename}"
            local progress_string="[${progress}/${files_total}]"
            msg -o "${progress_string} Copying: ${filename##*/}"
            [[ ! -d "${output%/*}" ]] && m_mkdir "${output%/*}"
            cp --reflink=auto "${source}" "${output}" &>> "${LOG_PATH}" || err "Command \"cp $*\" failed" "$?"
            progress=$((progress+1))
        done
    elif [[ -f "${source_path}" ]]; then
        cp --reflink=auto "${source_path}" "${target_path}" &>> "${LOG_PATH}" || err "Command \"cp $*\" failed" "$?"
    fi
}


m_extract() {
    local file_path="${1}"; [[ -z "${file_path}" ]] && err "Missing file_path argument"
    local target_path="${2:-"${file_path%/*}"}"
    local filename="${file_path##*/}"

    check_target_path "${target_path}"
    [[ ! -d "${target_path}" ]] && m_mkdir "${target_path}"

    msg "Extracting: ${filename}"
    case "${filename}" in
        # Extract archive
        *.zip*|*.7z*) m_7z x -aoa "${file_path}" -o"${target_path}" 1>/dev/null ;;
        *.tar*) m_tar -xf "${file_path}" -C "${target_path}" 1>/dev/null ;;
        *.deb*)
            m_7z x -aoa "${file_path}" -o"${target_path}" 1>/dev/null
            m_tar -xf "${file_path%/*}/data.tar" -C "${target_path}" 1>/dev/null
            m_rm "${file_path%/*}/data.tar"
        ;;
        *) err "Cannot extract file: \"${file_path}\"" ;;
    esac
}


m_download() {
    local force=0; local silent=0
    for opt in "${@}"; do
        case ${opt} in
            -f) force=1; shift 1 ;;
            -s) silent=1; shift 1 ;;
        esac
    done
    local url="${1}"; [[ -z "${url}" ]] && err "Missing url argument" 
    local target_path="${2}"; [[ -z "${target_path}" ]] && err "Missing target_path argument"
    local filename="${url##*/}"
    check_target_path "${target_path}"

    if [[ -d "${target_path}" ]]; then target_path="${target_path}/${filename}"
    else filename="${target_path##*/}"; fi

    if [[ ! -f "${target_path}" || $force -eq 1 ]]; then
        msg "Downloading: ${filename}..."
        if [[ $silent -eq 1 ]]; then m_curl -S -s --create-dirs -L "${url}" -o "${target_path}"
        else m_curl --create-dirs -L "${url}" -o "${target_path}"; fi
    fi
}


# # # # # # # # # # #
# Helper functions  #
# # # # # # # # # # #

msg() {
    case "$1" in
        # Override mode
        -o) local mode="o"; shift ;;
    esac

    local output="$*"
    local filtered_str; filtered_str=$( echo -e "${output}" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' )

    # Print to terminal
    case ${NO_ANSI} in
        1) echo "${filtered_str}" ;;
        *)
            case ${mode} in
                o) echo -e "\r\033[1A\033[0K│ ${output}" ;;
                *) echo -e "│ ${output}" ;;
            esac
        ;;
    esac

    # Write to log file
    if [[ -d "${CACHE_DIR}" && "${mode}" != "o" ]] ; then
        echo "[$TITLE] ${filtered_str}" &>> "${LOG_PATH}"
    fi
}


warn() {
    msg "${BOLD}${YELLOW}Warn: ${RESET}$1"
}


err() {
    local message="$1"; local status="${2:-"1"}"
    local pfx="${BOLD}${RED}ERROR ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}${message} (Exit code: ${status})" 1>&2
    msg "   ► See ${BOLD}\"${LOG_PATH}\"${RESET} for more details." 1>&2
    m_exit "$status"
}


yesno() {
    msg "${BOLD}${BLUE}[Q] $*${RESET} [y/n] "
    if [[ $NO_PROMPT == 1 ]]; then msg "NO_PROMPT variable set - returning 0" && return 0; fi
    while true; do
        read -r -p "│   ► " yn
        case $yn in
            [Yy]*) return 0 ;;  
            [Nn]*) return 1 ;;
        esac
    done
}


read_input() {
    if [[ $NO_PROMPT == 1 ]]; then msg "NO_PROMPT variable set - returning 0" && return 0; fi
    read -e -r -p "│    ► " input
    # HACK: Special input check for canceling the action
    [[ "${input:0:1}" =~ ^[Qq]+$ ]] && return 1
    printf "$input\n"
}


set_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key; key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    local value; value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"

    # Filter for invalid keys
    [[ -z "${key}" ]] && err "Missing key for array \"${array_name}\""
    [[ ! "${key}" =~ ^[A-Za-z0-9_-]+$ ]] && err "Key contains invalid characters: \"${key}\""
    [[ -n "${value}" && ! "${value}" =~ ^[\ A-Za-z0-9/@()/:.,_+=-]+$ ]] && err "Value contains invalid characters: \"${value}\""

    # Set value
    case "${array_name}" in
        config)
            [[ -z "${value}" ]] && err "Missing value for array \"${array_name}\""
            CONFIG[$key]="${value%/}"
        ;;
        env)
            ENV[$key]="${value%/}"
            export "${key}=${value%/}"  
        ;;
        metadata) METADATA[$key]="${value}" ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


unset_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key; key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    local value; value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"

    # Filter for invalid keys
    [[ -z "$key" ]] && err "Missing key: \"${array_name}\""

    # Unset key
    case "${array_name}" in
        config) unset CONFIG[$key] ;;
        env) unset ENV[$key]; unset "${key}" ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


load_array() {
    local path; local array_name="${1}" || err "Missing argument: load_array [array_name]"
    case "${array_name}" in
        config) path="${CONFIG_PATH}" ;;
        env) path="${ENV_PATH}" ;;
        metadata) path="${METADATA_PATH}" ;;
        *) err "Invalid argument \"${array_name}\"";;
    esac

    # Warn if the file does not exist
    if [[ ! -f "${path}" ]]; then
        warn "Failed to load \"${path}\": File does not exist" && return
    fi

    # Read lines & load values
    while read -r line; do
        case "${line}" in
            *=*) set_value "${array_name}" "${line}" ;;
            *) err "Cannot load setting \"${line}\": Invalid format" ;;
        esac
    done < "${path}"
}


save_array() {
    local key; local array_name="${1}"
    [[ ! -d "${CONFIG_DIR}" ]] && return 1
    case "${array_name}" in
        config)
            [[ -f "${CONFIG_PATH}" ]] && m_rm "${CONFIG_PATH}"
            for key in "${!CONFIG[@]}"; do
                echo "${key}=\"${CONFIG[$key]}\"" >> "${CONFIG_PATH}"
            done
        ;;
        env)
            [[ -f "${ENV_PATH}" ]] && m_rm "${ENV_PATH}"
            for key in "${!ENV[@]}"; do
                echo "${key}=\"${ENV[$key]}\"" >> "${ENV_PATH}"
            done
        ;;
        *) ;;
    esac
}


set_spt_path() {
    local target_path="$( realpath -m "${1%/}" )"
    [[ -z "${target_path}" ]] && err "Path argument is not set"
    check_path "${target_path}"
    set_value config "spt-path=${target_path}"
}


set_prefix_path() {
    local target_path="$( realpath -m "${1%/}" )"
    [[ -z "${target_path}" ]] && err "Path argument is not set"

    # Validate prefix path
    check_path "${target_path}"
    check_prefix_dir "${target_path}" || err "Given directory is not empty or the prefix is corrupted: \"${target_path}\""

    # Update WINEPREFIX environment variable
    export WINEPREFIX="${target_path}"

    # Update prefix config
    set_value env "WINEPREFIX=${target_path}"

    # Update prefix paths
    case "${WINEPREFIX}" in
        *"steamapps/compatdata/3932890"*)
            if [[ ! -d "${WINEPREFIX}" ]]; then
                warn "Game prefix not found!"
                msg "   ► ${BOLD}Ensure that Escape from Tarkov is installed inside Steam${RESET}"
                msg "   ► ${BOLD}& that you've run the game at least once for it to create the prefix directory${RESET}"
                err "Game prefix not found"
            fi
            local spt_path; spt_path="$( cd "${CONFIG[steam-library-path]}" && realpath -m "../../" 2>/dev/null )"
            [[ -z "${spt_path}" ]] && spt_path="${HOME}"
            set_value config "spt-path=${spt_path%/}/Games/SPTarkov"
            BSG_DIR="${CONFIG[steam-library-path]}/common/Escape from Tarkov/launcher"
            EFT_DIR="${CONFIG[steam-library-path]}/common/Escape from Tarkov/build"
        ;;
        *)
            set_value config "spt-path=${WINEPREFIX%/}/drive_c/SPTarkov"
            BSG_DIR="${WINEPREFIX%/}/drive_c/Battlestate Games/BsgLauncher"
            EFT_DIR=$( get_eft_path )
        ;;
    esac

    msg "${BOLD}Prefix path has been set to:${RESET}"
    msg "   ► ${WINEPREFIX}"
}


init_prefix() {
    local prefix_path=${1:-"${WINEPREFIX}"}
    set_prefix_path "${prefix_path}"

    local missing_proton_dir
    [[ ! -d "${COMPAT_DIR}/${PROTONPATH}" && ! -d "${PROTONPATH}" ]] && missing_proton_dir=1
    if [[ "${PROTONPATH}" != "GE-Proton" && "${missing_proton_dir}" ]]; then
        msg "Invalid Proton path: ${PROTONPATH}"
        msg "   ► Defaulting to \"GE-Proton\"..."
        set_value env "PROTONPATH=GE-Proton"
    fi

     # Check if we need to update the prefix
    if [[ "${PROTONPATH}" == "GE-Proton" || "${missing_proton_dir}" || ! -d "${WINEPREFIX}" ]]; then
        # Update the prefix
        msg; msg "Initializing wine prefix..." && m_umu wineboot -u
        m_umu winecfg /v win81 1>> "${LOG_PATH}"

        # WORKAROUND: Fixes umu-launcher always re-downloading the latest GE-Proton version
        local proton_path="$( dir -1 -v "${COMPAT_DIR}" | grep "GE-Proton*" | tail -1 )"
        if [[ "${PROTONPATH}" == "GE-Proton" ]]; then
            msg "Pinning Proton version to \"${proton_path##*/}\""
            set_value env "PROTONPATH=${proton_path##*/}"
        fi
    fi
}


get_eft_path() {
    local entry; local path
    # get windows path
    [[ ! -f "${WINEPREFIX}/system.reg" ]] && exit 11
    entry=$( sed -n '/Uninstall\\\\EscapeFromTarkov/,/^$/p' "${WINEPREFIX}/system.reg" )
    path=$( echo "${entry}" | grep -o "\"UninstallString\"=\"[^}]*" | cut -d "\"" -f4 2>/dev/null )
    # Convert to unix path
    path=$( m_umu winepath -u "${path}" 2>/dev/null )
    [[ -z "${path}" ]] && exit 12
    # Finally assemble the full path & return it
    printf "%s\n" "${path%/*}"
}


get_steam_game_libraries() {
    local config_path="${STEAM_DIR}/config/libraryfolders.vdf"
    local paths; paths=$( cat "${config_path}" | grep "\"path\"" | cut -d "\"" -f4 2>/dev/null )
    printf "%s\n" "${paths}"
}


get_steam_eft_path() {
    local library_path="${1}"
    [[ -z "${library_path}" ]] && exit 12
    eft_path="${library_path}/steamapps/common/Escape from Tarkov"
    [[ ! -d "${eft_path}" ]] && exit 10
    printf "%s\n" "${eft_path}"
}


get_patcher_eft_version() {
    local path="${1}"
    # Split filename to get version infos from it
    local filename; filename=$( echo "${path##*/}" | tr "_." " " )
    local version; version=$( echo "${filename}" | cut -d " " -f6 )
    [[ -z "${version}" ]] && exit 12
    printf "%s\n" "${version}"
}


get_file_version() {
    local filepath="${1}"
    [[ ! -f "${filepath}" ]] && exit 11
    m_7z l "${filepath}" | grep -o "FileVersion:[^}]*" | head -1 | cut -d " " -f2
}


get_eft_version() { get_file_version "${EFT_DIR}/EscapeFromTarkov.exe" | cut -d "." -f4; }
get_mod_eft_version() { get_file_version "${CONFIG[spt-path]}/EscapeFromTarkov.exe" | cut -d "." -f4; }
get_spt_version() { get_file_version "${CONFIG[spt-path]}/BepInEx/plugins/spt/spt-core.dll" | cut -d "." -f1-3; }
get_env() { local key; printf "$( for key in "${!ENV[@]}"; do printf "${key}=\"${ENV[$key]}\" "; done )\n"; }
get_hash() { md5sum "$@" | cut -d ' ' -f 1 | xxd -r -p | base64 2>/dev/null; }


# # # # # # # # # # #
#  Check functions  #
# # # # # # # # # # #

check_target_path() {
    local target_path="${1%/}"
    case "${1}" in
        "") err "Target path is not set" ;;
        *"${WINEPREFIX}"* | *"${DATA_DIR}"* | *"${CACHE_DIR}"* | *"${ICO_DIR}"* | *"${APP_DIR}"* | *"${CONFIG[spt-path]}"* | \
        *"${HOME}/.local/bin"* | *"${HOME}/bin"* | *"${COMPAT_DIR}"* | *"${CONFIG_DIR}"* | *"${TMP_DIR}"*) ;;
        *) err "Invalid target directory \"${target_path}\"" ;;
    esac
}


check_verb() {
    [[ ! -d "${WINEPREFIX}" ]] && err "Prefix directory \"${WINEPREFIX}\" does not exist"
    if ! cat "${WINEPREFIX}/winetricks.log" 2>/dev/null | grep -q "$1"; then return 1; fi
}


check_disk_space() {
    local total_gb=${1}; local path="${2:-"${WINEPREFIX}"}"
    [[ -z "${path}" ]] && err "Missing path argument"
    [[ ! -d "${path}" ]] && err "Directory does not exist: ${path}"
    # Get required values
    local free_kb; free_kb=$( df -k "${path}" | tail -1 | awk '{print $4}' )
    local free_gb; free_gb=$( echo "${free_kb}" | awk '{ free = $1/1024/1024 ; printf("%.2fGiB\n", free) }' )
    # If no total size is defined, use size of the EFT game files
    if [[ -n "${total_gb}" ]]; then
        local total_kb; total_kb=$(( 1024*1024*total_gb ))
    else
        local eft_kb; eft_kb=$( du -cs "${EFT_DIR}" | head -1 | cut -d$'\t' -f1 )
        total_kb=$((eft_kb + 1024*1024*10))
    fi
    total_gb=$( echo "${total_kb}" | awk '{ total = $1/1024/1024 ; printf("%.2fGiB\n", total) }' )
    # Check if there's enough space
    [[ $free_kb -le $total_kb ]] && err "Not enough free disk space! (${free_gb} free < ${total_gb} needed)"
    msg "Enough free disk space available! (${free_gb} free > ${total_gb} needed)"
}


check_prefix_dir() {
    local target_path="${1%/}"
    local check_paths=( "${target_path}/system.reg" "${target_path}/dosdevices" "${target_path}/drive_c" )
    # Check directory content
    if [[ -d "${target_path}" && -n "$( m_ls -A "${target_path}" 2>/dev/null )" ]]; then
        for path in "${check_paths[@]}"; do
            [[ ! -f "${path}" ]] && [[ ! -d "${path}" ]] && return 1
        done
    fi
    return 0
}


check_path() {
    local status=0
    local path="${1%/}"
    [[ ! "${path:0:1}" =~ ^[./~]+$ ]] && err "Invalid path format: \"${path}\""
    path="$( realpath -m "${path}" )"

    while true; do
        [[ -f "${path}" ]] && status=1 && break

        # Check for write permissions
        local recursive_path="${path}"
        while [[ ! -d "${recursive_path}" ]]; do
            recursive_path="${recursive_path%/*}"
            [[ "${recursive_path}" == "" ]] && status=2 && break
        done
        [[ ! -w "${recursive_path}" ]] && status=3 && break
        break
    done

    if [[ $status != 0 ]]; then
        case $status in
            1) err "Given path is a file: \"${path}\"" ;;
            2) err "Failed to resolve prefix path: \"${path}\"" ;;
            3) err "No write permission for directory: \"${path}\"" ;;
        esac
    fi
}


check_eft_installed() {
    if [[ -z "${EFT_DIR}" || ! -d "${EFT_DIR}" || -z $( m_ls -A "${EFT_DIR}" ) ]]; then
        return 1
    fi
    return 0
}


check_legacy_installed() {
    [[ -z "${CONFIG[spt-path]}" || ! -d "${CONFIG[spt-path]}" ]] && return 1
    [[ ! -d "${CONFIG[spt-path]}/SPT_Data" || ! -f "${CONFIG[spt-path]}/SPT.Launcher.exe" ]] && return 1
    return 0
}


check_latest_installed() {
    [[ -z "${CONFIG[spt-path]}" || ! -d "${CONFIG[spt-path]}" ]] && return 1
    [[ ! -d "${CONFIG[spt-path]}/SPT" || ! -f "${CONFIG[spt-path]}/SPT.Launcher.exe" ]] && return 1
    return 0
}


check_steam_install() {
    local paths=( "${WINEPREFIX}" "${BSG_DIR}" "${EFT_DIR}" )
    for path in "${paths[@]}"; do [[ "${path}" != **"/steamapps/"** ]] && return 1; done
    return 0
}


check_aspnet() {
    if ! dotnet --list-runtimes 2>/dev/null | grep "AspNet" | grep "9.0" &>/dev/null; then
        warn "\"ASP.NET Runtime 9.0\" is not installed."
        msg "   ► ASP.NET is ${BOLD}REQUIRED${RESET} to run then SPT Linux server!"
        sleep 3
    fi
}


check_native_deps() {
    local status; local cmd
    local cmds=( "python3" "curl" "7zzs" "xxd" "hpatchz" "jq" "umu-run" )
    msg "Checking for native dependencies..."
    for cmd in "${cmds[@]}"; do
        if command -v "${cmd}" &>/dev/null; then continue; fi
        case ${cmd} in
            # Required tools / libraries
            python3|curl) err "Cannot find \"${cmd}\"!" ;;
            # Downloadable tools / libraries
            jq|hpatchz|xxd|7zzs|umu-run) install_dep "${cmd}" "${METADATA[${cmd}-url]}" ;;
        esac
    done
}


check_eft_running() {
    local app; local apps=( "BsgLauncher.exe" "EscapeFromTarko" )
    for app in "${apps[@]}"; do
        if [[ -z $( pidof "${app}" ) ]]; then continue; fi
        warn "It looks like \"${app}\" is currently running on your system!"
        msg "   ► ${YELLOW} Please close the application & retry.${RESET}"
        err "\"${app}\" process found"
    done
}


check_hash() {
    local file_path="${1%/}"
    local expected_hash="${2}"
    # Check arguments
    [[ ! -f "${file_path}" ]] && err "File \"${file_path}\" does not exist"
    [[ -z "${expected_hash}" ]] && err "Missing \"expected_hash\" argument"
    # use file to calculate MD5 hash and ENCODE in base64
    msg "Calculating checksum for file: ${file_path##*/}"
    local file_hash; file_hash=$( get_hash "${file_path}" ) || err "Failed to calculate hash"
    [[ -z "${file_hash}" ]] && err "get_hash returned empty string"
    # Compare
    if [[ "${file_hash}" != "${expected_hash}" ]]; then
        warn "Hash check mismatch (File: \"${file_hash}\" != Expected: \"${expected_hash}\")"
        return 1
    fi
    msg "Hash check successful"
}


check_cached() {
    local cached_path="${1%/}"
    local expected_hash="${2}"
    # Make sure the path actually is in CACHE_PATH
    [[ "$cached_path" == *"${CACHE_DIR}"* ]] || err "File is not in \"${CACHE_DIR}\""
    # Verify the file is there and valid
    local filename=${cached_path##*/}
    if [[ -f "${cached_path}" ]]; then
        msg "Found \"${filename}\" in cache directory"
        if [[ -n "${expected_hash}" ]] && ! check_hash "${cached_path}" "${expected_hash}"; then
            msg "Removing cached file \"${filename}\""
            m_rm "${cached_path}"
            return 1
        fi
    else
        msg "\"${cached_path}\" is not cached"
        return 1
    fi
}


check_ttl() {
    local file_path="${1%/}"
    local ttl="${2:-"3600"}"
    # Check if file exists, if not - fail the check
    [[ ! -f "${file_path}" ]] && return 1
    # Calculate time elapsed since last modified
    local current_time; current_time=$( date +%s )
    local modified_time; modified_time=$( date -r "${file_path}" +%s )
    ((elapsed_time = current_time - modified_time))
    # If elapsed time >= TTL - fail the check
    if [[ $elapsed_time -ge $ttl ]]; then return 1; fi
}


add_battleeye_workaround() {
    # Derived from: https://github.com/nmlynch94/tarkov-flatpak/blob/main/scripts/tarkov-run.sh#L109
    local key='HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\BEService'
    local binary_path="${EFT_DIR}/BattlEye/BEService_x64.exe"
    local dst_dir="${WINEPREFIX}/drive_c/Program Files (x86)/Common Files/BattlEye"

    msg "Adding BattleEye service workaround (This might take a bit) ..."
    if [[ ! -d "${dst_dir}" ]]; then m_mkdir "${dst_dir}"; fi
    if [[ ! -f "${dst_dir}/BEService_x64.exe" ]]; then m_cp "${binary_path}" "${dst_dir}/BEService_x64.exe"; fi

    m_umu reg add "${key}" /v DisplayName /t REG_SZ /d "BattlEye Service" /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v ImagePath   /t REG_SZ /d 'C:\Program Files (x86)\Common Files\BattlEye\BEService_x64.exe' /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v ObjectName  /t REG_SZ /d "LocalSystem" /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v ErrorControl       /t REG_DWORD /d 1      /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v PreshutdownTimeout /t REG_DWORD /d 180000 /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v Start              /t REG_DWORD /d 2      /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v Type               /t REG_DWORD /d 16     /f 1>> "${LOG_PATH}"
    m_umu reg add "${key}" /v WOW64              /t REG_DWORD /d 1      /f 1>> "${LOG_PATH}"
}


# # # # # # # # # # # # #
#  Installer functions  #
# # # # # # # # # # # # #

install_verb() {
    local verb="${1}"; local text="${2:-"Installing: ${verb}..."}"
    if check_verb "${verb}"; then
        msg "\"${verb}\" is already installed" && return 1
    fi
    msg "Installing: ${text}..."
    m_umu winetricks -q "${verb}" 1>> "${LOG_PATH}"
}


install_dep() {
    local cmd_name="$1"; local url="$2";  local filename="${url##*/}"
    local source_path="${3:-$TMP_DIR}"; local target_path="${4:-$RUNTIME_DIR}"
    
    m_download -s "${url}" "${source_path}"
    case "${filename}" in
        # Single file workarounds
        *jq-linux-amd64*) mv "${source_path}/jq-linux-amd64" "${source_path}/jq" || err "Failed to rename \"${filename}\"" ;;
        *) m_extract "${source_path}/${filename}" 1>/dev/null ;;
    esac

    # Search for executable inside the extracted directory
    local file_path; file_path=$( find "${source_path}" \( -name "${cmd_name}" -type f \) | head -1 )
    [[ -z "${file_path}" ]] && err "Cannot find \"${cmd_name}\" in \"${source_path}\""

    # Change permissions
    m_chmod +x "${file_path}"

    # Move to target directory
    m_mv -f "${file_path}" "$target_path/${cmd_name}"
}


install_mod_archive() {
    local url="${1}"; [[ -z "${url}" ]] && err "Missing argument: url"
    local source_path="${2}"; [[ -z "${source_path}" ]] && err "Missing argument: source_path"
    local hash="${3}"; [[ -z "${hash}" ]] && err "Missing argument: hash"
    if ! check_cached "${source_path}" "${hash}"; then
        m_download "${url}" "${source_path}"
        check_hash "${source_path}" "${hash}" || err "File \"${source_path##*/}\" is corrupted"
    fi
    m_extract "${source_path}" "${CONFIG[spt-path]}"
}


install_additions() {
    local target_path="${1%/}"
    [[ ! -d "${target_path}" ]] && m_mkdir "${target_path}"
    m_download -s "${METADATA[installer-script-url]}" "${TMP_DIR}"
    check_hash "${TMP_DIR}/${TITLE}" "${METADATA[additions-hash]}" || err "Downloaded script is corrupted"
    msg "Installing ${TITLE}..."
    m_mv "${TMP_DIR}/${TITLE}" "${target_path}/${TITLE}" && m_chmod +x "${target_path}/${TITLE}"
}


install_eft() {
    msg "${BOLD}Launching \"Escape from Tarkov\" installer...${RESET}"

    if ! check_eft_installed; then check_disk_space 60; fi

    # Install BSG Launcher
    if [[ ! -d "${BSG_DIR}" ]]; then
        # Download BSG Launcher setup file
        m_download "${METADATA[bsg-launcher-url]}" "${FILES_DIR}/BsgLauncher.exe"
        
        msg "Installing BSG Launcher..."
        m_umu "${FILES_DIR}/BsgLauncher.exe" /VERYSILENT
    fi

    # Download icon to icons directory
    m_download -s "${METADATA[bsg-ico-url]}" "${ICO_DIR}/bsg_launcher.png"

    # Create application shortcut
    opt_shortcut bsg-launcher

    msg "BSG Launcher is installed!"
}


install_spt() {
    local install_mode="${CONFIG[install-mode]}"
    msg "${BOLD}Launching \"SPTarkov\" installer...${RESET}"
    # WORKAROUND: Fixes older config files
    [[ "${install_mode}" == "native" ]] && set_value config "install-mode=latest"
    # WORKAROUND: Shows script version for Lutris installs
    [[ "${install_mode}" == "lutris" ]] && opt_version
    msg "Selected install mode is \"${install_mode}\"..."

    if ! check_eft_installed; then
        warn "${BOLD}Escape from Tarkov is not installed${RESET}"
        msg "   ► make sure to install the game inside the BSG Launcher & try again!"
        err "Escape from Tarkov not found."
    elif check_latest_installed || check_legacy_installed; then
        warn "${BOLD}\"${CONFIG[spt-path]}\"${RESET} already exists"
        msg "   ► If you want to reinstall, make sure to move or delete the current installation first!"
        err "SPTarkov directory already exists."
    fi

    check_eft_running;  check_aspnet;  check_disk_space

    # Install dependencies
    install_verb "dotnetdesktop6" ".NET Desktop Runtime 6.0"
    install_verb "dotnetdesktop8" ".NET Desktop Runtime 8.0"

    # Download & install .NET Desktop Runtime 9.0
    local dotnet_file="${FILES_DIR}/dotnet-runtime.exe"
    if [[ ! -f "${dotnet_file}" ]] || ! check_ttl "${dotnet_file}" 604800; then m_download -f "${METADATA[dotnetcore-url]}" "${dotnet_file}"; fi
    msg "Installing: .NET Desktop Runtime 9.0..." && m_umu "${dotnet_file}" /q

    # Add DLL overrides
    opt_dlloverride winhttp n,b

    # Install SPT
    case "$install_mode" in
        latest|legacy|lutris) install_spt_native ;;
        proton)
            # Download & install ASP.NET Desktop Runtime 9.0
            # WORKAROUND: Fixes SPTInstaller requirement check failing
            m_download "${METADATA[aspnetcore-url]}" "${FILES_DIR}/aspnet-runtime.exe"
            msg "Installing: ASP.NET Desktop Runtime 9.0..." && m_umu "${FILES_DIR}/aspnet-runtime.exe" /q

            # Download SPT Installer
            m_download "${METADATA[spt-installer-url]}" "${FILES_DIR}"

            # Symlink SPTInstaller cache directory to script cache directory
            local cache_dir="${WINEPREFIX}/drive_c/users/steamuser/Application Data/spt-installer/cache"
            [[ -d "${cache_dir}" && $(readlink "${cache_dir}") != "${FILES_DIR}" ]] && m_rm -r "${cache_dir}"
            [[ ! -d "${cache_dir}" ]] && m_mkdir "${cache_dir%/*}"
            ln -s -n "${FILES_DIR}" "${cache_dir}" &>> "${LOG_PATH}"

            # Convert SPT directory path to windows path
            local path; path=( m_umu winepath -w "${CONFIG[spt-path]}}" )

            # Run SPT Installer
            msg "Launching SPT Installer..."
            m_umu "${FILES_DIR}/SPTInstaller.exe" installpath="${path}"
            if ! check_latest_installed && ! check_legacy_installed; then err "Failed to install SPTarkov"; fi

            # Make the Linux server executable
            m_chmod +x "${CONFIG[spt-path]}/SPT/SPT.Server.Linux"
        ;;
    esac

    # Set Windows version to 8.1
    msg "Setting Windows version to \"8.1\"..."
    m_umu winetricks -q "win81" 1>> "${LOG_PATH}"

    # Steam library directory workaround
    local steam_dir="${WINEPREFIX}/drive_c/Program Files (x86)/Steam/steamapps"
    if [[ ! -f "${steam_dir}/libraryfolders.vdf" ]]; then
        msg "Adding Steam library file workaround..."
        m_mkdir "${steam_dir}"
        touch "${steam_dir}/libraryfolders.vdf"
    fi

    if [[ "${install_mode}" == "legacy" ]]; then set_value env "PROTON_VERB=run"
    else
        # Install the latest server launch script
        m_download -s "${METADATA[server-script-url]}" "${CONFIG[spt-path]}"
        m_chmod +x "${CONFIG[spt-path]}/launch-server.sh"

        # Create launcher shortcut inside the root directory
        ln -s "${CONFIG[spt-path]}/SPT/SPT.Launcher.exe" "${CONFIG[spt-path]}" &>> "${LOG_PATH}"\
        || warn "Failed to create symbolic link for \"SPT.Launcher.exe\""
    fi

    case "${install_mode}" in
        latest|legacy|proton)
            # Download icons to icons directory
            local launcher_icon="${ICO_DIR}/spt_launcher.png"
            local server_icon="${ICO_DIR}/spt_server.png"
            m_download -s "${METADATA[launcher-ico-url]}" "${launcher_icon}"
            m_download -s "${METADATA[server-ico-url]}" "${server_icon}"

            # Create application shortcuts
            opt_shortcut spt
        ;;
        lutris) ;;
    esac
    msg "SPTarkov has been installed!"
}


install_spt_native() {
    local install_mode="${CONFIG[install-mode]}"

    case "${install_mode}" in
        # SPT 3.11.x
        legacy) load_metadata legacy && msg "${BOLD}Installing legacy SPT version: \"${METADATA[mod-version]}\"${RESET}" ;;
        # SPT 4.x.x
        latest|lutris) load_metadata latest && msg "${BOLD}Installing latest SPT version: \"${METADATA[mod-version]}\"${RESET}" ;;
        *) err "Invalid install mode \"${install_mode}\"" ;;
    esac

    # Check if we need to patch the game files
    msg "Comparing installed EFT <--> required EFT versions"
    if [[ "${METADATA[inst-eft]}" -ne "${METADATA[mod-eft]}" ]]; then
        msg "Incompatible EFT version found - Checking patcher compatibility..."
        # Check if target EFT version is lower, greater or equal to required EFT version
        if [[ "${METADATA[patcher-eft]}" -lt "${METADATA[inst-eft]}" ]]; then
            # No patcher available yet!
            warn "Looks like there's no patcher available for your EFT version"
            msg "    ► This usually happens when EFT has been updated recently."
            msg "    ► Please wait for the SPT team to generate a new patcher."
            msg "    ► Usually, this will take less then 24 hours."
            err "No patcher available"

        elif [[ "${METADATA[patcher-eft]}" -gt "${METADATA[inst-eft]}" ]]; then
            # EFT is outdated!
            warn "Looks like your installed EFT version is out-of-date"
            msg "    ► Please update your live EFT installation & try again"
            err "EFT is out-of-date"

        elif [[ "${METADATA[patcher-eft]}" -eq "${METADATA[inst-eft]}" ]]; then
            # Downpatcher is compatible!
            msg "Patcher is compatible"

            # Download latest patcher if needed
            [[ -z "${METADATA[patcher-hash]}" ]] && err "Missing patcher hash argument"
            if ! check_cached "${METADATA[patcher-path]}" "${METADATA[patcher-hash]}"; then
                m_download "${METADATA[patcher-url]}" "${METADATA[patcher-path]}"
                check_hash "${METADATA[patcher-path]}" "${METADATA[patcher-hash]}" || err "File \"${METADATA[patcher-path]##*/}\" is corrupted"
            fi

            # Extract latest patcher to tmp directory
            m_extract "${METADATA[patcher-path]}" "${TMP_DIR}"

            # Copy EFT files
            msg "Copying game files to \"${CONFIG[spt-path]}\""
            m_cp "${EFT_DIR}/" "${CONFIG[spt-path]}"

            # Move patcher files to install directory
            msg "Copying patch files to \"${CONFIG[spt-path]}\""
            local patch_dir; patch_dir="$(find "${TMP_DIR}" -type d -name '*SPT_Patches*')"
            m_cp "${patch_dir}" "${CONFIG[spt-path]}/SPT_Patches" || err "Failed to copy patch files" 

            # Patch game files
            opt_patch "${CONFIG[spt-path]}" || err "Failed to patch game files"
        else
            msg "Installed EFT version is compatible with \"SPT ${METADATA[mod-version]}\""
            msg "Copying game files to \"${CONFIG[spt-path]}\""
            m_cp "${EFT_DIR}/" "${CONFIG[spt-path]}"
        fi
    fi

    install_mod_archive "${METADATA[mod-url]}" "${METADATA[mod-path]}" "${METADATA[mod-hash]}"
}


install_fika() {
    local releases=( "fika-core" "fika-server" )
    msg "${BOLD}Launching \"Fika\" installer...${RESET}"

    if ! check_eft_installed; then
        warn "${BOLD}Escape from Tarkov is not installed${RESET}"
        msg "   ► make sure to install the game inside the BSG Launcher & try again!"
        err "Escape from Tarkov not found."
    elif ! check_latest_installed; then
        warn "${BOLD}SPTarkov is not installed${RESET}"
        msg "   ► make sure to install it & try again!"
        err "SPTarkov not found."
    elif [[ -d "${CONFIG[spt-path]}/BepInEx/plugins/Fika" ]]; then
        # Ask for confirmation
        warn "${BOLD}Fika is already installed${RESET}"
        yesno "Do you want to update/re-install Fika?" || return 0
    fi

    for release in "${releases[@]}"; do
        local json_path="${METADATA_DIR}/${release}.json"
        local archive_path="${FILES_DIR}/${release}.zip"
        
        # Get metadata json
        if ! check_ttl "${json_path}"; then m_download "${METADATA[${release}-json-url]}" "${json_path}"; fi

        # Get archive url
        local archive_url; archive_url=$( cat "${json_path}" | grep -o "\"browser_download_url\": \"[^}]*" | cut -d "\"" -f4 2>/dev/null )
        [[ -z "${archive_url}" ]] && err "Failed to get release file URL"

        if [[ "$release" == "fika-core" ]]; then
            # Get Fika version
            local fika_version; fika_version=$( echo "${archive_url##*/}" | cut -d "." -f3-5 2>/dev/null )
            [[ -z "${fika_version}" ]] && err "Failed to get Fika version"
            msg "${BOLD}Latest Fika version is \"${fika_version}\"${RESET}"

            # SPT-EFT compatibility check
            local compatible_eft; compatible_eft=$( cat "${json_path}" | grep -o "## Compatible with EFT [^}]*" | cut -d " " -f5 2>/dev/null )
            compatible_eft=$( echo "${compatible_eft}" | cut -d "." -f4 | cut -d "\\" -f1 )
            [[ -z "${compatible_eft}" ]] && err "Failed to get compatible EFT version"
            if [[ "${METADATA[inst-mod-eft]}" -eq "${compatible_eft}" ]]; then msg "Installed SPT-EFT version is compatible!"
            else err "Incompatible EFT version (installed: ${METADATA[inst-mod-eft]} != Required: ${compatible_eft})"; fi
        fi

        # Install archive
        m_download -s -f "${archive_url}" "${archive_path}"
        m_extract "${archive_path}" "${CONFIG[spt-path]}"

    done

    msg "Fika has been installed!"
}


# # # # # # # # # # # # #
#  Uninstall functions  #
# # # # # # # # # # # # #

uninstall_eft() {
    local no_prompt="${1:-$NO_PROMPT}"
    if check_steam_install; then
        warn "Steam installation of Escape from Tarkov detected!"
        msg "   ► Please uninstall the game inside Steam instead."
        return 1
    fi

    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"Escape from Tarkov\" from your system!${RESET}"
        msg "   ► EFT: ${BSG_DIR}"
        msg "   ► BSG Launcher: ${EFT_DIR}"
        yesno "Do you want to continue?" || return 1
    fi

    msg "Uninstalling \"Escape from Tarkov\"..."
    m_rm -r "${BSG_DIR}"; m_rm -r "${EFT_DIR}"
    m_rm -r "${WINEPREFIX}/drive_c/Battlestate Games"

    msg "Removing \"BSG Launcher\" shortcut..."
    [[ -f "${SHORTCUT[bsg-launcher]}" ]] && m_rm "${SHORTCUT[bsg-launcher]}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_spt() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${CONFIG[spt-path]}" ]] && msg "SPT is not installed" && return 0

    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"SPTarkov\" from your system!${RESET}"
        msg "SPT directory: ${UNDERLINE}${CONFIG[spt-path]}${RESET}"
        yesno "Do you want to continue?" || return 1
    fi

    msg "Uninstalling \"SPTarkov\"..."
    m_rm -r "${CONFIG[spt-path]}"

    msg "Removing \"SPTarkov\" shortcuts..."
    [[ -f "${SHORTCUT[spt-server]}" ]] && m_rm "${SHORTCUT[spt-server]}"
    [[ -f "${SHORTCUT[spt-launcher]}" ]] && m_rm "${SHORTCUT[spt-launcher]}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_prefix() {
    local no_prompt="${1:-$NO_PROMPT}"
    if check_steam_install; then
        warn "Steam installation of Escape from Tarkov detected!"
        msg "   ► Please uninstall the game inside Steam instead."
        return 1
    fi
    [[ ! -d "${WINEPREFIX}" ]] && msg "Prefix directory does not exist" && return 0
    msg "Removing Prefix directory: \"${WINEPREFIX}\""
    m_rm -r "${WINEPREFIX}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


load_metadata() {
    local name="${1}"
    case "${name}" in
        latest)
            # Fetch metadata
            if ! check_ttl "${MOD_JSON_PATH}" || ! check_ttl "${PATCHER_JSON_PATH}"; then
                m_download -f -s "${METADATA[mod-json-url]}" "${MOD_JSON_PATH}"
                m_download -f -s "${METADATA[patcher-json-url]}" "${PATCHER_JSON_PATH}"
            fi
            METADATA[mod-eft]=$( jq -r '.ClientVersion' "${MOD_JSON_PATH}" ) || err "Failed to get required EFT version for SPT" "$?"
            METADATA[mod-version]=$( jq -r '.AkiVersion' "${MOD_JSON_PATH}" ) || err "Failed to get remote SPT version" "$?"
            METADATA[mod-url]=$( jq -r '.Mirrors[].DownloadUrl' "${MOD_JSON_PATH}" ) || err "Failed to get SPT download url" "$?"
            METADATA[mod-hash]=$( jq -r '.Mirrors[].Hash' "${MOD_JSON_PATH}" ) || err "Failed to get SPT archive hash" "$?"
            METADATA[mod-path]="${MOD_PATH}"
            METADATA[patcher-url]=$( jq -r '.Mirrors[].Link' "${PATCHER_JSON_PATH}" | head -1 ) || err "Failed to get patcher download url" "$?"
            METADATA[patcher-hash]=$( jq -r '.Mirrors[].Hash' "${PATCHER_JSON_PATH}" | head -1 ) || err "Failed to get patcher hash" "$?"
            METADATA[patcher-eft]=$( get_patcher_eft_version "${METADATA[patcher-url]}" ) || err "Failed to get required EFT version for patcher" "$?"
            METADATA[patcher-path]="${PATCHER_PATH}"
        ;;
        legacy)
            # Fetch metadata
            load_metadata
            METADATA[mod-url]="${METADATA[lts-spt-url]}"; [[ -z "${METADATA[mod-url]}" ]] && err "Failed to get mod url"
            METADATA[mod-hash]="${METADATA[lts-spt-hash]}"; [[ -z "${METADATA[mod-hash]}" ]] && err "Failed to get mod hash"
            METADATA[mod-eft]="$( echo "${METADATA[mod-url]##*/}" | cut -d "-" -f3 )"; [[ -z "${METADATA[mod-eft]}" ]] && err "Failed to get mod eft version"
            METADATA[mod-version]="$( echo "${METADATA[mod-url]##*/}" | cut -d "-" -f2 )"; [[ -z "${METADATA[mod-version]}" ]] && err "Failed to get mod version"
            METADATA[mod-path]="${LEGACY_MOD_PATH}"
            METADATA[patcher-url]="${METADATA[lts-patcher-url]}"
            METADATA[patcher-hash]="${METADATA[lts-patcher-hash]}"
            METADATA[patcher-eft]=$( get_patcher_eft_version "${METADATA[patcher-url]}" ) || err "Failed to get required EFT version for patcher" "$?"
            METADATA[patcher-path]="${LEGACY_PATCHER_PATH}"
        ;;
        eft)
             METADATA[inst-eft]=$( get_eft_version ) || err "Failed to get EFT version" "$?"
        ;;
        mod-eft)
            METADATA[inst-spt]=$( get_spt_version ) || err "Failed to get installed SPT version" "$?"
            METADATA[inst-mod-eft]=$( get_mod_eft_version ) || err "Failed to get mod EFT version" "$?"
        ;;
        "")
            # Get metadata file (1 hour time-to-live)
            if ! check_ttl "${METADATA_PATH}"; then
                m_download -f -s "${METADATA_URL}" "${METADATA_PATH}"
            fi
            load_array metadata
        ;;
        *) err "Invalid argument: \"${name}\"" ;;
    esac
}


# # # # # # # # # # # #
#   Option functions  #
# # # # # # # # # # # #

opt_install() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov install spt 
    local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) install_eft ;;
        spt|sptarkov) load_metadata eft; install_spt "${CONFIG[install-mode]}" ;;
        fika) load_metadata mod-eft; install_fika "${CONFIG[install-mode]}" ;;
        "") err "Option \"install\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_uninstall() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov uninstall spt 
    local shortcut; local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) uninstall_eft ;;
        spt|sptarkov) uninstall_spt ;;
        all)
            # Ask for confirmation
            if [[ "${NO_PROMPT}" != 1 ]]; then
                msg "The following directories will be deleted ${BOLD}permanently${RESET}:"
                msg "   ► ${WINEPREFIX}"
                msg "   ► ${EFT_DIR}"
                msg "   ► ${CONFIG[spt-path]}"
                yesno "Do you want to continue?" || return 1
            fi
            uninstall_spt 1
            uninstall_eft 1
            uninstall_prefix 1
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}All done!${RESET}"
        ;;
        "") err "Option \"uninstall\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_update() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov update spt 
    local option="$1" && shift
    case "${option}" in
        spt|sptarkov)
            if ! check_eft_installed; then msg "Escape from Tarkov is not installed"; return 0; fi

            # Get metadata
            if check_latest_installed; then load_metadata latest
            elif check_legacy_installed; then load_metadata legacy
            else msg "SPTarkov is not installed"; return 0; fi
            
            load_metadata mod-eft
            [[ -z "${METADATA[inst-spt]}" ]] && err "Installed SPT version is not set"
            [[ -z "${METADATA[mod-version]}" ]] && err "Update SPT version is not set"
            msg "Installed SPT version is \"${METADATA[inst-spt]}\""
            msg "Latest SPT version is \"${METADATA[mod-version]}\""
            
            local inst_major; inst_major=$( echo "${METADATA[inst-spt]}" | cut -d "." -f1 )
            local inst_minor; inst_minor=$( echo "${METADATA[inst-spt]}" | cut -d "." -f2 )
            local inst_patch; inst_patch=$( echo "${METADATA[inst-spt]}" | cut -d "." -f3 )
            local upd_major; upd_major=$( echo "${METADATA[mod-version]}" | cut -d "." -f1 )
            local upd_minor; upd_minor=$( echo "${METADATA[mod-version]}" | cut -d "." -f2 )
            local upd_patch; upd_patch=$( echo "${METADATA[mod-version]}" | cut -d "." -f3 )

            if [[ "${METADATA[mod-version]}" == "${METADATA[inst-spt]}" ]]; then
                msg "${BOLD}SPT is up-to-date.${RESET}" && return 0
            elif [[ "${upd_major}" -gt "${inst_major}" ]]; then
                {   msg "${BOLD}${YELLOW}A new major update is available!${RESET}"
                    msg "   ${BOLD}${YELLOW}NOTE${RESET}: User profiles & mods usually are not compatible for major updates."
                    msg
                    msg "   ${BOLD}Please check out the release notes & re-install SPT manually:${RESET}"
                    msg "   ► ${METADATA[spt-release-url]}/tag/${METADATA[mod-version]}"
                    msg
                    msg "   1. Update the additions script with: ${GREEN}${TITLE} self-update${RESET}"
                    msg "   2. Backup or delete your old SPTarkov directory in \"${CONFIG[spt-path]}\""
                    msg "   3. Update Escape from Tarkov inside the BSG Launcher"
                    msg "   4. Re-install SPT using: ${GREEN}${TITLE} install spt${RESET}"
                } | more
            elif [[ "${upd_minor}" -gt "${inst_minor}" ]]; then
                {   msg "${BOLD}${YELLOW}A new minor update is available!${RESET}"
                    msg "   ${BOLD}${YELLOW}NOTE${RESET}: User profiles & mods might not be compatible."
                    msg
                    msg "   ${BOLD}Please check out the release notes & update / re-install SPT manually:${RESET}"
                    msg "   ► ${METADATA[spt-release-url]}/tag/${METADATA[mod-version]}"
                    msg
                    msg "   ${BOLD}How to update:${RESET}"
                    msg "   1. Download the latest release archive: ${METADATA[mod-url]}"
                    msg "   2. Extract its content into \"${CONFIG[spt-path]}\" & override when asked"
                    msg
                    msg "   ${BOLD}How to re-install:${RESET}"
                    msg "   1. Backup or delete your old SPTarkov directory in \"${CONFIG[spt-path]}\""
                    msg "   2. Update Escape from Tarkov inside the BSG Launcher"
                    msg "   3. Re-install SPT using: ${GREEN}${TITLE} install spt${RESET}"
                }
            elif [[ "${upd_patch}" -gt "${inst_patch}" ]]; then
                {   msg "${BOLD}${YELLOW}A new patch update is available!${RESET}"
                    msg "   ${BOLD}Please check out the release notes:${RESET}"
                    msg "   ► ${METADATA[spt-release-url]}/tag/${METADATA[mod-version]}"
                    msg
                    yesno "Do you want to install the update?" || return 0
                }
                install_mod_archive "${METADATA[mod-url]}" "${METADATA[mod-path]}" "${METADATA[mod-hash]}"
                msg "${GREEN}${BOLD}Update successful!${RESET}"
            else
                err "Unhandled exception"
            fi
        ;;
        fika) load_metadata mod-eft; NO_PROMPT=1 install_fika ;;
        additions|script) opt_selfupdate ;;
        ge-proton|proton-ge|proton)
            [[ -z "${PROTONPATH}" ]] && err "PROTONPATH environment variable is not set"
            [[ "${PROTONPATH}" != *"GE-Proton"* ]] && err "GE-Proton is not set in PROTONPATH"

            local url; url=$( m_curl -Ls -o /dev/null -w %{url_effective} "${METADATA[ge-proton-url]}/latest" 2>> "${LOG_PATH}" )
            [[ -z "${url}" ]] && err "Failed to get latest Proton version"
            local latest_version="${url##*/}"
            local old_version="${PROTONPATH}"

            msg "Installed version: ${old_version}"
            msg "Latest version: ${latest_version}"

            if [[ "${old_version}" != "${latest_version}" ]]; then
                {   msg "${BOLD}${YELLOW}${latest_version} is available!${RESET}"
                    msg "   ► The following directory will be removed:"
                    msg "   ► ${COMPAT_DIR}/${old_version}"
                } | more
                yesno "Do you want to update?" || return 0
                m_download "${METADATA[ge-proton-url]}/download/${latest_version}/${latest_version}.tar.zst" "${TMP_DIR}"
                m_extract "${TMP_DIR}/${latest_version}.tar.zst" "${COMPAT_DIR}"
                m_rm -rf "${COMPAT_DIR}/${old_version}"
                set_value env "PROTONPATH=${latest_version}"
                opt_shortcut all
                msg "${GREEN}Done!${RESET}"
            else
                msg "${BOLD}Proton is up-to-date!${RESET}"
            fi
            return 0
        ;;
        "") err "Option \"update\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_patch() {
    msg "${BOLD}Launching patcher...${RESET}"
    local files_total; local progress=1
    local target_path="${1:-"${CONFIG[spt-path]}"}";  local source_path="${2:-"${target_path}"}"
    target_path=$( realpath -m "${target_path%/}" );  source_path=$( realpath -m "${source_path%/}" )
    [[ -z "${target_path}" ]] && err "Target path is not set"
    [[ ! -d "${target_path}" ]] && err "Target directory \"${target_path}\" does not exist"

    msg "Patching game files in \"${target_path}\"..."

    # Search in optional SOURCE directory
    if [ "$( find "${source_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        source_path="${source_path}"
    # Search in TARGET directory
    elif [ "$( find "${target_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        source_path="${target_path}"
    else
        err "Unable to locate \"SPT_Patches\" directory in \"${source_path}\""
    fi

    files_total=$( find "${source_path}/SPT_Patches" \( -type f -printf x \) | wc -c )

    # Iterate files
    echo; find "${source_path}/SPT_Patches" \( -type f \) -print0 | while IFS= read -r -d '' source; do 
        local progress_string="[${progress}/${files_total}]"
        # Isolate the operation extension
        local extension="${source##*.}"
        # Isolate sub-directories of SPT_Patches
        local trimmed="${source#*SPT_Patches/}"
        # Remove operation extension to get actual file name
        trimmed="${trimmed%.*}"

        local output="${target_path}/${trimmed}"
        local target="${output}.decoded"
        local dir_path="${output%/*}"

        case "$extension" in
            "delta")
                msg -o "${progress_string} (*) Patching: ${trimmed##*/}"
                hpatchz "${output}" "${source}" "${target}" >/dev/null 2>> "${LOG_PATH}" || return 1
                # Remove old file and replace with .decoded file
                [[ ! -f "${target}" ]] && return 1
                rm "${output}" || return 1
                m_mv "${target}" "${output}" || return 1
            ;;
            "del")
                msg -o "${progress_string} (-) Deleting: ${trimmed##*/}"
                rm "${output}" || return 1
                if [[ -z "$( m_ls -A "${dir_path}" )" ]]; then
                    msg -o "${progress_string} (-) Deleting directory: ${dir_path##*/}"
                    rm -r "${dir_path}" || return 1
                fi
            ;;
            "new")
                msg -o "${progress_string} (+) Adding: ${trimmed##*/}"
                if [[ ! -d "${dir_path}" ]]; then
                    msg -o "${progress_string} (+) Adding directory: ${dir_path##*/}"
                    m_mkdir "${dir_path}"
                fi
                cp "${source}" "${output}" || return 1
            ;;
            *) return 1 ;;
        esac
        progress=$((progress+1))
    done

    local status=$?
    if [[ "$status" -ne "0" ]]; then
        # Failed patching
        msg "Removing corrupted game files..."
        m_rm -r "${target_path}" || err "Failed to remove corrupted game files" $status
        return 1
    fi
    
    # Clean up patcher files
    if [[ "${target_path}" == *"${source_path}"* ]]; then
        msg "Cleaning up patch files..."
        [[ -d "${source_path}/SPT_Patches" ]] && rm -r "${source_path}/SPT_Patches"
        [[ -f "${source_path}/patcher.exe" ]] && rm -r "${source_path}/patcher.exe"
    fi

    msg "Done patching game files!"
}


opt_guided_install() {
    # Overview
    {   msg "░█▀▀░█▀█░▀█▀░░░█▀█░█▀▄░█▀▄░▀█▀░▀█▀░▀█▀░█▀█░█▀█░█▀▀"
        msg "░▀▀█░█▀▀░░█░░░░█▀█░█░█░█░█░░█░░░█░░░█░░█░█░█░█░▀▀█"
        msg "░▀▀▀░▀░░░░▀░░░░▀░▀░▀▀░░▀▀░░▀▀▀░░▀░░▀▀▀░▀▀▀░▀░▀░▀▀▀"
        opt_version
        msg
        msg "${BOLD}Hello mercenary! ${BLUE}(･_･)ゞ${RESET}"
        msg
        msg "${BOLD}${YELLOW}This CLI installer will perform the following steps:${RESET}"
        msg "   ► Install latest GE-Proton (if not installed already)"
        msg "   ► Setup the wine prefix, install dependencies & apply game specific workarounds"
        msg "   ► Install the BSG Launcher"
        msg "   ► Install SPTarkov"
        msg "   ► Add application menu shortcuts"
    } | more
    
    while true; do
        # Check if Steam version of EFT is installed
        local steam_paths=( $( get_steam_game_libraries ) )
        local steam_install=0
        local input

        for path in "${steam_paths[@]}"; do
            local steam_eft_dir; steam_eft_dir=$( get_steam_eft_path "${path}" )
            if [[ -n "${steam_eft_dir}" && -n "$( m_ls -A "${steam_eft_dir}" 2>/dev/null )" ]]; then
                # Found EFT in a Steam library
                msg; msg "${BOLD}Found Steam version of \"Escape from Tarkov\" in:${RESET}"
                msg "   ► ${steam_eft_dir}"
                set_value config "steam-library-path=${path}/steamapps"
                msg; init_prefix "${CONFIG[steam-library-path]}/compatdata/3932890/pfx"
                steam_install=1
                break
            fi
        done

        if [[ "${steam_install}" == 0 ]]; then
            # Choose a custom prefix install location
            msg; msg "${BOLD}${BLUE}[Q] Where do you want to install the wine prefix (Leave blank for \"${DEFAULT_WINEPREFIX}\")${RESET}"
            msg "(Enter ${BOLD}q${RESET} or press ${BOLD}ctrl-c${RESET} to cancel)"

            input=$( read_input ) || return 1
            if [[ -n "$input" ]]; then
                local prefix_path="${input//[~]/"$HOME"}"
            fi

            init_prefix "${prefix_path:-${DEFAULT_WINEPREFIX}}"
        fi

        check_eft_running

        # Add prefix update pop-up workaround
        msg; msg "Adding \"RUNDLL32\" pop-up workaround..."
        m_umu reg add "HKLM\\Software\\Microsoft\\.NETFramework" /v "OnlyUseLatestCLR" /t "REG_DWORD" /d 0001 /f 1>> "${LOG_PATH}"

        # Add mouse focus workaround
        msg "Adding mouse focus workaround..."
        m_umu reg add "HKCU\\Software\\Wine\\X11 Driver" /v "UseTakeFocus" /t "REG_SZ" /d "N" /f 1>> "${LOG_PATH}"

        # Install EFT dependencies
        install_verb "dotnet48" ".NET 4.8 Runtime (this might take a while)"
        install_verb "vcrun2022" "Microsoft Visual C++ 2015-2022 Redistributable"

        if [[ "${steam_install}" == 1 ]]; then
            # Launch the BSG Launcher
            if ! check_eft_installed; then err "Looks like Escape from Tarkov is not installed"; fi

            # Add BattleEye workaround 
            msg; add_battleeye_workaround

            if command -v steam &>/dev/null; then
                msg; msg "${BOLD}${BLUE}[A] Launching BSG Launcher once to create important metadata...${RESET}"
                msg "   ► Please ensure the launcher works & the \"${GREEN}Play${RESET}\" button is visible."
                msg "   ► Then close it again to continue..."
                opt_run bsg-launcher || err "Failed to launch Escape from Tarkov with Steam"
            else
                warn "Cannot launch Steam on your system!"
                msg "   ► You might need to launch the BSG Launcher once manually to create important metadata"
                sleep 3
            fi
        else
            # Ask to skip EFT installation if it's already installed
            local inst_eft=1
            if check_eft_installed; then
                msg; yesno "\"Escape from Tarkov\" is already installed. Do you want to skip this step?"
                [[ "$?" == 0 ]] && inst_eft=0
            fi

            # Install EFT
            if [[ "${inst_eft}" == 1 ]]; then
                opt_install eft
                
                # Add BattleEye workaround 
                msg; add_battleeye_workaround

                # Run BSG Launcher
                msg "${BOLD}${BLUE}[A] Please install Escape from Tarkov inside the BSG Launcher ...${RESET}"
                msg "   ► When the game is installed, close the Launcher to continue${RESET}"
                opt_run bsg-launcher || err "Failed to launch \"BSG Launcher\""

                # Update EFT path
                EFT_DIR=$( get_eft_path )
                if ! check_eft_installed; then
                    warn "${YELLOW} Looks like EFT is not installed!${RESET}"
                    msg "   ► Make sure that Escape From Tarkov is installed inside the Launcher"
                    msg "   ► & that you can see the \"${GREEN}Play${RESET}\" button"
                    err "Failed to get EFT install path"
                fi
            fi
        fi

        # Choose SPTarkov install path
        msg; msg "${BOLD}${BLUE}[Q] Where do you want to install SPTarkov (Leave blank for \"${CONFIG[spt-path]}\")${RESET}"
        msg "(Enter ${BOLD}q${RESET} or press ${BOLD}ctrl-c${RESET} to cancel)"
        input=$( read_input ) || return 1
        set_spt_path "${input:-${CONFIG[spt-path]}}"

        # Install SPT
        opt_install spt

        # Ask for desktop shortcuts
        if command -v "xdg-user-dir" &>/dev/null; then
            if msg && yesno "Do you want to add additional desktop shortcuts?"; then
                for path in "${SHORTCUT[@]}"; do
                    local name="${path##*/}"
                    local desktop_dir; desktop_dir=$( xdg-user-dir DESKTOP )
                    msg "Creating \"${name}\" desktop shortcut..."
                    ln -s -f "${APP_DIR}/${name}" "${desktop_dir}/${name}"
                done
            fi
        fi

        # Ask to install the script & remove all cached files if not
        if ! opt_selfinstall; then
            if msg && yesno "Do you want to clean cached files in \"${CACHE_DIR}\"?"; then
                export NO_PROMPT=1
                opt_clean metadata; opt_clean files
            fi
        fi

        # All done!
        msg; msg "${BOLD}${GREEN}All done! ※\(^o^)/※${RESET}"
        msg
        msg "${BOLD}${BLUE}You need help or just wanna hang out with ${GREEN}THE NERDS${RESET}?:${RESET}"
        msg "   ${METADATA[discord-url]}"
        msg
        msg "${BOLD}${BLUE}Get your favorite mods from ${GREEN}THE FORGE${RESET}:"
        msg "   ${METADATA[forge-url]}"
        return 0
    done
}


opt_run() {
    # SYNTAX: spt-additions -e MANGOHUD=1 run launcher
    local option="$1" && shift
    [[ -z "${option}" ]] && err "Option \"run\" requires an argument"
    
    case "${option}" in
        eft|tarkov|bsg|bsg-launcher)
            msg "${BOLD}Launching BSG Launcher...${RESET}"
            case "${WINEPREFIX}" in
                *"steamapps/compatdata/3932890"*)
                    steam steam://rungameid/3932890 &>>/dev/null &
                    local pid; local c; while [[ -z "$pid" ]]; do
                        pid=$( pidof "BsgLauncher.exe" )
                        # Timeout
                        ((c++)) && ((c==30)) && err "Timed out while waiting for BSG Launcher process"
                        sleep 2
                    done
                    waitpid $pid
                ;;
                *)
                    local args="--disable-software-rasterizer"
                    cd "${BSG_DIR}" && m_umu "BsgLauncher.exe" "$args" "$@"
                ;;
            esac
        ;;
        launcher)
            check_eft_running
            msg "${BOLD}Launching SPT Launcher...${RESET}"
            cd "${CONFIG[spt-path]}" && m_umu "SPT.Launcher.exe" "$@"
        ;;
        server)
            check_eft_running
            msg "${BOLD}Launching SPT Server...${RESET}"
            cd "${CONFIG[spt-path]}" || exit
            if check_legacy_installed; then m_umu "SPT.Server.exe" "$@"
            else "./launch-server.sh" "$@" &>> "${LOG_PATH}"; fi
        ;;
        "") err "Option \"run\" requires an argument" ;;
        *)
            local cmd="$( echo "${option} $*" | sed -e 's/[[:space:]]*$//' )"
            msg "Running command: \"${cmd}\"..."
            m_umu "${option}" "$@"
        ;;
    esac
}


opt_dlloverride() {
    local dll_name="${1}"; local override_type="${2:-"native,builtin"}"
    [[ -z "${dll_name}" ]] && err "Option \"dlloverride\" requires a DLL name as first argument"
    [[ ! "${dll_name}" =~ ^[A-Za-z0-9_-]+$ ]] && err "DLL name contains invalid characters: \"${dll_name}\""
    case "${override_type}" in
        n|native) override_type="native" ;;
        b|builtin) override_type="builtin" ;;
        d|disabled) override_type="disabled" ;;
        native,builtin|n,b) override_type="native,builtin" ;;
        builtin,native|b,n) override_type="builtin,native" ;;
        *) err "Invalid override type \"${override_type}\"" ;;
    esac
    msg "Setting \"${dll_name}\" DLL override (${override_type})..."
    m_umu reg add "HKCU\\Software\\Wine\\DllOverrides" /v "${dll_name}" /t "REG_SZ" /d "${override_type}" /f 1>> "${LOG_PATH}"
}


opt_env() {
    # SYNTAX: spt-additions env add MANGOHUD=1
    local option="$1"; local keyval="$2" && shift 2
    local key; key=$( echo "${keyval}" | cut -d "=" -f1 )
    local value; value=$( echo "${keyval}" | cut -d "=" -f 2- )
    [[ "${key}" == "${value}" ]] && unset value

    # If the key begins with a '-' we actually wanna unset it!
    if [[ $key == -* ]]; then
        key="${key:1}"
        opt_env unset "${key}"
        return
    fi

    case "${option}" in
        set|add)
            if [[ "${ENV[$key]}" ]]; then msg "Updating environment variable: \"${keyval}\""
            else msg "Adding environment variable: \"${keyval}\""; fi
            set_value env "${key}=${value}"
        ;;
        unset|remove)
            [[ ! "${ENV[$key]}" ]] && msg "Environment variable \"${key}\" is not set" && return
            msg "Removing environment variable: \"$keyval\""
            unset_value env "${key}"
        ;;
        list|-l) get_env ;;
        "") err "Option \"env\" requires an argument" ;;
        *) err "Invalid switch \"${option}\"" ;;
    esac
}


add_app_shortcut() {
    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "app-shortcut" ]] && err "Failed to load shortcut data from cache array"
    if [[ -f "${CACHE[path]}" ]]; then msg "Updating \"${CACHE[name]}\" application shortcut..."
    else msg "Creating \"${CACHE[name]}\" application shortcut..."; fi

    # Warn if the executable does not exist
    if [[ ! -f "${CACHE[working_dir]}/${CACHE[exe_path]}" ]]; then
        warn "File \"${CACHE[working_dir]}/${CACHE[exe_path]}\" does not exist"
    fi 

    # Remove existing shortcut
    [[ -f "${CACHE[path]}" ]] && m_rm "${CACHE[path]}"

    # Prepare environment string
    local env
    [[ -n "${CACHE[env]}" ]] && env="env ${CACHE[env]}"

    # Generate the exec string
    local exec_string
    case "${CACHE[exe_path]}" in
        *exe*|*bat*|*msi*) exec_string="Exec=${env}\"${UMU_PATH}\" \"${CACHE[exe_path]}\" ${CACHE[args]}" ;;
        *) exec_string="Exec=${env}\"${CACHE[working_dir]}/${CACHE[exe_path]}\" ${CACHE[args]}" ;;
    esac

    # Write desktop file
    {   echo "[Desktop Entry]"
        echo "Categories=Game;ActionGame;Simulation"
        echo "Path=${CACHE[working_dir]}"
        echo "${exec_string}"
        echo "Name=${CACHE[name]}"
        echo "Icon=${CACHE[icon]}"
        echo "Type=Application"
    } > "${CACHE[path]}" && m_chmod +x "${CACHE[path]}"
}


opt_shortcut() {
    # SYNTAX: spt-additions -p "" -e "" -a "" shortcut launcher
    local option="$1" && shift
    local env=$( get_env )
    CACHE[_id]="app-shortcut"
    CACHE[env]="${env}"
    CACHE[args]=""

    case "${option}" in
        eft|bsg|bsg-launcher)
            CACHE[name]="BSG - Launcher"
            CACHE[exe_path]="BsgLauncher.exe"
            CACHE[args]="--disable-software-rasterizer"
            CACHE[working_dir]="${BSG_DIR}"
            CACHE[icon]="bsg_launcher"
        ;;
        launcher)
            CACHE[name]="SPT - Launcher"
            CACHE[exe_path]="SPT.Launcher.exe"
            CACHE[working_dir]="${CONFIG[spt-path]}"
            CACHE[icon]="spt_launcher"
        ;;
        server)
            CACHE[name]="SPT - Server"
            CACHE[exe_path]="launch-server.sh"
            CACHE[env]=""
            CACHE[working_dir]="${CONFIG[spt-path]}"
            CACHE[icon]="spt_server"
        ;;
        legacy-server)
            CACHE[name]="SPT - Server"
            CACHE[exe_path]="SPT.Server.exe"
            CACHE[working_dir]="${CONFIG[spt-path]}"
            CACHE[icon]="spt_server"
        ;; 
        spt|sptarkov)
            opt_shortcut launcher
            if check_legacy_installed; then opt_shortcut legacy-server
            else opt_shortcut server; fi
            return 0
        ;;
        all) opt_shortcut bsg-launcher;  opt_shortcut spt;  return 0 ;;
        "") err "Option \"shortcut\" requires an argument" ;;
        *)
            # Create custom shortcut
            local exe_path; exe_path=$( realpath -m "${option}" )
            [[ ! -f "${exe_path}" ]] && err "File \"${exe_path}\" does not exist"
            local name="${option##*/}"; name="${name%.*}"
            local working_dir="${option%/*}"
            [[ "${working_dir}" == "${option}" ]] && working_dir="${PWD}"
            CACHE[name]="${name}"
            CACHE[exe_path]="${option##*/}"
            CACHE[args]="$*"
            CACHE[working_dir]="${working_dir}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]=$( echo "${CACHE[name]}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' )
        ;;
    esac

    # Create the shortcut
    CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
    add_app_shortcut
}


opt_clean() {
    # SYNTAX: spt-additions --no-prompt clean all 
    local option="$1" && shift
    local path; local paths=()

    case "${option}" in
        metadata) paths=( "${METADATA_DIR}" ) ;;
        cache) paths=( "${CACHE_DIR}" ) ;;
        config) paths=( "${CONFIG_DIR}" ) ;;
        data) paths=( "${DATA_DIR}" ) ;;
        runtime) paths=( "${RUNTIME_DIR}" )  ;;
        files) paths=( "${FILES_DIR}" )  ;;
        all) paths=( "${CACHE_DIR}" "${CONFIG_DIR}" "${DATA_DIR}" ) ;;
        "") err "Option \"clean\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac

    # Warn user before continuing
    if [[ -n "${paths}" ]]; then
        if [[ "${NO_PROMPT}" != 1 ]]; then
            {   msg "${BOLD}This action will remove the following files / directories ${YELLOW}permanently${RESET}:"
                for path in "${paths[@]}"; do msg "    ► ${UNDERLINE}${path}${RESET}"; done
            } | more
            yesno "Do you want to continue?" || return 1
        fi
        for path in "${paths[@]}"; do
            msg "Removing: ${path}..."
            if [[ -f "${path}" ]]; then m_rm "${path}"
            elif [[ -d "${path}" ]]; then m_rm -r "${path}"; fi
        done
        msg "${BOLD}${GREEN}Done!${RESET}"
    fi
}


opt_selfinstall() {
    local path; local bin_paths=( "${HOME}/.local/bin" "${HOME}/bin" )
    [[ -n "${XDG_BIN_HOME}" ]] && bin_paths+=( "${XDG_BIN_HOME}" )

    # Check if PATH contains any of the user bin paths
    for path in "${bin_paths[@]}"; do
        if [[ -n $( echo "${PATH}" | grep "${path}" ) ]]; then break; fi
        {   msg; warn "${BOLD}PATH variable does not contain a local bin directory!${RESET}"
            msg
            msg "   ► ${GREEN}${TITLE}${RESET} provides useful CLI commands to manage your wine prefix."
            msg "   ► Please consider installing the script to a local bin directory & adding"
            msg "   ► the directory to your PATH environment variable, e.g. by adding:"
            msg "   ► ${GREEN}export PATH=\$HOME/bin:\$HOME/.local/bin:\$PATH${RESET}"
            msg "   ► to your .bashrc / .zshrc file."
            msg "   ► After installing the script, you can run \"${GREEN}${TITLE} -h${RESET}\" for more details."
        } | more
        return 1
    done

    # Check if the script is already installed
    for path in "${bin_paths[@]}"; do
        if [[ -f "${path}/${TITLE}" ]]; then
            msg "${BOLD}${GREEN}${TITLE}${RESET} is already installed in:"
            msg "   ► ${path}"
            return 0
        fi
    done

    # Load required metadata
    load_metadata

    # Search for bin paths in the PATH environment variable
    for path in "${bin_paths[@]}"; do
        msg "${BOLD}Remote hash${RESET}: ${METADATA[additions-hash]}"
        if [[ -z $( echo "${PATH}" | grep "${path}" ) ]]; then continue; fi

        # Found a user bin path
        {   msg "${YELLOW}Found \"${path}\" in the PATH environment variable${RESET}"
            msg
            msg "   ► This script provides useful CLI commands to manage your wine prefix, e.g:"
            msg "   ► \"${GREEN}${TITLE} -e MANGOHUD=1 shortcut launcher${RESET}\"  (Set an environment variable & update an app shortcut)"
            msg "   ► \"${GREEN}${TITLE} update spt${RESET}\"                       (Update to a new SPT version)"
            msg "   ► \"${GREEN}${TITLE} -m legacy install spt${RESET}\"            (Install legacy SPT [3.11.x])"
            msg "   ► Run \"${GREEN}${TITLE} -h${RESET}\" for more details"
        } | more
        yesno "Do you want to install ${TITLE} into the user bin directory (\"${path}\")?" || return 1
        install_additions "${path}" && break
    done
}


opt_selfupdate() {
    local current_hash; current_hash=$( get_hash "${SCRIPT_PATH}" ) || err "Failed to get script hash"
    [[ -z "${current_hash}" ]] && err "Failed to get script hash"

    # Load required metadata
    load_metadata

    msg "${BOLD}Current hash${RESET}:  ${current_hash}"
    msg "${BOLD}Remote hash${RESET}:   ${METADATA[additions-hash]}"
    if [[ "${current_hash}" == "${METADATA[additions-hash]}" ]]; then
        msg "${BOLD}The script is up-to-date.${RESET}"
        return 1
    fi
    msg; msg "${BOLD}A new spt-additions version is available!${RESET}"
    msg "   ► ${BOLD}The script will attempt to download the latest version from:${RESET}"
    msg "   ► ${UNDERLINE}${METADATA[installer-script-url]}${RESET}"
    msg
    yesno "Do you want to update now?" || return 1
    install_additions "${SCRIPT_DIR}"
    return 0
}


opt_version() {
    msg "${BOLD}Version: ${RESET}${VERSION} (${DATE})"
    local current_hash; current_hash=$( get_hash "${SCRIPT_PATH}" 2>/dev/null )
    [[ -n "${current_hash}" ]] && msg "${BOLD}Hash: ${RESET}${current_hash}"
}


opt_help() {
    local option="${1}"
    case "${option}" in
        install)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|tarkov                 - Install the BSG Launcher"
                msg "spt|sptarkov                   - Install SPTarkov"
                msg "fika                           - Install Fika (core + server mod)"
                msg 
                msg "${BOLD}SPTarkov install modes (-m switch):${RESET}"
                msg "latest                         - Use the latest install method to install the latest SPTarkov release"
                msg "legacy                         - Install the legacy version of SPTarkov"
                msg "proton                         - Use Proton to install the latest version of SPTarkov"
                msg
                opt_help switches
            } | more
        ;;
        uninstall)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|tarkov                 - Uninstall the BSG Launcher"
                msg "spt|sptarkov                   - Uninstall SPTarkov"
                msg "all                            - Uninstall everything (prefix, EFT & SPT)"
                msg
                opt_help switches
            } | more
        ;;
        update)
            {   msg "${BOLD}Available options:${RESET}"
                msg "spt|sptarkov                   - Update SPTarkov to the latest version"
                msg "fika                           - Update Fika to the latest version"
                msg "proton                         - Update GE-Proton to the latest version"
                msg "additions|script               - Update this additions script"
                msg
                opt_help switches
            } | more
        ;;
        patch)
            {   msg "Downpatch EFT game files to a supported version for SPTarkov"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE patch [target_path] [source_path]${RESET}"
                msg
                msg "${BOLD}Example:${RESET}"
                msg "${YELLOW}$TITLE patch \"${DEFAULT_SPT_DIR}\" \"~/Downloads/patcher\"${RESET}"
                msg
                msg "target_path            - Destination install directory (defaults to \"${DEFAULT_SPT_DIR}\")"
                msg "source_path            - Directory containing SPT_Patches (defaults to \"target_path\")"
                msg
                opt_help switches
            } | more
        ;;
        run)
            {   msg "Run EFT/SPT or custom commands inside the prefix"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] run [eft|launcher|server|custom_command] [ARGS...]${RESET}"
                msg
                msg "${BOLD}Examples:${RESET}"
                msg "${YELLOW}$TITLE run launcher${RESET}"
                msg "${YELLOW}$TITLE run winecfg${RESET}"
                msg "${YELLOW}$TITLE run winetricks [VERBS...]${RESET}"
                msg "${YELLOW}$TITLE run ./custom.exe --example-arg${RESET}"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|bsg-launcher           - Run the BSG Launcher"
                msg "launcher                       - Run the SPT Launcher"
                msg "server                         - Run the SPT Server"
                msg "custom_command                 - Run a custom command inside the prefix"
                msg
                opt_help switches
            } | more
        ;;
        dlloverride)
            {   msg "Add a DLL override to the wine prefix"
                msg 
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] dlloverride [DLL_NAME] [override_type]${RESET}"
                msg
                msg "${BOLD}Example:${RESET}"
                msg "${YELLOW}$TITLE dlloverride d3d11 n,b${RESET}"
                msg
                opt_help switches
            } | more
        ;;
        env)
            {   msg "Set, unset and list environment variables for the wine prefix"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "set|add [KEY=VALUE]            - Set or add an environment variable"
                msg "unset|remove [KEY]             - Unset or remove an environment variable"
                msg "list|-l                        - List all active environment variables"
                msg
                opt_help switches
            } | more
        ;;
        shortcut)
            {   msg "${BOLD}Available options:${RESET}"
                msg "eft|bsg|bsg-launcher           - Create/update BSG Launcher shortcut"
                msg "launcher                       - Create/update SPT Launcher shortcut"
                msg "server                         - Create/update SPT Server shortcut"
                msg "legacy-server                  - Create/update legacy SPT Server shortcut"
                msg "spt|sptarkov                   - Create/update all SPT shortcuts"
                msg "all                            - Create/update all available shortcuts"
                msg "custom_executable              - Create/update custom shortcuts"
                msg
                opt_help switches
            } | more
        ;;
        clean)
            {   msg "Clean installer and prefix files"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "metadata                       - Remove metadata files"
                msg "cache                          - Remove all cached files"
                msg "config                         - Remove configuration files"
                msg "data                           - Remove installer data files"
                msg "runtime                        - Remove static runtime / libraries"
                msg "files                          - Remove cached installer / archive files"
                msg "all                            - Remove all of the above"
                msg
                opt_help switches
            } | more
        ;;
        self-install)
            {   msg "Install this additions script to a local bin directory for ease of use"
                msg 
            } | more
        ;;
        self-update)
            {   msg "Update this additions script to the latest version"
                msg
            } | more
        ;;
        switches)
            {   msg "${BOLD}Available switches:${RESET}"
                msg "-p <path>                      - Specify a custom wine prefix path"
                msg "-e <KEY=VALUE>                 - Set an environment variable for the prefix"
                msg "-m <mode>                      - Set the install mode for SPTarkov (latest, legacy, proton)"
                msg "--no-prompt                    - Disable all prompts and assume \"yes\" as answer"
                msg "--no-ansi                      - Disable ANSI colors in output"
                msg "-h|--help                      - Show help message"
                msg "-v|--version                   - Show version info"
            } | more
        ;;
        "") 
            {   msg "${BOLD}${TITLE} - Standalone EFT/SPTarkov installer & configuration tool${RESET}"
                msg
                msg "${BOLD}Usage:${RESET}"
                msg "${YELLOW}$TITLE [SWITCHES] <option> [ARGS...]${RESET}"
                msg
                msg "${BOLD}Available options:${RESET}"
                msg "install                        - Install EFT/SPT"
                msg "uninstall                      - Uninstall EFT/SPT"
                msg "update                         - Update EFT/SPT or this script"
                msg "run                            - Run EFT/SPT or custom commands inside the prefix"
                msg "dlloverride                    - Add a DLL override to the wine prefix"
                msg "env                            - Set, unset and list environment variables for the wine prefix"
                msg "shortcut                       - Create application menu shortcuts"
                msg "patch                          - Downpatch EFT game files to a supported version for SPTarkov"
                msg "clean                          - Clean installer and prefix files"
                msg "self-install                   - Install this script to a local bin directory for ease of use"
                msg "self-update                    - Update this script to the latest version"
                msg "version                        - Print the VERSION info message"
                msg "help                           - Print this help message or help for a specific option"
                msg
                msg "Run \"${BOLD}$TITLE help <option>${RESET}\" for more information about a specific option."
            } | more
        ;;
        *) msg "Invalid option: ${option}" ;;
    esac
}


# # # # # # # # # # # #
# Main loop functions #
# # # # # # # # # # # #

handle_opts() {
    # Handle switches
    while getopts ":p:e:a:m:h:v:-:" subopt; do
        case ${subopt} in
            p) set_prefix_path "${OPTARG}" ;;
            e) opt_env set "${OPTARG}" ;;
            m)
                case "${OPTARG}" in
                    latest|proton|legacy|lutris)
                        msg "Setting install mode to \"${OPTARG}\"..."
                        set_value config "install-mode=${OPTARG}"
                    ;;
                    *) err "Invalid mode: ${OPTARG}" ;;
                esac
            ;;
            v) opt_version ;;
            h) opt_help ;;
            -*)
                case "${OPTARG}" in
                    no-prompt) export NO_PROMPT=1; msg "\"NO_PROMPT\" option set" ;;
                    no-ansi) export NO_ANSI=1; msg "\"NO_ANSI\" option set" ;;
                    self-install) opt_selfinstall ;;
                    self-update) opt_selfupdate ;;
                    version) opt_version ;;
                    help) opt_help ;;
                    *) err "Invalid switch: --${OPTARG}" ;;
                esac
            ;;
            :)
                case "${OPTARG}" in
                    h) opt_help ;;
                    v) opt_version ;;
                    *) err "Switch \"${OPTARG}\" requires an argument" ;;
                esac
            ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done
    shift $((OPTIND-1))

    local option="${1}" && shift
    
    # Check native dependencies
    case "${option}" in
        "") [[ $OPTIND -eq 1 ]] && check_native_deps ;;
        install|shortcut|uninstall|patch|update|dlloverride|run) check_native_deps ;;
    esac

    # Initialize wine prefix
    case "${option}" in
        shortcut|uninstall) set_prefix_path "${WINEPREFIX}" 1>/dev/null ;;
        install|update|dlloverride|run) init_prefix ;;
    esac

    # Handle options
    case "${option}" in
        install) opt_install "$@" ;;
        uninstall) opt_uninstall "$@" ;;
        update) opt_update "$@" ;;
        patch) opt_patch "$@" ;;
        run) opt_run "$@" ;;
        dlloverride) opt_dlloverride "$@" ;;
        env) opt_env "$@" ;;
        shortcut) opt_shortcut "$@" ;;
        clean) opt_clean "$@" ;;
        self-update) opt_selfupdate ;;
        self-install) opt_selfinstall ;;
        version) opt_version ;;
        help) opt_help "$@";;
        "") [[ $OPTIND -eq 1 ]] && opt_guided_install ;;
        *) err "Invalid option: ${option}" ;;
    esac
}


main() {
    # Create dirs
    local dirs=( "${TMP_DIR}" "${DATA_DIR}" "${RUNTIME_DIR}" "${CONFIG_DIR}" "${APP_DIR}" "${ICO_DIR}" "${FILES_DIR}" )
    local dir; for dir in "${dirs[@]}"; do [[ ! -d "${dir}" ]] && mkdir -p "${dir}"; done

    # Set default config variables
    [[ -f "${CONFIG_PATH}" ]] && load_array config
    set_spt_path "${CONFIG[spt-path]:-${DEFAULT_SPT_DIR}}"
    set_value config "install-mode=${CONFIG[install-mode]:-"${DEFAULT_INSTALL_MODE}"}"
    set_value config "steam-library-path=${CONFIG[steam-library-path]:-"${DEFAULT_STEAM_LIBRARY_PATH}"}"

    # Set default environment variables
    [[ -f "${ENV_PATH}" ]] && load_array env
    [[ -z "${ENV[WINEPREFIX]}" ]] && set_value env "WINEPREFIX=${WINEPREFIX:-"${DEFAULT_WINEPREFIX}"}"
    [[ -z "${ENV[PROTONPATH]}" ]] && set_value env "PROTONPATH=${PROTONPATH:-"${DEFAULT_PROTONPATH}"}"
    [[ -z "${ENV[PROTON_USE_XALIA]}" ]] && set_value env "PROTON_USE_XALIA=0"
    [[ -z "${ENV[DOTNET_BUNDLE_EXTRACT_BASE_DIR]}" ]] && set_value env "DOTNET_BUNDLE_EXTRACT_BASE_DIR="
    [[ -z "${ENV[DOTNET_ROOT]}" ]] && set_value env "DOTNET_ROOT="

    # Remove old log file
    [[ -f "${LOG_PATH}" ]] && m_rm "${LOG_PATH}"

    # Load initial metadata file (7 days time-to-live)
    if ! check_ttl "${METADATA_PATH}" 604800; then load_metadata
    else load_array metadata; fi

    # Export paths
    export WINEDEBUG="${WINEDEBUG:-"+debugstr,err+all,fixme+all"}"
    export WINEPREFIX="${ENV[WINEPREFIX]}"
    export PROTONPATH="${ENV[PROTONPATH]}"
    export PATH=$RUNTIME_DIR:$PATH

    # Check for updates (5 days interval)
    if [[ -f "${SCRIPT_PATH}" ]] && ! check_ttl "${SCRIPT_PATH}" 432000; then
        if opt_selfupdate; then
            # Clear temp
            [[ -d "${TMP_DIR}" ]] && m_rm -r "${TMP_DIR}"
            # replace shell with updated script
            exec "${SCRIPT_PATH}" "$@"
        else
            # Reset modified time
            touch "${SCRIPT_PATH}"
        fi
    fi

    # Handle command line arguments
    handle_opts "$@"
    m_exit 0
}

# Main entry
main "$@"
