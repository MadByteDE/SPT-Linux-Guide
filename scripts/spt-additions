#!/usr/bin/env bash

# # # # # # # # # 
# SPT-ADDITIONS #
# # # # # # # # # 

# exit codes:
# 1: general error | 10: -d check failed | 11: -f check failed | 12: empty string | 13: m_7z failed
# 14: case char mismatch

# TODO: Think about splitting the script up and source common functions
# Downside would be less portability :/
TITLE="spt-additions"
AUTHOR="MadByte"
LICENSE="MIT"
VERSION="0.5.7"
DATE="2025-08-23"

# ANSI codes
BOLD="\e[1m"; UNDERLINE="\e[2m"; RESET="\e[0m"
RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[36m"
YELLOW="\e[33m"; GRAY="\e[90m"

# System directories
readonly DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
readonly CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly DATA_DIR="${DATA_HOME}/${TITLE}" && mkdir -p "${DATA_DIR}"
readonly RUNTIME_DIR="${DATA_DIR}/runtime" && mkdir -p "${RUNTIME_DIR}"
readonly CACHE_DIR="${CACHE_HOME}/${TITLE}" && mkdir -p "${CACHE_DIR}"
readonly CONFIG_DIR="${CONFIG_HOME}/${TITLE}" && mkdir -p "${CONFIG_DIR}"
readonly TMP_DIR="${CACHE_DIR}/tmp" && mkdir -p "${TMP_DIR}"
readonly ICO_DIR="${DATA_HOME}/icons/hicolor/256x256/apps" && mkdir -p "${ICO_DIR}"
readonly APP_DIR="${DATA_HOME}/applications"
readonly DEFAULT_PFX_DIR="${HOME}/Games/tarkov"
readonly DEFAULT_SPT_DIR="drive_c/SPTarkov"
readonly FAUGUS_CONFIG_DIR="$CONFIG_HOME/faugus-launcher"

# File path variables
readonly LOG_PATH="${CACHE_DIR}/installer.log"
readonly SCRIPT_PATH="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" && pwd )"
readonly UMU_PATH=$( command -v umu-run || echo "${RUNTIME_DIR}/umu-run" )
readonly CONFIG_PATH="${CONFIG_DIR}/prefix.conf"
readonly ENV_PATH="${CONFIG_DIR}/env.conf"
readonly MOD_PATH="${CACHE_DIR}/SPT.7z"
readonly PATCHER_PATH="${CACHE_DIR}/Patcher.7z"
readonly MOD_JSON_PATH="${CACHE_DIR}/release.json"
readonly PATCHER_JSON_PATH="${CACHE_DIR}/mirrors.json"
readonly FAUGUS_JSON_PATH="${FAUGUS_CONFIG_DIR}/games.json"

declare -A CONFIG
declare -A ENV
declare -a ARGS
declare -A CACHE

declare -A URL
# Libraries / Tools
URL[umu-launcher]="https://github.com/Open-Wine-Components/umu-launcher/releases/download/1.2.9/umu-launcher-1.2.9-zipapp.tar"
URL[hpatchz]="https://github.com/sisong/HDiffPatch/releases/download/v4.11.1/hdiffpatch_v4.11.1_bin_linux64.zip"
URL[jq]="https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-linux-amd64"
# Installers
URL[bsg-launcher]="https://prod.escapefromtarkov.com/launcher/download"
URL[spt-installer]="https://ligma.waffle-lord.net/SPTInstaller.exe"
# Scripts
URL[installer-script]="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/refs/heads/SPTv4-dev/scripts/spt-additions"
# Icons
URL[bsg-launcher-ico]="https://cdn2.steamgriddb.com/icon/33686c2d8930be81c843ffb7d4312605/32/256x256.png"
URL[spt-launcher-ico]="https://cdn2.steamgriddb.com/icon_thumb/ddd4f86cd0f978e85155cfa6c9f94e0c.png"
URL[spt-server-ico]="https://cdn2.steamgriddb.com/icon_thumb/9f7431ea593b8e57401c08f40adc6e34.png"
# Metadata
URL[patcher-json]="https://slugma.waffle-lord.net/mirrors.json"
URL[mod-json]="https://spt-releases.modd.in/release.json"
# Links
URL[guide-repo]="https://github.com/MadByteDE/SPT-Linux-Guide"
URL[discord]="https://discord.com/invite/Xn9msqQZan"
readonly -A URL

# We don't want to run as root
if [[ "$( id -u )" -eq 0 ]]; then
    echo "This script is not supposed to be run as root!"
    exit 1
fi

# Shell options
shopt -s extglob

# Make sure to throw an error on SIGINT
trap int INT; int() { err "Interrupt received"; }


# # # # # # # # # #
# Alias functions #
# # # # # # # # # #

m_exit() {
    local status=${1:-$?}

    # Remove tmp files
    if [[ -d "${TMP_DIR}" ]] && [[ -n $( ls "${TMP_DIR}" 2>/dev/null ) ]]; then
        m_rmdir "${TMP_DIR}/"
    fi

    # Exit with passed status code
    exit "${status}"
}


m_chmod() {
    chmod "$@" &>> "${LOG_PATH}" || err "Command \"$*\" failed (status code $?)"
}


m_cp() {
    local source_path="${1}"; local target_path="${2}"
    # Check exists
    [[ ! -d "${source_path}" ]] && err "Source \"${source_path}\" does not exist"
    # Check if the target path is inside a valid directory
    case "${target_path}" in
        *"${CONFIG[pfx_dir]}"* | *"${CACHE_DIR}"*) ;;
        *) err "Invalid target directory \"$target_path\"" ;;
    esac
    # Create missing directories
    mkdir -p "${target_path}"
    # Copy files to target path
    if [[ -n "$( ls -A "${source_path}" )" ]]; then
        cp --reflink=auto -r "${source_path}"* "${target_path}" \
        || err "Command \"$*\" failed (status code $?)"
    fi
}


m_rm() {
    local path="${1%/}"
    if [[ -d "${path}" ]]; then
        err "Cannot remove directories. Use \"m_rmdir\" instead."
    fi
    rm "$1" || err "Command \"$*\" failed (status code $?)"
}


m_rmdir() {
    local path="${1%/}"
    if [[ -f "${path}" ]]; then
        warn "Cannot remove single files. Use \"m_rm\" instead."
        exit 1
    fi
    case "$path" in
        ""|"${HOME%/}"|"${CONFIG_HOME%/}"|"${CACHE_HOME%/}"|"${DATA_HOME%/}")
            warn "Directory \"$path\" cannot be removed"
            exit 1
        ;;
        *) rm -r "$1" || exit 1 ;;
    esac
}


m_7z() {
    local archive_path="${1}"; local target_path="${2}"
    filename="${archive_path##*/}"
    # Extract
    msg "Extracting \"${filename}\""
    7z x -aoa "${archive_path}" -o"${target_path}" 1>/dev/null; status=$?
    [[ "$status" != 0 ]] && err "Failed to extract \"${filename}\" (status code $status)"
}


m_curl() {
    curl --connect-timeout 30 -f "$@" || err "Command \"$*\" failed (status code $?)"
}


m_umu() {
    "${UMU_PATH}" "$@" &>> "${LOG_PATH}" || err "Command \"$*\" failed (status code $?)"
}


# # # # # # # # # # #
# Helper functions  #
# # # # # # # # # # #

msg() {
    local filtered_str
    local output="${GRAY}[$TITLE]${RESET} ${*}"
    filtered_str=$( echo -e "${output}" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' )

    # Print to terminal
    echo -e "${output}"

    # Write to log file
    if [[ -d "${CACHE_DIR}" ]]; then
        echo "${filtered_str}" &>> "${LOG_PATH}"
    fi
}


warn() {
    local pfx="${BLUE}Warn ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}$1"
}


err() {
    local status=$?
    local pfx="${BOLD}${RED}ERROR ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}$1"
    msg "${pfx}See \"${LOG_PATH}\" for more details.${RESET}"
    m_exit ${status}
}


dbg() {
    local pfx="${GRAY}DEBUG ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}$1"
}


ask() {
    printf "${GRAY}[${TITLE}]${RESET} $* [y/n] "
    while true; do
        read -r -p "> " yn
        case $yn in
            [Yy]*) return 0 ;;  
            [Nn]*) msg "Aborted"; m_exit 0 ;;
        esac
    done
}


set_value() {
    local key value
    local array_name="${1}"
    local input="${2}" || err "Missing argument: set_value [array_name] [input]"
    # msg "DEBUG: Input is \"${input}\""
    key="$( echo "$input" | cut -d '=' -f 1 )"
    value="$( echo "${input//["\""]}" | cut -d '=' -f 2- )"
    # Fail if no key is provided
    [[ -z "$key" ]] && err "Input \"$input\" in \"$array_name\" has no key"
    case "${array_name}" in
        config)
            case "${value}" in
                "") err "Key \"$key\" in \"$array_name\" has no value" ;;
                *) CONFIG[$key]="${value%/}"
            esac
        ;;
        env) ENV[$key]="${value%/}" ;;
        *) err "Invalid array name: \"$array_name\""
    esac
}


load_array() {
    local path
    local array_name="${1}" || err "Missing argument: load_array [array_name]"
    case "$array_name" in
        config) path="${CONFIG_PATH}" ;;
        env) path="${ENV_PATH}" ;;
        *) err "Invalid argument \"$array_name\"";;
    esac
    # Warn if the file does not exist
    if [[ ! -f "$path" ]]; then
        warn "Failed to load \"$path\": File does not exist"
        return
    fi
    # Read lines & load values
    while read -r line; do
        case "${line}" in
            *=*) set_value "$array_name" "$line" ;;
            *) err "Cannot load setting \"$line\": Invalid format" ;;
        esac
    done < "$path"
}


save_array() {
    local array_name="${1}" || err "Missing argument: \"array_name\""
    case "${array_name}" in
        config)
            [[ -f "${CONFIG_PATH}" ]] && m_rm "${CONFIG_PATH}"
            for key in "${!CONFIG[@]}"; do
                echo "${key}=\"${CONFIG[$key]}\"" >> "${CONFIG_PATH}"\
                || err "Failed to write \"${CONFIG_PATH}\""
            done
        ;;
        env)
            [[ -f "${ENV_PATH}" ]] && m_rm "${ENV_PATH}"
            for key in "${!ENV[@]}"; do
                echo "${key}=\"${ENV[$key]}\"" >> "${ENV_PATH}"\
                || err "Failed to write \"${ENV_PATH}\""
            done
        ;;
        *) ;;
    esac
}


export_env() {
    for key in "${!ENV[@]}"; do
        export "$key=${ENV[$key]}"
    done
}


get_env_string() {
    for key in "${!ENV[@]}"; do
        local var="$key=${ENV[$key]} "
        env+="$var"
    done
    printf "${env}\n"
}


# # # # # # # # # # # # #
# EFT Helper functions  #
# # # # # # # # # # # # #

get_eft_path() {
    local entry path
    [[ ! -d "${CONFIG[pfx_dir]}" ]] && exit 10
    [[ ! -f "${CONFIG[pfx_dir]}/system.reg" ]] && exit 11
    # get windows formatted path
    entry=$( sed -n '/Uninstall\\\\EscapeFromTarkov/,/^$/p' "${CONFIG[pfx_dir]}/system.reg" )
    path=$( echo "${entry}" | grep -o "\"InstallLocation\"=\"[^}]*" | cut -d "\"" -f4 2>/dev/null )
    [[ -z "$path" ]] && exit 12
    # Replace backslashes with slashes
    path="${path//\\\\/\/}"
    # Finally assemble the full path & return it
    printf "${CONFIG[pfx_dir]}/${path//C:/drive_c}\n"
}


get_eft_version() {
    local version
    [[ ! -d "${EFT_DIR}" ]] && exit 10
    # Check if main exe exists
    local path="${EFT_DIR}/EscapeFromTarkov.exe"
    [[ ! -f "${path}" ]] \
    && err "File \"${path}\" does not exist"
    # Extract metadata
    m_7z "${path}" "${TMP_DIR}" 1>/dev/null
    # Get the EFT version from the version.txt file
    version=$( cat "${TMP_DIR}/.rsrc/0/version.txt" | head -1 | tr -d '\0\r' | cut -d "," -f4 2>/dev/null )
    [[ -z "${version}" ]] && exit 12
    printf "${version}\n"
}


# # # # # # # # # # # # # # #
# Patcher Helper functions  #
# # # # # # # # # # # # # # #

get_patcher_urls() {
    local urls
    local json_path="${1:-"${PATCHER_JSON_PATH}"}"
    local index="${2}"
    urls=$( cat "${json_path}" | jq -r '.Mirrors[].Link' )
    [[ -z "${urls}" ]] && exit 12
    # Return a specific url
    if [[ -n "${index}" ]]; then
        echo "${urls}" | sed "${index}q;d" 2>/dev/null
        return 0
    fi
    # Return the full list
    printf "${urls}\n"
}


get_patcher_eft_version() {
    local url filename version
    local json_path="${1:-"${PATCHER_JSON_PATH}"}"
    url=$( get_patcher_urls "${json_path}" 1 ) || exit 1
    # Split filename to get version infos from it
    filename=$( echo "${url##*/}" | tr "_." " " )
    # get target EFT version
    version=$( echo "${filename}" | cut -d " " -f5 )
    # Check returned value
    case "${version}" in
        ""|*[!0-9]*) exit 14 ;;
        *) printf "${version}\n" ;;
    esac
}


download_patcher() {
    # Set global variable for patcher mirror urls
    local urls
    urls=$( get_patcher_urls ) || err "Failed to get patcher mirrors"
    # Try to download from first to last
    echo "${urls}" | while read -r url; do
        msg "Downloading \"$url\"..."
        m_curl -L "${url}" -o "${PATCHER_PATH}" && break
    done
}


# # # # # # # # # # #
#  Check functions  #
# # # # # # # # # # #

check_disk_space() {
    local path=${1:-"${CONFIG[pfx_dir]}"}
    [[ -z "${path}" ]] && err "Missing path argument"
    # Get required values
    local free_kb eft_kb free_gb total_gb
    free_kb=$( df -k "${path}" | tail -1 | awk '{print $4}' )
    eft_kb=$( du -cs "${EFT_DIR}" | head -1 | cut -d$'\t' -f1 )
    local overhead_kb=$((1024*1024*10))
    local total_kb=$((eft_kb + overhead_kb))
    free_gb=$( echo "$free_kb" | awk '{ free = $1/1024/1024 ; printf("%.2fGiB\n", free) }' )
    total_gb=$( echo $total_kb | awk '{ total = $1/1024/1024 ; printf("%.2fGiB\n", total) }' )
    # Check if there's enough space
    [[ $free_kb -le $total_kb ]] && err "Not enough free disk space! ($free_gb free < $total_gb needed)"
    msg "Enough free disk space available! ($free_gb free > $total_gb needed)"
}


check_prefix_path() {
    local pfx_path="${1%/}"
    local check_paths=("${pfx_path}/system.reg" "${pfx_path}/dosdevices" "${pfx_path}/drive_c")
    [[ $pfx_path != /* ]] && err "Malformed prefix path: \"$pfx_path\""
    if [[ -d "$pfx_path" ]]; then
        for p in "${check_paths[@]}"; do
            if [[ ! -f "$p" ]] && [[ ! -d "$p" ]]; then
                set_value config "pfx_dir=${DEFAULT_PFX_DIR}"
                save_array config
                err "Invalid wine prefix directory: \"${pfx_path}\""
            fi
        done
    fi
}


check_spt_path() {
    local spt_path="${1%/}"
    if [[ "$spt_path" != *"drive_c"* ]]; then
        set_value config "spt_dir=${DEFAULT_SPT_DIR}"
        save_array config
        err "Invalid spt path: \"${spt_path}\""
    fi
}


check_dotnet() {
    local status
    # Check for .NET Core and ASP.NET Runtime
    if ! "$( dotnet --list-runtimes 2>/dev/null | grep -q "AspNet" | grep -q "9.0" )"; then
        msg "${YELLOW}> \"ASP.NET Runtime 9.0\" is not installed on your system${RESET}"
        status=1
    fi
    if [ "$status" = 1 ]; then
        msg "${YELLOW}> Please install all missing dependencies & try again.${RESET}"
        err "Missing dependencies"
    fi
}


check_native_deps() {
    local status
    local cmds=( "7z" "xxd" "hpatchz" "jq" )
    msg "Checking for native dependencies..."
    # Check each cmd and error out if something is missing
    for cmd in "${cmds[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            case ${cmd} in
                jq)
                    $(install_dep "jq" "${URL[jq]}")\
                    || msg "${YELLOW}> Failed to install \"$cmd\". Please install it manually."
                    status=1
                ;;
                hpatchz)
                    $(install_dep "hpatchz" "${URL[hpatchz]}")\
                    || msg "${YELLOW}> Failed to install \"$cmd\". Please install it manually."
                    status=1
                ;;
                7z) msg "${YELLOW}> \"$cmd\" is not installed on your system${RESET}" && status=1 ;;
                xxd) msg "${YELLOW}> \"$cmd\" is not installed on your system${RESET}" && status=1 ;;
                mangohud) msg "${BLUE}HINT${RESET}: \"$cmd\" is not installed on your system." ;;
                gamemode) msg "${BLUE}HINT${RESET}: \"$cmd\" is not installed on your system." ;;
            esac
        fi
    done
    if [ "$status" = 1 ]; then
        err "Please install all missing dependencies & try again."
    fi
}


check_eft_running() {
    local processes=( "BsgLauncher.exe" "EscapeFromTarko" )
    for process in "${processes[@]}"; do
        if [[ -n $( pidof "$process" ) ]]; then
            msg "${YELLOW}> \"$process\" is currently running! Please close it to continue."
            err "\"$process\" is running"
        fi
    done
}


check_hash() {
    local file_hash
    local file_path="${1}"; local expected_hash="${2}"
    # Check arguments
    [[ ! -f "${file_path}" ]] && err "File \"${file_path}\" does not exist"
    [[ -z "${expected_hash}" ]] && err "Missing \"expected_hash\" argument"
    # use file to calculate MD5 hash and ENCODE in base64
    msg "Calculating checksum of file \"${file_path##*/}\""
    file_hash=$( md5sum "${file_path}" | cut -d ' ' -f 1 | xxd -r -p | base64 2>/dev/null )
    [[ -z "${file_hash}" ]] && err "Failed to calculate hash"
    # dbg "File hash: ${file_hash} Expected hash: ${expected_hash}"
    # Compare
    if [[ "${file_hash}" != "${expected_hash}" ]]; then
        warn "Hash check mismatch (File: \"${file_hash}\" != Expected: \"${expected_hash}\")"
        return 1
    fi
    msg "Hash check successful"
}


check_cached() {
    local cached_path="${1}"; [[ -z "${cached_path}" ]] && err "Missing cached path argument"
    local expected_hash="${2}"; [[ -z "${expected_hash}" ]] && err "Missing expected hash argument"
    # Make sure the path actually is in CACHE_PATH
    [[ "$cached_path" == *"${CACHE_DIR}"* ]] \
    || err "Given file isn't inside the scripts cache directory"
    # Verify the file is there and valid
    local filename=${cached_path##*/}
    msg "Checking for cached file \"${filename}\""
    if [[ -f "${cached_path}" ]]; then
        msg "Found \"${filename}\" in cache directory"
        # Check hash
        if ! check_hash "${cached_path}" "${expected_hash}"; then
            msg "Removing cached file \"${filename}\""
            m_rm "${cached_path}"
            return 1
        else
            return 0
        fi
    else
        msg "\"${cached_path}\" is not cached"
        return 1
    fi
}


check_ttl() {
    local c_time m_time e_time
    local file_path="${1}"
    # Check if file exists, if not - fail the check
    [[ ! -f "${file_path}" ]] && msg "File \"${file_path}\" does not exist" && return 1
    # Calculate time elapsed since last modified
    local ttl="${2:-"3600"}" 
    c_time=$( date +%s )
    m_time=$( date -r "${file_path}" +%s )
    ((e_time = c_time - m_time))
    # If elapsed time >= TTL - fail the check
    if [[ $e_time -ge $ttl ]]; then
        warn "File \"${file_path}\" is out of date"
        return 1
    fi
}


# # # # # # # # # # # # #
#  Installer functions  #
# # # # # # # # # # # # #

winetricks_install() {
    local verb="${1}"; local name="${2}"; local args="${3}"
    # Skip if dependency is already installed
    if ! cat "${CONFIG[pfx_dir]}/winetricks.log" 2>/dev/null | grep -q "$verb"; then
        msg "Installing $name..."
        m_umu winetricks -q $verb $args
    fi
}


install_dep() {
    local cmd_name="$1"; local url="$2"
    local source_path="${3:-$TMP_DIR}"; local target_path="${4:-$RUNTIME_DIR}"
    local download_name="${url##*/}"
    [[ "$download_name" = *"."* ]] && local file_ext=".${download_name##*.}"
    local file_name="${cmd_name}${file_ext}"
    cd "${TMP_DIR}" || err "Failed to change directory to \"$TMP_DIR\""
    # Download
    msg "Downloading \"$cmd_name\"..."
    m_curl -L "${url}" -o "${file_name}"
    # Exctract archive if needed
    case "$file_ext" in
        *.zip*|*.7z*) m_7z "${file_name}" "${TMP_DIR}" ;;
        *.tar*) tar -xf "${file_name}" || err "Failed to extract tar archive" ;;
        *) ;;
    esac
    local file_path=$( find "$source_path" \( -name "$cmd_name" -type f \) )
    [[ -z "$file_path" ]] && err "Cannot find \"$cmd_name\" in \"$source_path\""
    # Change permissions
    chmod +x "$file_path" || err "Failed to set permissions for \"$cmd_name\""
    # Move to target directory
    mv -f "$file_path" "$target_path/$cmd_name" || err "Failed to move \"$cmd_name\" into \"${target_path}\""
    msg "Installed \"$cmd_name\" successfully"
}


install_eft() {
    msg "Starting \"Escape from Tarkov\" setup..."
    opt_setprefix "${CONFIG[pfx_dir]}"

    # HACK: make sure to use UMU-Proton for dotnet48
    export PROTONPATH="UMU-Latest"

    if [[ ! -d "${CONFIG[pfx_dir]}" ]]; then
        # Initialize prefix
        msg "Initializing wine prefix..."
        m_umu wineboot -u || err "Failed to initialize wine prefix"
    fi

    # Install game dependencies
    winetricks_install "dotnet48" ".NET 4.8 Runtime (this might take a while)"
    winetricks_install "vcrun2022" "Microsoft Visual C++ 2015-2022 Redistributable"

    # Add prefix update pop-up workaround
    msg "Adding window pop-up workaround..."
    m_umu reg add "HKLM\\Software\\Microsoft\\.NETFramework" /v "OnlyUseLatestCLR" /t "REG_DWORD" /d 0001 /f

    # Add mouse focus workaround
    msg "Adding mouse focus workaround to registry..."
    m_umu reg add "HKCU\\Software\\Wine\\X11 Driver" /v "UseTakeFocus" /t "REG_SZ" /d "N" /f
    
    # Download BSG Launcher if needed
    if [[ ! -f "${CACHE_DIR}/BsgLauncher.exe" ]]; then
        msg "Downloading BSG Launcher..."
        cd "${CACHE_DIR}" && m_curl -L "${URL[bsg-launcher]}" -o "BsgLauncher.exe"
    fi

    # Install BSG Launcher
    msg "Installing BSG Launcher..."
    m_umu "${CACHE_DIR}/BsgLauncher.exe" /VERYSILENT

    # Re-initialize prefix for GE-Proton
    export PROTONPATH="GE-Proton"
    msg "Updating wine prefix..."
    m_umu wineboot -u

    # Copy icon to user icons directory
    if [[ ! -f "${ICO_DIR}/bsg_launcher.png" ]]; then
        msg "Getting app icon from SteamGridDB..."
        cd "${ICO_DIR}" && m_curl -L "${URL[bsg-launcher-ico]}" -o "bsg_launcher.png"
    fi

    # Create application shortcut
    opt_shortcut bsg-launcher

    msg "${GREEN}Done! ※\(^o^)/※${RESET}"
}


install_spt() {
    local install_mode="${1:-"proton"}"
    
    msg "Starting \"SPTarkov\" setup..."
    msg "Install mode is \"$install_mode\"..."

    check_eft_running

    # Check for dotnet / aspnet dependencies (for SPT 4.x)
    # check_dotnet

    # Define used prefix
    opt_setprefix "${CONFIG[pfx_dir]}"

    if [[ ! -d "${EFT_DIR}" ]]; then
        msg "> ${YELLOW}Escape from Tarkov is not installed.${RESET}"
        msg "> ${YELLOW}make sure to install the game inside the BSG Launcher & try again!${RESET}"
        err "Escape from Tarkov not found."
    elif [[ -d "${SPT_DIR}" ]]; then
        msg "> ${YELLOW}SPTarkov directory already exists.${RESET}"
        msg "> ${YELLOW}If you want to reinstall, make sure to remove the old installation first!${RESET}"
        err "SPTarkov directory already exists."
    fi
    
    # Install dependencies
    winetricks_install "dotnetdesktop8" ".NET Desktop 8 Runtime"
    winetricks_install "dotnetdesktop9" ".NET Desktop 9 Runtime"

    # Add DLL overrides
    msg "Adding DLL overrides to registry..."
    m_umu reg add "HKCU\\Software\\Wine\\DllOverrides" /v "winhttp" /t "REG_SZ" /d "native,builtin" /f

    # Install SPT
    case "$install_mode" in
        native) install_spt_native ;;
        lutris|proton) install_spt_proton ;;
        ""|*) err "Invalid install mode \"$install_mode\""
    esac

    # Install server launch script
    install_launch_script

    case "$install_mode" in
        native|proton)
            # Copy icon to user icons directory
            if [[ ! -f "${ICO_DIR}/spt_launcher.png" ]] || [[ ! -f "${ICO_DIR}/spt_server.png" ]]; then
                msg "Getting app icons from SteamGridDB..."
                cd "${ICO_DIR}" && m_curl -L "${URL[spt-launcher-ico]}" -o "spt_launcher.png"
                cd "${ICO_DIR}" && m_curl -L "${URL[spt-server-ico]}" -o "spt_server.png"
            fi
            # Create application shortcuts
            opt_shortcut spt
        ;;
        ""|*) err "Invalid install mode \"$install_mode\""
    esac

    msg "${GREEN}Done! ※\(^o^)/※${RESET}"
}


install_spt_native() {
    # Pre-Checks
    check_native_deps
    check_disk_space

    # Get required metadata for mod and patcher releases
    check_ttl "${MOD_JSON_PATH}" || m_curl -L "${URL[mod-json]}" -o "${MOD_JSON_PATH}"
    check_ttl "${PATCHER_JSON_PATH}" || m_curl -L "${URL[patcher-json]}" -o "${PATCHER_JSON_PATH}"

    # Fetch some juicy data
    local installed_eft patcher_eft mod_eft mod_version
    local mod_url mod_hash patcher_hash
    installed_eft=$( get_eft_version ) || m_exit 1
    mod_eft="$( jq -r '.ClientVersion' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_version="$( jq -r '.AkiVersion' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_url="$( jq -r '.Mirrors[].DownloadUrl' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_hash="$( jq -r '.Mirrors[].Hash' "${MOD_JSON_PATH}" )" || m_exit 1
    patcher_hash="$( jq -r '.Mirrors[].Hash' "${PATCHER_JSON_PATH}" | head -1 )" || m_exit 1
    patcher_eft="$( get_patcher_eft_version )" || m_exit 1
    
    # Check for cached mod archive
    if ! check_cached "${MOD_PATH}" "${mod_hash}"; then
        msg "Downloading mod archive..."
        m_curl -L "${mod_url}" -o "${MOD_PATH}"

        # Make sure the file is good to use
        check_hash "${MOD_PATH}" "${mod_hash}" \
        || err "Downloaded mod archive is corrupted"
    fi

    msg "Latest SPT release is \"${mod_version}\""

    # Check if we need to patch the game files
    msg "Comparing installed EFT <--> required EFT versions"
    if [[ "${installed_eft}" -ne "${mod_eft}" ]]; then
        msg "Incompatible EFT version found - Checking latest downpatcher"
        # Check if target EFT version is lower, greater or equal to required EFT version
        if [[ "${patcher_eft}" -lt "${installed_eft}" ]]; then
            # No patcher available yet!
            warn "Looks like there's no patcher available for your EFT version"
            msg
            msg "    > This usually happens when EFT has been updated recently."
            msg "    > Please wait for the SPT team to generate a new patcher."
            msg "    > Usually, this will take less then 24 hours."
            msg
            err "No patcher available"
            
        elif [[ "${patcher_eft}" -gt "${installed_eft}" ]]; then
            # EFT is outdated!
            warn "Looks like your installed EFT version is out-of-date"
            msg
            msg "    > Please update your live EFT installation & try again"
            msg
            err "EFT is out-of-date"

        elif [[ "${patcher_eft}" -eq "${installed_eft}" ]]; then
            # Downpatcher is compatible!
            msg "Patcher is compatible"

            # Check for cached patcher archive
            if ! check_cached "${PATCHER_PATH}" "${patcher_hash}"; then
                download_patcher
                check_hash "${PATCHER_PATH}" "${patcher_hash}" \
                || err "Downloaded patcher archive is corrupted"
            fi

            # Extract downpatcher to temp directory
            m_7z "${PATCHER_PATH}" "${TMP_DIR}/patcher"

            # Copy EFT files
            msg "Copying EFT game files..."
            m_cp "${EFT_DIR}/" "${SPT_DIR}"

            # Move patcher files to install directory
            msg "Moving patcher files to \"${SPT_DIR}\""
            find "${TMP_DIR}/patcher" -type d -name '*SPT_Patches*' -print0 | xargs -0 mv -t "${SPT_DIR}" \
            || err "Failed to move patcher files to SPT install directory" 

            # Patch game using downloaded patcher files
            opt_patch "${SPT_DIR}" || err "Something went wrong while patching game files"
        fi
    else
        msg "Installed EFT version is compatible with \"SPT ${mod_version}\""
        msg "Copying EFT game files..."
        m_cp "${EFT_DIR}/" "${SPT_DIR}"
    fi

    # Extract mod archive to install directory
    m_7z "${MOD_PATH}" "${SPT_DIR}"
}


install_spt_proton() {
    # Download SPT Installer
    if ! [[ -f "${CACHE_DIR}/SPTInstaller.exe" ]]; then
        msg "Downloading SPTInstaller.exe..."
        cd "${CACHE_DIR}" && m_curl -LO "${URL[spt-installer]}"
    fi

    # Run SPT Installer
    msg "Launching SPT Installer..."
    m_umu "${CACHE_DIR}/SPTInstaller.exe" installpath="C:\\SPTarkov" || err "Failed to launch SPT Installer"
}


install_launch_script() {
    # Server launch script
    local path="${SPT_DIR}/launch-server.sh"
    cat <<'EOF' > "${path}"
#!/bin/bash
root_path="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
terms=( "foot" "alacritty" "ptyxis" "kgx" "konsole"
"gnome-terminal" "xfce4-terminal" "kitty" "xterm" )
[[ $( pidof "SPT.Server.Linux" ) != "" ]] && exit 0
for term in "${terms[@]}"; do
    if command -v $term &>/dev/null; then
        cd "${root_path}"
        $term -e "./SPT.Server.Linux"
        break
    fi
done
EOF
    m_chmod +x "${path}"
}


uninstall_eft() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${BSG_DIR}" ]] && msg "EFT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        # Warn user before continuing
        msg "${BOLD}This action will uninstall \"Escape from Tarkov\" from your system!${RESET}"
        msg "Prefix directory: ${UNDERLINE}${CONFIG[pfx_dir]}${RESET}"
        ask "Do you want to continue?"
    fi

    msg "Uninstalling \"Escape from Tarkov\"..."
    m_rmdir "${BSG_DIR}"

    msg "Removing \"BSG Launcher\" shortcut..."
    app_path="${APP_DIR}/BSG - Launcher.desktop"
    [[ -f "${app_path}" ]] && m_rm "${app_path}"

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_spt() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${SPT_DIR}" ]] && msg "SPT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"SPTarkov\" from your system!${RESET}"
        msg "SPT directory: ${UNDERLINE}${SPT_DIR}${RESET}"
        ask "Do you want to continue?"
    fi

    msg "Uninstalling \"SPTarkov\"..."
    m_rmdir "${SPT_DIR}"

    msg "Removing \"SPTarkov\" shortcuts..."
    local apps=( "SPT - Launcher.desktop" "SPT - Server.desktop" )
    for app in "${apps[@]}"; do
        local app_path="${APP_DIR}/${app}"
        [[ -f "${app_path}" ]] && m_rm "${app_path}"
    done

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_prefix() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${CONFIG[pfx_dir]}" ]] && msg "Prefix directory does not exist" && return 0
    msg "Removing Prefix directory..."
    m_rmdir "${CONFIG[pfx_dir]}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


# # # # # # # # # # # #
#   Option functions  #
# # # # # # # # # # # #

opt_setprefix() {
    local path="${1%/}"

    # Check if it's valid
    check_prefix_path "$path"

    # Update WINEPREFIX environment variable
    export WINEPREFIX="${path}"

    # Update prefix config
    set_value config "pfx_dir=${path}"
    save_array config

    # Update prefix paths
    SPT_DIR="${CONFIG[pfx_dir]%/}/${CONFIG[spt_dir]%/}"
    BSG_DIR="${CONFIG[pfx_dir]%/}/drive_c/Battlestate Games"
    EFT_DIR="$( get_eft_path )"

    msg "Prefix path has been set to \"${CONFIG[pfx_dir]}\""
}


opt_setenv() {
    local key value
    local string="$1"
    key=$( echo "$string" | cut -d "=" -f1 )
    value=$( echo "$string" | cut -d "=" -f 2- )
    msg "Adding environment variable: \"$string\""
    set_value env "$key=$value"
    save_array env
    # Export to use in current session
    export_env
}


opt_setarg() {
    local arg="${1}"
    local args_string="${ARGS[*]}"
    case "$args_string" in
     *"$arg"*) ;;
     *)
        msg "Adding launch argument: \"$arg\""
        ARGS+=( "$arg" )
     ;;
    esac
}


opt_install() {
    # SYNTAX: spt-additions install spt -p ~/Games/sptarkov
    local option="$1" && shift
    local spt_install_mode="proton"

    while getopts ":p:e:a:m:-:" subopt; do
        case ${subopt} in
            p) set_value config "pfx_dir=${OPTARG}";;
            e) opt_setenv "${OPTARG}";;
            a) opt_setarg "${OPTARG}";;
            m)
                case "${OPTARG}" in
                    native|proton|lutris) spt_install_mode="${OPTARG}" ;;
                    *) err "Invalid option: ${OPTARG}" ;;
                esac
            ;;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done
    
    case "${option}" in
        eft|tarkov|bsg) install_eft ;;
        spt|sptarkov) install_spt "$spt_install_mode" ;;
        help|-h|--help) opt_help "install";;
        "") err "Option \"install\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_uninstall() {
    # SYNTAX: spt-additions uninstall spt -p ~/Games/sptarkov
    local option="$1" && shift

    while getopts ":p:-:" subopt; do
        case ${subopt} in
            p) opt_setprefix "${OPTARG}";;
            -*)
                case "${OPTARG}" in
                    no-prompt) export NO_PROMPT=1; msg "\"NO_PROMPT\" option set" ;;
                    *) err "Invalid option: --${OPTARG}" ;;
                esac
            ;;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done
    
    case "${option}" in
        eft) uninstall_eft ;;
        spt) uninstall_spt ;;
        all)
            # Ask for confirmation
            if ! [ "${NO_PROMPT}" = 1 ]; then
                msg "${BOLD}This action will remove the installed wine prefix!${RESET}"
                msg "The following directory will be deleted ${BOLD}permanently${RESET}:"
                msg "${UNDERLINE}${CONFIG[pfx_dir]}${RESET}"
                ask "Do you want to continue?"
            fi

            uninstall_eft 1
            uninstall_spt 1
            uninstall_prefix 1

            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        help|-h|--help) opt_help "uninstall";;
        "") err "Option \"uninstall\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_run() {
    # SYNTAX: spt-additions run spt-launcher -e "MANGOHUD=1"
    local option="$1" && shift

    while getopts ":p:e:a:-:" subopt; do
        case ${subopt} in
            p) set_value config "pfx_dir=${OPTARG}";;
            e) opt_setenv "${OPTARG}";;
            a) opt_setarg "${OPTARG}";;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done

    case "${option}" in
        eft|bsg|bsg-launcher)
            check_eft_running
            opt_setarg "--disable-software-rasterizer"
            opt_setprefix "${CONFIG[pfx_dir]}"
            cd "${BSG_DIR}/BsgLauncher" || m_exit 1
            m_umu "BsgLauncher.exe" "${ARGS[@]}" &
        ;;
        spt-launcher)
            check_eft_running
            opt_setprefix "${CONFIG[pfx_dir]}"
            cd "${SPT_DIR}" && m_umu SPT.Launcher.exe "${ARGS[@]}" &
        ;;
        spt-server)
            # check_dotnet
            check_eft_running
            opt_setprefix "${CONFIG[pfx_dir]}"
            cd "${SPT_DIR}" && "./launch-server.sh" "${ARGS[@]}" &
        ;;
        help|-h|--help) opt_help "run";;
        "") err "Option \"run\" requires an argument" ;;
        *)
            opt_setprefix "${CONFIG[pfx_dir]}"
            cd "${CONFIG[pfx_dir]}" && m_umu "${option}" "${ARGS[@]}" &
        ;;
    esac
}


opt_patch() {
    local progress_total
    local target_path="${1%/:-"${SPT_DIR}"}" 
    local source_path="${2%/:-"${SPT_DIR}"}" 
    msg "Started \"SPTarkov\" patcher..."
    # Fail if the target director does not exist
    [[ ! -d "${target_path}" ]] && err "Target directory \"${target_path}\" does not exist"
    # Make sure hpatchz is installed
    if ! command -v "hpatchz" &>/dev/null; then
        install_dep "hpatchz" "${URL[hpatchz]}" || err "Missing dependency \"hpatchz\". Please install it & try again"
    fi
    # Search in optional SOURCE directory
    if [ "$( find "$source_path" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        msg "Using \"SPT_Patches\" found in \"${source_path}\""
    # Search in TARGET directory
    elif [ "$( find "$target_path" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        msg "Using \"SPT_Patches\" found in \"${target_path}\""
        source_path="${target_path}"
    else
        # No "SPT_Patches" directory found
        err "Unable to locate \"SPT_Patches\" directory in \"${source_path}\""
    fi
    # Print debug strings
    msg "Source path: ${source_path}"
    msg "Target path: ${target_path}"
    
    local progress_start=1
    progress_total=$( find "$source_path/SPT_Patches" \( -type f -printf x \) | wc -c )

    find "$source_path/SPT_Patches" \( -type f \) -print0 | while IFS= read -r -d '' source; do 
        # progress_current
        local progress_current="[${progress_start}/${progress_total}]"
        # Isolate the operation extension
        local extension="${source##*.}"
        # Isolate sub-directories of SPT_Patches
        local formatted="${source#*SPT_Patches/}"
        # Remove operation extension to get actual file name
        formatted="${formatted%.*}"

        local output="${target_path}/${formatted}"
        local target="${output}.decoded"
        local dir_path="${output%/*}"

        case "$extension" in
            "delta")
                msg "${progress_current} (*) Patching: ${formatted##*/}"
                hpatchz "$output" "$source" "$target" 1>/dev/null || return 1

                # Remove old file and replace with .decoded file
                [[ ! -f "${target}" ]] && return 1
                m_rm "${output}" || return 1
                mv "${target}" "${output}" || return 1
            ;;
            "del")
                msg "${progress_current} (-) Deleting: ${formatted##*/}"
                m_rm "${output}" || return 1
                if [[ -z "$( ls -A "${dir_path}" )" ]]; then
                    msg "${progress_current} (-) Deleting directory: ${dir_path##*/}"
                    m_rmdir "${dir_path}" || return 1
                fi
            ;;
            "new")
                msg "${progress_current} (+) Adding: ${formatted##*/}"
                if [[ ! -d "${dir_path}" ]]; then
                    msg "${progress_current} (+) Adding directory: ${dir_path##*/}"
                    mkdir -p "${dir_path}"
                fi
                cp "${source}" "${output}" || return 1
            ;;
            *)
                return 1
            ;;
        esac
        progress_start=$((progress_start+1))
    done

    if [[ "$?" -ne "0" ]]; then
        # Failed patching
        m_rmdir "${SPT_DIR}"
        err "Patching failed"
    fi
    
    # Clean up patcher files
    if [[ "${target_path}" == *"${source_path}"* ]]; then
        msg "Cleaning up patcher files..."
        [[ -d "${source_path}/SPT_Patches" ]] && m_rmdir "${source_path}/SPT_Patches"
        [[ -f "${source_path}/patcher.exe" ]] && m_rmdir "${source_path}/patcher.exe"
    fi

    msg "Done patching game files!"
}


add_app_shortcut() {
    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "app-shortcut" ]] && err "Failed to load shortcut data from cache array"
    msg "Creating \"${CACHE[name]}\" shortcut..."
    # Get env string
    local env="$( get_env_string )"
    env+="WINEPREFIX=${CONFIG[pfx_dir]}"
    [[ "$env" != *"PROTONPATH"* ]] && env="$(echo "PROTONPATH=GE-Proton $env")"
    # Remove existing shortcut
    [[ -f "${CACHE[path]}" ]] && m_rm "${CACHE[path]}"
    # Generate the exec string
    local exec_string
    case "${CACHE[executable]}" in
        *exe*|*bat*|*msi*) exec_string="Exec=env $env $UMU_PATH \"${CACHE[executable]}\" ${ARGS[*]}" ;;
        *) exec_string="Exec=\"${CACHE[working_dir]}/${CACHE[executable]}\" ${ARGS[*]}" ;;
    esac
    # Write desktop file
    {   echo "[Desktop Entry]"
        echo "Categories=Game;ActionGame;Simulation"
        echo "Path=${CACHE[working_dir]}"
        echo "${exec_string}"
        echo "Name=${CACHE[name]}"
        echo "Icon=${CACHE[icon]}"
        echo "Type=Application"
    } > "${CACHE[path]}" && m_chmod +x "${CACHE[path]}"
}


add_faugus_shortcut() {
    # Check if faugus-launcher is installed
    if [[ ! "$(command -v "faugus-launcher")" ]]; then
        msg "Faugus-Launcher is not installed"
        return 0
    fi
    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "faugus-shortcut" ]] && err "Failed to load shortcut data from cache array"
    # Create Faugus config dir if not already there
    mkdir -p "$FAUGUS_CONFIG_DIR"
    # Create games.json if it doesn't exist
    [[ ! -f "$FAUGUS_JSON_PATH" ]] && jq -n '[]' > "$FAUGUS_JSON_PATH"
    # Check if the game ids already exist
    if [[ "$(cat "$FAUGUS_JSON_PATH" | grep "${CACHE[gameid]}")" ]]; then
        warn "A shortcut for \"${CACHE[title]}\" already exists, skipping"
        return 0
    fi
    # Add shortcut
    local prefix="${CONFIG[pfx_dir]}"
    local launch_args="$(get_env_string)"
    local game_args="${ARGS[*]}"
    local runner="GE-Proton"
    msg "Adding \"${CACHE[title]}\" to Faugus Launcher..."
    jq --arg gameid "${CACHE[gameid]}" --arg title "${CACHE[title]}" --arg path "${CACHE[path]}" \
    --arg prefix "$prefix" --arg launch_args "$launch_args" --arg game_args "$game_args" --arg runner "$runner" \
    '. += [{ "gameid": $gameid,"title": $title,"path": $path,"prefix": $prefix,
    "launch_arguments": $launch_args,"game_arguments": $game_args,"runner": $runner,
    "lossless_enabled": false,"lossless_performance": false,"lossless_hdr": false }]'\
    "$FAUGUS_JSON_PATH" > "$TMP_DIR/games.json"
    mv "$TMP_DIR/games.json" "$FAUGUS_JSON_PATH"
}


opt_shortcut() {
    # SYNTAX: spt-additions shortcut spt --launcher -p "" -e "" -a ""
    local name executable working_dir path icon
    local option="$1" && shift

    while getopts ":p:e:a:h:-:" subopt; do
        case ${subopt} in
            p) opt_setprefix "${OPTARG}";;
            e) opt_setenv "${OPTARG}";;
            a) opt_setarg "${OPTARG}";;
            h) opt_help "shortcut" ;;
            -*)
                case "${OPTARG}" in
                    "") err "Option \"${option}\" requires an argument" ;;
                    *) err "Invalid option: --${OPTARG}" ;;
                esac
            ;;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done
    
    case "${option}" in
        eft|bsg|bsg-launcher)
            opt_setarg "--disable-software-rasterizer"
            CACHE[_id]="app-shortcut"
            CACHE[name]="BSG - Launcher"
            CACHE[executable]="BsgLauncher.exe"
            CACHE[working_dir]="${BSG_DIR}/BsgLauncher"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="bsg_launcher"
            add_app_shortcut
        ;;
        spt-launcher)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Launcher"
            CACHE[executable]="SPT.Launcher.exe"
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_launcher"
            add_app_shortcut
        ;;
        spt-server)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Server"
            CACHE[executable]="launch-server.sh"
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_server"
            add_app_shortcut
        ;; 
        spt|sptarkov)
            opt_shortcut spt-launcher
            opt_shortcut spt-server
        ;;
        faugus)
            if [[ -d "$BSG_DIR" ]]; then
                # BSG - Launcher
                opt_setarg "--disable-software-rasterizer"
                CACHE[_id]="faugus-shortcut"
                CACHE[gameid]="bsg-launcher"
                CACHE[title]="BSG Launcher"
                CACHE[path]="$BSG_DIR/BsgLauncher.exe"
                add_faugus_shortcut
            fi
            if [[ -d "$SPT_DIR" ]]; then
                # SPT - Launcher
                CACHE[_id]="faugus-shortcut"
                CACHE[gameid]="spt-launcher"
                CACHE[title]="SPT Launcher"
                CACHE[path]="$SPT_DIR/SPT.Launcher.exe"
                add_faugus_shortcut
            fi
        ;;
        all)
            opt_shortcut bsg-launcher
            opt_shortcut spt-launcher
            opt_shortcut spt-server
        ;;
        help|-h|--help) opt_help "shortcut";;
        "") err "Option \"shortcut\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_clean() {
    # SYNTAX: spt-additions clean all --no-prompt
    local option="$1" && shift

    while getopts ":p:-:" subopt; do
        case ${subopt} in
            p) opt_setprefix "${OPTARG}";;
            -*)
                case "${OPTARG}" in
                    no-prompt) export NO_PROMPT=1; msg "\"NO_PROMPT\" option set" ;;
                    *) err "Invalid option: --${OPTARG}" ;;
                esac
            ;;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
    done

    case "${option}" in
        cache)
            msg "Removing Cache directory..."
            [[ -d "${CACHE_DIR}" ]] && m_rmdir "${CACHE_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        config)
            msg "Removing config directory..."
            [[ -d "${CONFIG_DIR}" ]] && m_rmdir "${CONFIG_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        data)
            msg "Removing data directory..."
            [[ -d "${DATA_DIR}" ]] && m_rmdir "${DATA_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        all)
            if [[ "${NO_PROMPT}" != 1 ]]; then
                # Warn user before continuing
                msg "${BOLD}This action will remove all configs, cached files & all game shortcuts!${RESET}"
                msg "The following directories will be deleted ${BOLD}permanently${RESET}:"
                msg "    > ${UNDERLINE}${DATA_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CACHE_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CONFIG_DIR}${RESET}"
                ask "Do you want to continue?"
            fi
            export NO_PROMPT=1
            opt_clean data
            opt_clean config
            opt_clean cache
            msg "${GREEN}Done!${RESET}"
        ;;
        help|-h|--help) opt_help "clean";;
        "") err "Option \"clean\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_selfupdate() {
    if [[ "${NO_PROMPT}" != 1 ]]; then
        msg "> The script will attempt to install the latest script from:"
        msg "> ${UNDERLINE}${URL[installer-script]}${RESET}"
        msg
        msg "> This feature is ${BOLD}NOT${RESET} fully implemented yet & won't validate the new script file!"
        msg
        ask "Do you want to continue?"
    fi
    msg "Updating script..."
    cd "${SCRIPT_PATH}" && m_curl -LO "${URL[installer-script]}"
    m_chmod +x "${SCRIPT_PATH}"
}


opt_help() {
    local option="${1}"
    case "${option}" in
        install)
            msg "${BOLD}Available options:${RESET}"
            msg "[eft|bsg|tarkov]               - Install the BSG Launcher"
            msg "[spt|sptarkov]                 - Install SPTarkov"
            msg
            msg "${BOLD}SPT Install modes:${RESET}"
            msg "native|proton"
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-m${RESET}              - Change SPT install mode (Default is \"proton\")"
            msg "${BOLD}-p${RESET}              - Set a custom prefix path (Default is \"~/Games/tarkov\")"
            msg "${BOLD}-e${RESET}              - Add/Update a environment variable"
            msg "${BOLD}-a${RESET}              - Add a custom launch argument"
            msg "${BOLD}-h|--help${RESET}       - Print the help message"
        ;;
        uninstall)
            msg "${BOLD}Available options:${RESET}"
            msg "eft|spt|all"
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-p${RESET}              - Set a custom path for the wine prefix"
            msg "${BOLD}--no-prompt${RESET}     - Disable interactive prompt messages"
            msg "${BOLD}-h|--help${RESET}       - Print the help message"
        ;;
        shortcut)
            msg "${BOLD}Available options:"
            msg "[eft|bsg|bsg-launcher]         - Update BSG-Launcher shortcut"
            msg "[spt|sptarkov]                 - Update SPT.Server and SPT.Launcher shortcut"
            msg "spt-launcher|spt-server        - Update SPT.Server or SPT.Launcher shortcut"
            msg "all                            - Update all shortcuts"
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-p${RESET}              - Set a custom path for the wine prefix"
            msg "${BOLD}-e${RESET}              - Add/Update a environment variable"
            msg "${BOLD}-a${RESET}              - Add a custom launch argument"
            msg "${BOLD}-h|--help${RESET}       - Print the help message"
        ;;
        run)
            msg "${BOLD}Available options:${RESET}"
            msg "[eft|bsg|bsg-launcher]         - Run the BSG Launcher"
            msg "spt-launcher                   - Run the SPT Launcher"
            msg "spt-server                     - Run the native SPT Server"
            msg "[*]                            - Run a custom command inside the prefix"
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-p${RESET}              - Set a custom path for the wine prefix"
            msg "${BOLD}-e${RESET}              - Add/Update a environment variable"
            msg "${BOLD}-a${RESET}              - Add a custom launch argument"
            msg "${BOLD}-h|--help${RESET}       - Print the help message"
        ;;
        patch)
            msg "Patch game files using hpatchz"
            msg 
            msg "${BOLD}Usage:${RESET}"
            msg "$TITLE patch [target dir][source dir]"
        ;;
        clean)
            msg "${BOLD}Available options:${RESET}"
            msg "cache|config|data|all"
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-p${RESET}              - Set a custom path for the wine prefix"
            msg "${BOLD}-h|--help${RESET}       - Print the help message"
        ;;
        "")
            msg "A Standalone EFT/SPT installer script using UMU-Launcher and Proton."
            msg
            msg "${BOLD}Example usage:${RESET}  ${YELLOW}spt-additions install eft -p ~/Games/tarkov${RESET}"
            msg "                ${YELLOW}spt-additions shortcut spt-launcher -e MANGOHUD=1${RESET}"
            msg
            msg "${BOLD}OPTIONS:${RESET}"
            msg "${BOLD}install${RESET}          - Install EFT/SPT into a prefix"
            msg "${BOLD}uninstall${RESET}        - Uninstall EFT/SPT from a prefix"
            msg "${BOLD}patch${RESET}            - Downpatch EFT game files"
            msg "${BOLD}shortcut${RESET}         - Create/update EFT/SPT shortcuts"
            msg "${BOLD}run${RESET}              - Run EFT/SPT from the terminal"
            msg "${BOLD}clean${RESET}            - Clean installer and prefix files"
            msg "${BOLD}--self-update${RESET}    - Updates this installer script"
            msg "${BOLD}--no-prompt${RESET}      - Disable interactive prompt messages"
            msg "${BOLD}-h | --help${RESET}      - Print the help message"
            msg "${BOLD}-v | --VERSION${RESET}   - Print the VERSION info message"
        ;;
        *) msg "Invalid option: ${option}. Available options: install|uninstall|shortcut|run|patch|clean" ;;
    esac
}


opt_version() {
    msg "${BOLD}Version: ${RESET}${VERSION} (${DATE})"
    msg "${BOLD}Author: ${RESET}${AUTHOR}"
    msg "${BOLD}License: ${RESET}${LICENSE}"
}


# # # # # # # # # # #
#  Entry functions  #
# # # # # # # # # # #

handle_opts() {
    local option="${1}" && shift

    # Install umu if needed
    case "$option" in
        install|run|patch)
            [[ ! -f "${UMU_PATH}" ]] && install_dep "umu-run" "${URL[umu-launcher]}"
        ;;
    esac

    case "$option" in
        install) opt_install "$@" ;;
        uninstall) opt_uninstall "$@" ;;
        run) opt_run "$@" ;;
        patch) opt_patch "$@" ;;
        shortcut) opt_shortcut "$@" ;;
        clean) opt_clean "$@" ;;
        self-update) opt_selfupdate ;;
        version) opt_version ;;
        help) opt_help "$@";;
        --*)
            case "$option" in
                --self-update) opt_selfupdate ;;
                --version) opt_version ;;
                --help) opt_help ;;
                *) err "Invalid option: ${option}" ;;
            esac
        ;;
        -*)
            case "$option" in
                -v) opt_version ;;
                -h) opt_help ;;
                *) err "Invalid option: ${option}" ;;
            esac
        ;;
        "") opt_help ;;
        *) err "Invalid option: ${option}" ;;
    esac
}


main() {
    # Remove tmp files
    if [[ -d "${TMP_DIR}" ]] && [[ -n $( ls "${TMP_DIR}" 2>/dev/null ) ]]; then
        m_rmdir "${TMP_DIR}/"
    fi

    # Set default config variables
    set_value config "pfx_dir=${DEFAULT_PFX_DIR}"
    set_value config "spt_dir=${DEFAULT_SPT_DIR}"

    # Set default environment variables
    set_value env "PROTON_USE_XALIA=0"
    set_value env "DOTNET_ROOT="
    set_value env "DOTNET_BUNDLE_EXTRACT_BASE_DIR="

    # Remove old log file
    [[ -f "${LOG_PATH}" ]] && m_rm "${LOG_PATH}"

    # Load config files
    [[ -f "${CONFIG_PATH}" ]] && load_array config
    [[ -f "${ENV_PATH}" ]] && load_array env

    # Set prefix paths
    check_prefix_path "${CONFIG[pfx_dir]}"
    check_spt_path "${CONFIG[spt_dir]}"
    SPT_DIR="${CONFIG[pfx_dir]%/}/${CONFIG[spt_dir]%/}"
    BSG_DIR="${CONFIG[pfx_dir]%/}/drive_c/Battlestate Games"
    EFT_DIR="$( get_eft_path )"

    # Export paths
    export PATH=$RUNTIME_DIR:$PATH

    # Export env vars from config
    export_env

    # HACK: Just for debugging purposes rn
    export WINEDEBUG="-all,err+all,fixme+all,debugstr+all"

    # Handle command line arguments
    handle_opts "$@"
}

# Main entry
main "$@"

m_exit 0
