#!/usr/bin/env bash

# # # # # # # # # 
# SPT-ADDITIONS #
# # # # # # # # # 

# TODO: Add zenity dialog boxes for guided game installs
# TODO: Think about launching EFT/SPT through the script to avoid updating shortcuts constantly

# exit codes:
# 1: general error | 10: -d check failed | 11: -f check failed | 12: empty string | 13: m_7z failed
# 14: case char mismatch

# We don't want to run as root
if [[ "$( id -u )" -eq 0 ]]; then
    echo "This script is not supposed to be run as root!"
    exit 1
fi

# Shell options
shopt -s extglob

# Make sure to throw an error and exit on SIGINT
trap int INT; int() { err "Interrupt received"; }

TITLE="spt-additions"
AUTHOR="MadByte"
LICENSE="MIT"
VERSION="0.6.0"
DATE="2025-09-14"

# ANSI codes
BOLD="\e[1m"; UNDERLINE="\e[2m"; RESET="\e[0m"
RED="\e[31m"; GREEN="\e[32m"; BLUE="\e[36m"
YELLOW="\e[33m"; GRAY="\e[90m"

# System directories
readonly DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
readonly CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly DATA_DIR="${DATA_HOME}/${TITLE}"
readonly RUNTIME_DIR="${DATA_DIR}/runtime"
readonly CACHE_DIR="${CACHE_HOME}/${TITLE}"
readonly CONFIG_DIR="${CONFIG_HOME}/${TITLE}"
readonly TMP_DIR="${CACHE_DIR}/tmp"
readonly ICO_DIR="${DATA_HOME}/icons/hicolor/256x256/apps"
readonly APP_DIR="${DATA_HOME}/applications"
readonly DEFAULT_PFX_DIR="${HOME}/Games/tarkov"
readonly DEFAULT_SPT_DIR="drive_c/SPTarkov"

declare -A FAUGUS
FAUGUS[config_dir]="$CONFIG_HOME/faugus-launcher"
FAUGUS[flatpak_config_dir]="$HOME/.var/app/io.github.Faugus.faugus-launcher/config/faugus-launcher"
FAUGUS[json_path]="${FAUGUS[config_dir]}/games.json"
FAUGUS[flatpak_json_path]="${FAUGUS[flatpak_config_dir]}/games.json"
readonly -A FAUGUS

# File path variables
readonly LOG_PATH="${CACHE_DIR}/installer.log"
readonly SCRIPT_PATH="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" && pwd )"
readonly UMU_PATH=$( command -v umu-run || echo "${RUNTIME_DIR}/umu-run" )
readonly CONFIG_PATH="${CONFIG_DIR}/prefix.conf"
readonly ENV_PATH="${CONFIG_DIR}/env.conf"
readonly MOD_PATH="${CACHE_DIR}/SPT"
readonly PATCHER_PATH="${CACHE_DIR}/patcher"
readonly MOD_JSON_PATH="${CACHE_DIR}/release.json"
readonly PATCHER_JSON_PATH="${CACHE_DIR}/mirrors.json"

# Default SPT install mode
INSTALL_MODE="native"

declare -A CONFIG
declare -A ENV
declare -a ARGS
declare -A CACHE

declare -A URL
# Libraries / Tools
URL[umu-launcher]="https://github.com/Open-Wine-Components/umu-launcher/releases/download/1.2.9/umu-launcher-1.2.9-zipapp.tar"
URL[hpatchz]="https://github.com/sisong/HDiffPatch/releases/download/v4.11.1/hdiffpatch_v4.11.1_bin_linux64.zip"
URL[jq]="https://github.com/jqlang/jq/releases/download/jq-1.8.1/jq-linux-amd64"
URL[xxd]="http://ftp.de.debian.org/debian/pool/main/v/vim/xxd_9.1.1230-2_amd64.deb"
# Installers
URL[bsg-launcher]="https://prod.escapefromtarkov.com/launcher/download"
URL[spt-installer]="https://ligma.waffle-lord.net/SPTInstaller.exe"
# Scripts
URL[installer-script]="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/refs/heads/SPTv4-dev/scripts/spt-additions"
# Icons
URL[bsg-launcher-ico]="https://cdn2.steamgriddb.com/icon/33686c2d8930be81c843ffb7d4312605/32/256x256.png"
URL[spt-launcher-ico]="https://cdn2.steamgriddb.com/icon_thumb/ddd4f86cd0f978e85155cfa6c9f94e0c.png"
URL[spt-server-ico]="https://cdn2.steamgriddb.com/icon_thumb/9f7431ea593b8e57401c08f40adc6e34.png"
# Metadata
URL[patcher-json]="https://slugma.waffle-lord.net/mirrors.json"
URL[mod-json]="https://spt-releases.modd.in/release.json"
# Links
URL[guide-repo]="https://github.com/MadByteDE/SPT-Linux-Guide"
URL[discord]="https://discord.com/invite/Xn9msqQZan"
URL[forge]="https://forge.sp-tarkov.com/"
readonly -A URL


# # # # # # # # # #
# Alias functions #
# # # # # # # # # #

m_exit() {
    local status=${1:-$?}

    # Remove tmp files
    if [[ -d "${TMP_DIR}" ]] && [[ -n $( m_ls "${TMP_DIR}" ) ]]; then
        m_rmdir "${TMP_DIR}/"
    fi

    # Exit with passed status code
    exit "${status}"
}


m_chmod() {
    chmod "$@" &>> "${LOG_PATH}" || err "Command \"chmod $*\" failed (status code $?)"
}


m_cp() {
    local source_path="${1}"; local target_path="${2}"
    # Check exists
    [[ ! -d "${source_path}" ]] && err "Source \"${source_path}\" does not exist"
    # Check if the target path is inside a valid directory
    case "${target_path}" in
        *"${CONFIG[pfx_dir]}"* | *"${CACHE_DIR}"*) ;;
        *) err "Invalid target directory \"${target_path}\"" ;;
    esac
    # Create missing directories
    mkdir -p "${target_path}"
    # Copy files to target path
    if [[ -n "$( m_ls -A "${source_path}" )" ]]; then
        cp --reflink=auto -r "${source_path}"* "${target_path}" \
        || err "Command \"cp $*\" failed (status code $?)"
    fi
}


m_ls() {
    ls "$@" 2>/dev/null || err "Command \"ls $*\" failed (status code $?)"
}


m_rm() {
    local path="$(realpath -m "${1%/}")"
    if [[ -d "${path}" ]]; then
        err "Cannot remove directories. Use \"m_rmdir\" instead."
    fi
    rm "$1" || err "Command \"rm $*\" failed (status code $?)"
}


m_rmdir() {
    local path="$(realpath -m "${1%/}")"
    if [[ -f "${path}" ]]; then
        warn "Cannot remove single files. Use \"m_rm\" instead."
        exit 1
    fi
    case "$path" in
        ""|"${HOME%/}"|"${CONFIG_HOME%/}"|"${CACHE_HOME%/}"|"${DATA_HOME%/}")
            warn "Directory \"${path}\" cannot be removed"
            exit 1
        ;;
        *) rm -r "$1" || exit 1 ;;
    esac
}


m_7z() {
    local archive_path="$(realpath -m "${1%/}")"; local target_path="$(realpath -m "${2%/}")"
    filename="${archive_path##*/}"
    # Extract
    msg "Extracting \"${filename}\""
    7z x -aoa "${archive_path}" -o"${target_path}" 1>/dev/null; status=$?
    [[ "$status" != 0 ]] && err "Failed to extract \"${filename}\" (status code $status)"
}


m_curl() {
    curl --connect-timeout 30 -f "$@" || err "Command \"curl $*\" failed (status code $?)"
}


m_umu() {
    case $1 in
        -q) shift; "${UMU_PATH}" "$@" &>> "${LOG_PATH}" || err "Command \"umu-run $*\" failed (status code $?)";;
        *) "${UMU_PATH}" "$@" || err "Command \"umu-run $*\" failed (status code $?)";;
    esac
}


m_winetricks() {
    local verb="${1}"; local name="${2}"; local args="${3}"
    # Skip if dependency is already installed
    if ! cat "${CONFIG[pfx_dir]}/winetricks.log" 2>/dev/null | grep -q "${verb}"; then
        msg "${name}..."
        m_umu -q winetricks -q $verb $args
    fi
}


# # # # # # # # # # #
# Helper functions  #
# # # # # # # # # # #

msg() {
    local filtered_str
    local output="${GRAY}[$TITLE]${RESET} ${*}"
    filtered_str=$( echo -e "${output}" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' )

    # Print to terminal
    case ${NO_ANSI} in
        1) echo "${filtered_str}" ;;
        *) echo -e "${output}" ;;
    esac
    
    # Write to log file
    if [[ -d "${CACHE_DIR}" ]]; then
        echo "${filtered_str}" &>> "${LOG_PATH}"
    fi
}


warn() {
    local pfx="${BLUE}Warn ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}$1"
}


err() {
    local message="$1"; local status="${2:-"1"}"
    local pfx="${BOLD}${RED}ERROR ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}${message}"
    msg "${pfx}See \"${LOG_PATH}\" for more details.${RESET}"
    m_exit "$status"
}


dbg() {
    local pfx="${GRAY}DEBUG ${FUNCNAME[1]}: ${RESET}"
    msg "${pfx}$1"
}


yesno() {
    printf "${GRAY}[${TITLE}]${RESET} $* [y/n] "
    while true; do
        read -r -p "> " yn
        case $yn in
            [Yy]*) return 0 ;;  
            [Nn]*) return 1 ;;
        esac
    done
}


read_input() {
    local input
    read -r -p "> " input
    printf "$input\n"
}


choice() {
    PS3="$1" && shift
    select answer in "$@"; do
        case $REPLY in
            1|2|3|4|5|6|7|8|9)
                if [[ $# -ge $REPLY ]]; then
                    echo "$REPLY" && break
                fi
            ;;
        esac
    done
}


wrap_run() {
    # Useful when wrapped code has exit calls but should continue
    # & just return the error code instead
    local out status
    out="$( "$@" )"; status=$?
    printf "%s\n" "${out}"
    return $status
}


set_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key value
    key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"
    # Filter for invalid keys/values
    [[ -z "${key}" ]] && err "Missing key for array \"${array_name}\""
    [[ ! "${key}" =~ ^[A-Za-z0-9_] ]] && err "Key contains invalid characters: \"${key}\""
    [[ -n "${value}" ]] && [[ ! "${value}" =~ ^[A-Za-z0-9/_=] ]] && err "Value contains invalid characters: \"${value}\""
    # Set value
    case "${array_name}" in
        config)
            [[ -z "${value}" ]] && err "Missing value for array \"${array_name}\""
            CONFIG[$key]="${value%/}"
            save_array config
        ;;
        env)
            ENV[$key]="${value%/}"
            export "${key}=${value%/}"
            save_array env  
        ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


unset_value() {
    local array_name="${1}"
    local keyval="${2}" || err "Missing argument: set_value [array_name] [keyval]"
    local key value
    key="$( echo "${keyval}" | cut -d '=' -f 1 )"
    value="$( echo "${keyval//["\""]}" | cut -d '=' -f 2- )"
    # Filter for invalid keys
    [[ -z "$key" ]] && err "Missing key: \"${array_name}\""
    # Unset key
    case "${array_name}" in
        config) unset CONFIG[$key]; save_array config ;;
        env) unset ENV[$key]; unset "${key}"; save_array env ;;
        *) err "Invalid array name: \"${array_name}\""
    esac
}


load_array() {
    local path
    local array_name="${1}" || err "Missing argument: load_array [array_name]"
    case "${array_name}" in
        config) path="${CONFIG_PATH}" ;;
        env) path="${ENV_PATH}" ;;
        *) err "Invalid argument \"${array_name}\"";;
    esac
    # Warn if the file does not exist
    if [[ ! -f "$path" ]]; then
        warn "Failed to load \"${path}\": File does not exist" && return
    fi
    # Read lines & load values
    while read -r line; do
        case "${line}" in
            *=*) set_value "${array_name}" "${line}" ;;
            *) err "Cannot load setting \"${line}\": Invalid format" ;;
        esac
    done < "$path"
}


save_array() {
    local array_name="${1}" || err "Missing argument: \"array_name\""
    case "${array_name}" in
        config)
            [[ -f "${CONFIG_PATH}" ]] && m_rm "${CONFIG_PATH}"
            for key in "${!CONFIG[@]}"; do
                echo "${key}=\"${CONFIG[$key]}\"" >> "${CONFIG_PATH}"\
                || err "Failed to write \"${CONFIG_PATH}\""
            done
        ;;
        env)
            [[ -f "${ENV_PATH}" ]] && m_rm "${ENV_PATH}"
            for key in "${!ENV[@]}"; do
                echo "${key}=\"${ENV[$key]}\"" >> "${ENV_PATH}"\
                || err "Failed to write \"${ENV_PATH}\""
            done
        ;;
        *) ;;
    esac
}


set_prefix() {
    local path="$(realpath -m "${1%/}")"

    # Check if it's valid
    check_prefix_path "${path}"

    # Update WINEPREFIX environment variable
    export WINEPREFIX="${path}"

    # Update prefix config
    set_value config "pfx_dir=${path}"

    # Update prefix paths
    SPT_DIR="${CONFIG[pfx_dir]%/}/${CONFIG[spt_dir]%/}"
    BSG_DIR="${CONFIG[pfx_dir]%/}/drive_c/Battlestate Games"
    EFT_DIR="$( get_eft_path )"

    msg "Prefix path has been set to \"${CONFIG[pfx_dir]}\""
}


set_arg() {
    local arg="${1}"
    local args_string="${ARGS[*]}"
    case "$args_string" in
     *"${arg}"*) ;;
     *)
        msg "Adding launch argument: \"${arg}\""
        ARGS+=( "${arg}" )
     ;;
    esac
}


get_env_string() {
    for key in "${!ENV[@]}"; do
        local var="${key}=${ENV[$key]} "
        env+="${var}"
    done
    printf "%s\n" "${env}"
}


# # # # # # # # # # # # #
# EFT Helper functions  #
# # # # # # # # # # # # #

get_eft_path() {
    local entry path
    [[ ! -d "${CONFIG[pfx_dir]}" ]] && exit 10
    [[ ! -f "${CONFIG[pfx_dir]}/system.reg" ]] && exit 11
    # get windows formatted path
    entry=$( sed -n '/Uninstall\\\\EscapeFromTarkov/,/^$/p' "${CONFIG[pfx_dir]}/system.reg" )
    path=$( echo "${entry}" | grep -o "\"InstallLocation\"=\"[^}]*" | cut -d "\"" -f4 2>/dev/null )
    [[ -z "${path}" ]] && exit 12
    # Replace backslashes with slashes
    path="${path//\\\\/\/}"
    # Finally assemble the full path & return it
    printf "%s/%s\n" "${CONFIG[pfx_dir]}" "${path//C:/drive_c}"
}


get_eft_version() {
    local version
    [[ ! -d "${EFT_DIR}" ]] && exit 10
    # Check if main exe exists
    local path="${EFT_DIR}/EscapeFromTarkov.exe"
    [[ ! -f "${path}" ]] \
    && err "File \"${path}\" does not exist"
    # Extract metadata
    m_7z "${path}" "${TMP_DIR}" 1>/dev/null
    # Get the EFT version from the version.txt file
    version=$( cat "${TMP_DIR}/.rsrc/0/version.txt" | head -1 | tr -d '\0\r' | cut -d "," -f4 2>/dev/null )
    [[ -z "${version}" ]] && exit 12
    printf "%s\n" "${version}"
}


# # # # # # # # # # # # # # #
# Patcher Helper functions  #
# # # # # # # # # # # # # # #

get_patcher_urls() {
    local urls
    local json_path="${1:-"${PATCHER_JSON_PATH}"}"
    local index="${2}"
    urls=$( cat "${json_path}" | jq -r '.Mirrors[].Link' )
    [[ -z "${urls}" ]] && exit 12
    # Return a specific url
    if [[ -n "${index}" ]]; then
        echo "${urls}" | sed "${index}q;d" 2>/dev/null
        return 0
    fi
    # Return the full list
    printf "%s\n" "${urls}"
}


get_patcher_eft_version() {
    local url filename version
    local json_path="${1:-"${PATCHER_JSON_PATH}"}"
    url=$( get_patcher_urls "${json_path}" 1 ) || exit 1
    # Split filename to get version infos from it
    filename=$( echo "${url##*/}" | tr "_." " " )
    # get target EFT version
    version=$( echo "${filename}" | cut -d " " -f5 )
    # Check returned value
    case "${version}" in
        ""|*[!0-9]*) exit 14 ;;
        *) printf "%s\n" "${version}" ;;
    esac
}


# # # # # # # # # # #
#  Check functions  #
# # # # # # # # # # #

check_disk_space() {
    local path=${1:-"${CONFIG[pfx_dir]}"}
    [[ -z "${path}" ]] && err "Missing path argument"
    # Get required values
    local free_kb eft_kb free_gb total_gb
    free_kb=$( df -k "${path}" | tail -1 | awk '{print $4}' )
    eft_kb=$( du -cs "${EFT_DIR}" | head -1 | cut -d$'\t' -f1 )
    local overhead_kb=$((1024*1024*10))
    local total_kb=$((eft_kb + overhead_kb))
    free_gb=$( echo "${free_kb}" | awk '{ free = $1/1024/1024 ; printf("%.2fGiB\n", free) }' )
    total_gb=$( echo "${total_kb}" | awk '{ total = $1/1024/1024 ; printf("%.2fGiB\n", total) }' )
    # Check if there's enough space
    [[ $free_kb -le $total_kb ]] && err "Not enough free disk space! (${free_gb} free < ${total_gb} needed)"
    msg "Enough free disk space available! (${free_gb} free > ${total_gb} needed)"
}


check_prefix_path() {
    local status=0 path
    local pfx_path="$(realpath -m "${1%/}")"
    local check_paths=("${pfx_path}/system.reg" "${pfx_path}/dosdevices" "${pfx_path}/drive_c")
    while true; do
        [[ "${pfx_path:0:1}" != "/" ]] && status=1 && break
        [[ -f "${pfx_path}" ]] && status=2 && break
        [[ ! -w "$(dirname "${pfx_path}")" ]] && status=3 && break
        if [[ -d "${pfx_path}" ]] && [[ -n "$( m_ls -A "${pfx_path}" )" ]]; then
            for path in "${check_paths[@]}"; do
                [[ ! -f "${path}" ]] && [[ ! -d "${path}" ]] && status=4 && break
            done
        fi
        break
    done
    if [[ $status != 0 ]]; then
        # Reset to default path
        set_value config "pfx_dir=${DEFAULT_PFX_DIR}"
        case $status in
            1) err "Missing leading \"/\" character: \"${pfx_path}\"" ;;
            2) err "Given path is a file: \"${pfx_path}\"" ;;
            3) err "No write permission for directory: \"${pfx_path}\"" ;;
            4) err "Given path is not a valid wine prefix: \"${pfx_path}\"" ;;
        esac
    fi
}


check_spt_path() {
    local spt_path="${1%/}"
    if [[ "$spt_path" != *"drive_c"* ]]; then
        # Reset to default path
        set_value config "spt_dir=${DEFAULT_SPT_DIR}"
        err "Invalid spt path: \"${spt_path}\""
    fi
}


check_faugus() {
    # Check if faugus-launcher is installed
    if command -v "faugus-launcher" &>/dev/null; then
        # Native
        config_dir="${FAUGUS[config_dir]}"
        json_path="${FAUGUS[json_path]}"
    elif flatpak list | grep -q faugus-launcher &>/dev/null; then
        # Flatpak
        config_dir="${FAUGUS[flatpak_config_dir]}"
        json_path="${FAUGUS[flatpak_json_path]}"
    else
        return 1
    fi
}


check_dotnet() {
    local status
    # Check for .NET Core and ASP.NET Runtime
    if ! dotnet --list-runtimes | grep "AspNet" | grep "9.0" &>/dev/null; then
        msg "${YELLOW}> \"ASP.NET Runtime 9.0\" is not installed on your system${RESET}"
        status=1
    fi
    if [ "$status" = 1 ]; then
        msg "${YELLOW}> Please install all missing dependencies & try again.${RESET}"
        err "Missing dependencies"
    fi
}


check_native_deps() {
    local status
    local cmds=( "7z" "xxd" "hpatchz" "jq" )
    msg "Checking for native dependencies..."
    # Check each cmd and error out if something is missing
    for cmd in "${cmds[@]}"; do
        if ! command -v "${cmd}" &> /dev/null; then
            case ${cmd} in
                jq|hpatchz|xxd) wrap_run install_dep "${cmd}" "${URL[${cmd}]}" || status=1 ;;
                7z) msg "\"${cmd}\" is not installed on your system." && status=1 ;;
                mangohud) msg "${BLUE}HINT${RESET}: \"${cmd}\" is not installed on your system." ;;
                gamemode) msg "${BLUE}HINT${RESET}: \"${cmd}\" is not installed on your system." ;;
            esac
        fi
    done
    if [ "$status" = 1 ]; then
        err "Please install all missing dependencies & try again."
    fi
}


check_eft_running() {
    local apps=( "BsgLauncher.exe" "EscapeFromTarko" )
    for app in "${apps[@]}"; do
        if [[ -n $( pidof "${app}" ) ]]; then
            err "\"${app}\" is currently running! Please close it to continue."
        fi
    done
}


check_hash() {
    local file_hash
    local file_path="$(realpath -m "${1%/}")"; local expected_hash="${2}"
    # Check arguments
    [[ ! -f "${file_path}" ]] && err "File \"${file_path}\" does not exist"
    [[ -z "${expected_hash}" ]] && err "Missing \"expected_hash\" argument"
    # use file to calculate MD5 hash and ENCODE in base64
    msg "Calculating checksum of file \"${file_path##*/}\""
    file_hash=$( md5sum "${file_path}" | cut -d ' ' -f 1 | xxd -r -p | base64 2>/dev/null )
    [[ -z "${file_hash}" ]] && err "Failed to calculate hash"
    # dbg "File hash: ${file_hash} Expected hash: ${expected_hash}"
    # Compare
    if [[ "${file_hash}" != "${expected_hash}" ]]; then
        warn "Hash check mismatch (File: \"${file_hash}\" != Expected: \"${expected_hash}\")"
        return 1
    fi
    msg "Hash check successful"
}


check_cached() {
    local cached_path="$(realpath -m "${1%/}")"; [[ -z "${cached_path}" ]] && err "Missing cached path argument"
    local expected_hash="${2}"; [[ -z "${expected_hash}" ]] && err "Missing expected hash argument"
    # Make sure the path actually is in CACHE_PATH
    [[ "$cached_path" == *"${CACHE_DIR}"* ]] \
    || err "Given file isn't inside the scripts cache directory"
    # Verify the file is there and valid
    local filename=${cached_path##*/}
    msg "Checking for cached file \"${filename}\""
    if [[ -f "${cached_path}" ]]; then
        msg "Found \"${filename}\" in cache directory"
        # Check hash
        if ! check_hash "${cached_path}" "${expected_hash}"; then
            msg "Removing cached file \"${filename}\""
            m_rm "${cached_path}"
            return 1
        else
            return 0
        fi
    else
        msg "\"${cached_path}\" is not cached"
        return 1
    fi
}


check_ttl() {
    local c_time m_time e_time
    local file_path="$(realpath -m "${1%/}")"
    # Check if file exists, if not - fail the check
    [[ ! -f "${file_path}" ]] && msg "File \"${file_path}\" does not exist" && return 1
    # Calculate time elapsed since last modified
    local ttl="${2:-"3600"}" 
    c_time=$( date +%s )
    m_time=$( date -r "${file_path}" +%s )
    ((e_time = c_time - m_time))
    # If elapsed time >= TTL - fail the check
    if [[ $e_time -ge $ttl ]]; then
        warn "File \"${file_path}\" is out of date"
        return 1
    fi
}


# # # # # # # # # # # # #
#  Installer functions  #
# # # # # # # # # # # # #

install_dep() {
    local cmd_name="$1"; local url="$2"
    local source_path="${3:-$TMP_DIR}"; local target_path="${4:-$RUNTIME_DIR}"
    local download_name="${url##*/}"
    [[ "$download_name" = *"."* ]] && local file_ext=".${download_name##*.}"
    local file_name="${cmd_name}${file_ext}"
    cd "${TMP_DIR}" || err "Failed to change directory to \"$TMP_DIR\""
    # Download
    msg "Downloading \"${cmd_name}\"..."
    m_curl -L "${url}" -o "${file_name}"
    # Extract archive if needed
    case "${file_ext}" in
        *.zip*|*.7z*) m_7z "${file_name}" "${TMP_DIR}" ;;
        *.tar*|*.zst*) tar -xf "${file_name}" || err "Failed to extract tar archive" ;;
        *.deb*)
            m_7z "${file_name}" "${TMP_DIR}"
            tar -xf "data.tar" || err "Failed to extract tar archive"
        ;;
        *) ;;
    esac
    local file_path=$( find "${source_path}" \( -name "${cmd_name}" -type f \) | head -1 )
    [[ -z "${file_path}" ]] && err "Cannot find \"${cmd_name}\" in \"${source_path}\""
    # Change permissions
    chmod +x "${file_path}" || err "Failed to set permissions for \"${cmd_name}\""
    # Move to target directory
    mv -f "${file_path}" "$target_path/${cmd_name}" || err "Failed to move \"${cmd_name}\" into \"${target_path}\""
    msg "Installed \"${cmd_name}\" successfully"
}


install_eft() {
    msg "Starting \"Escape from Tarkov\" setup..."

    # HACK: make sure to use UMU-Proton for dotnet48
    export PROTONPATH="UMU-Latest"

    # Initialize prefix
    msg "Initializing wine prefix..."
    m_umu -q wineboot -u || err "Failed to initialize wine prefix"

    # Install game dependencies
    m_winetricks "dotnet48" "Installing .NET 4.8 Runtime (this might take a while)"
    m_winetricks "vcrun2022" "Installing Microsoft Visual C++ 2015-2022 Redistributable"

    # Add prefix update pop-up workaround
    msg "Adding window pop-up workaround..."
    m_umu -q reg add "HKLM\\Software\\Microsoft\\.NETFramework" /v "OnlyUseLatestCLR" /t "REG_DWORD" /d 0001 /f

    # Add mouse focus workaround
    msg "Adding mouse focus workaround to registry..."
    m_umu -q reg add "HKCU\\Software\\Wine\\X11 Driver" /v "UseTakeFocus" /t "REG_SZ" /d "N" /f
    
    # Download BSG Launcher if needed
    if [[ ! -f "${CACHE_DIR}/BsgLauncher.exe" ]]; then
        msg "Downloading BSG Launcher..."
        cd "${CACHE_DIR}" && m_curl -L "${URL[bsg-launcher]}" -o "BsgLauncher.exe"
    fi

    # Install BSG Launcher
    msg "Installing BSG Launcher..."
    m_umu -q "${CACHE_DIR}/BsgLauncher.exe" /VERYSILENT

    # Re-initialize prefix for GE-Proton
    export PROTONPATH="GE-Proton"
    msg "Updating wine prefix for \"${PROTONPATH}\"..."
    m_umu -q wineboot -u

    # Copy icon to user icons directory
    if [[ ! -f "${ICO_DIR}/bsg_launcher.png" ]]; then
        msg "Getting app icon from SteamGridDB..."
        cd "${ICO_DIR}" && m_curl -L "${URL[bsg-launcher-ico]}" -o "bsg_launcher.png"
    fi

    # Create application shortcut
    opt_shortcut bsg-launcher

    msg "${GREEN}Done! ※\(^o^)/※${RESET}"
}


install_spt() {
    local install_mode="${1:-"proton"}"
    
    msg "Starting \"SPTarkov\" setup..."
    msg "Install mode is \"${install_mode}\"..."

    check_eft_running

    # Check for dotnet / aspnet dependencies (for SPT 4.x)
    # check_dotnet

    if [[ ! -d "${EFT_DIR}" ]]; then
        msg "> ${YELLOW}Escape from Tarkov is not installed.${RESET}"
        msg "> ${YELLOW}make sure to install the game inside the BSG Launcher & try again!${RESET}"
        err "Escape from Tarkov not found."
    elif [[ -d "${SPT_DIR}" ]]; then
        msg "> ${YELLOW}SPTarkov directory already exists.${RESET}"
        msg "> ${YELLOW}If you want to reinstall, make sure to remove the old installation first!${RESET}"
        err "SPTarkov directory already exists."
    fi
    
    # Install dependencies
    m_winetricks "dotnetdesktop8" "Installing .NET Desktop 8 Runtime"
    m_winetricks "dotnetdesktop9" "Installing .NET Desktop 9 Runtime"

    # Add DLL overrides
    msg "Adding DLL overrides to registry..."
    m_umu -q reg add "HKCU\\Software\\Wine\\DllOverrides" /v "winhttp" /t "REG_SZ" /d "native,builtin" /f

    # Install SPT
    case "$install_mode" in
        native|faugus) install_spt_native ;;
        lutris)
            # Add prefix update pop-up workaround
            msg "Adding window pop-up workaround..."
            m_umu -q reg add "HKLM\\Software\\Microsoft\\.NETFramework" /v "OnlyUseLatestCLR" /t "REG_DWORD" /d 0001 /f
            # Install SPT
            install_spt_native
        ;;
        proton)
            # HACK: The SPTInstaller needs GE-Proton instead of UMU-Latest
            export PROTONPATH="GE-Proton"
            # Download SPT Installer
            if ! [[ -f "${CACHE_DIR}/SPTInstaller.exe" ]]; then
                msg "Downloading SPTInstaller.exe..."
                cd "${CACHE_DIR}" && m_curl -LO "${URL[spt-installer]}"
            fi
            # Symlink SPTInstaller cache directory to our cache directory
            local appdata_dir="${CONFIG[pfx_dir]}/drive_c/users/steamuser/Application Data/spt-installer"
            local installer_cache_dir="${appdata_dir}/cache"
            if [[ -d "${installer_cache_dir}" ]]; then
                [[ $(readlink "${installer_cache_dir}") != "${CACHE_DIR}" ]] && m_rmdir "${installer_cache_dir}"
            fi
            [[ ! -d "${installer_cache_dir}" ]] && mkdir -p "${appdata_dir}"
            ln -s "${CACHE_DIR}" "${installer_cache_dir}"
            # Run SPT Installer
            msg "Launching SPT Installer..."
            m_umu -q "${CACHE_DIR}/SPTInstaller.exe" installpath="C:\\SPTarkov" || err "Failed to launch SPT Installer"
        ;;
        ""|*) err "Invalid install mode \"${install_mode}\""
    esac

    # Install server launch script
    install_launch_script

    case "${install_mode}" in
        native|proton)
            # Copy icon to user icons directory
            if [[ ! -f "${ICO_DIR}/spt_launcher.png" ]] || [[ ! -f "${ICO_DIR}/spt_server.png" ]]; then
                msg "Getting app icons from SteamGridDB..."
                cd "${ICO_DIR}" && m_curl -L "${URL[spt-launcher-ico]}" -o "spt_launcher.png"
                cd "${ICO_DIR}" && m_curl -L "${URL[spt-server-ico]}" -o "spt_server.png"
            fi
            # Create application shortcuts
            opt_shortcut spt
        ;;
        faugus) opt_shortcut faugus ;;
        lutris) ;;
        ""|*) err "Invalid install mode \"${install_mode}\""
    esac

    msg "${GREEN}Done! ※\(^o^)/※${RESET}"
}


install_spt_native() {
    # Pre-Checks
    check_native_deps
    check_disk_space

    # Get required metadata for mod and patcher releases
    check_ttl "${MOD_JSON_PATH}" || m_curl -L "${URL[mod-json]}" -o "${MOD_JSON_PATH}"
    check_ttl "${PATCHER_JSON_PATH}" || m_curl -L "${URL[patcher-json]}" -o "${PATCHER_JSON_PATH}"

    # Fetch some juicy data
    local installed_eft patcher_eft mod_eft mod_version
    local mod_url mod_hash patcher_hash
    installed_eft=$( get_eft_version ) || m_exit 1
    mod_eft="$( jq -r '.ClientVersion' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_version="$( jq -r '.AkiVersion' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_url="$( jq -r '.Mirrors[].DownloadUrl' "${MOD_JSON_PATH}" )" || m_exit 1
    mod_hash="$( jq -r '.Mirrors[].Hash' "${MOD_JSON_PATH}" )" || m_exit 1
    patcher_hash="$( jq -r '.Mirrors[].Hash' "${PATCHER_JSON_PATH}" | head -1 )" || m_exit 1
    patcher_eft="$( get_patcher_eft_version )" || m_exit 1
    
    # Check for cached mod archive
    if ! check_cached "${MOD_PATH}" "${mod_hash}"; then
        msg "Downloading mod archive..."
        m_curl -L "${mod_url}" -o "${MOD_PATH}"

        # Make sure the file is good to use
        check_hash "${MOD_PATH}" "${mod_hash}" \
        || err "Downloaded mod archive is corrupted"
    fi

    msg "Latest SPT release is \"${mod_version}\""

    # Check if we need to patch the game files
    msg "Comparing installed EFT <--> required EFT versions"
    if [[ "${installed_eft}" -ne "${mod_eft}" ]]; then
        msg "Incompatible EFT version found - Checking latest downpatcher"
        # Check if target EFT version is lower, greater or equal to required EFT version
        if [[ "${patcher_eft}" -lt "${installed_eft}" ]]; then
            # No patcher available yet!
            warn "Looks like there's no patcher available for your EFT version"
            msg
            msg "    > This usually happens when EFT has been updated recently."
            msg "    > Please wait for the SPT team to generate a new patcher."
            msg "    > Usually, this will take less then 24 hours."
            msg
            err "No patcher available"
            
        elif [[ "${patcher_eft}" -gt "${installed_eft}" ]]; then
            # EFT is outdated!
            warn "Looks like your installed EFT version is out-of-date"
            msg
            msg "    > Please update your live EFT installation & try again"
            msg
            err "EFT is out-of-date"

        elif [[ "${patcher_eft}" -eq "${installed_eft}" ]]; then
            # Downpatcher is compatible!
            msg "Patcher is compatible"

            # Check for cached patcher archive
            if ! check_cached "${PATCHER_PATH}" "${patcher_hash}"; then
                # Set global variable for patcher mirror urls
                local urls
                urls=$( get_patcher_urls ) || err "Failed to get patcher mirrors"
                # Try to download from first to last
                echo "${urls}" | while read -r url; do
                    msg "Downloading \"${url}\"..."
                    m_curl -L "${url}" -o "${PATCHER_PATH}" && break
                done
                # Check archive
                check_hash "${PATCHER_PATH}" "${patcher_hash}" \
                || err "Downloaded patcher archive is corrupted"
            fi

            # Extract downpatcher to temp directory
            m_7z "${PATCHER_PATH}" "${TMP_DIR}/patcher"

            # Copy EFT files
            msg "Copying EFT game files..."
            m_cp "${EFT_DIR}/" "${SPT_DIR}"

            # Move patcher files to install directory
            msg "Moving patcher files to \"${SPT_DIR}\""
            find "${TMP_DIR}/patcher" -type d -name '*SPT_Patches*' -print0 | xargs -0 mv -t "${SPT_DIR}" \
            || err "Failed to move patcher files to SPT install directory" 

            # Patch game using downloaded patcher files
            opt_patch "${SPT_DIR}" || err "Something went wrong while patching game files"
        fi
    else
        msg "Installed EFT version is compatible with \"SPT ${mod_version}\""
        msg "Copying EFT game files..."
        m_cp "${EFT_DIR}/" "${SPT_DIR}"
    fi

    # Extract mod archive to install directory
    m_7z "${MOD_PATH}" "${SPT_DIR}"
}


install_launch_script() {
    # Server launch script
    local path="${SPT_DIR}/launch-server.sh"
    cat <<'EOF' > "${path}"
#!/usr/bin/env bash
root_path="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
terms=( "foot" "alacritty" "ptyxis" "kgx" "konsole"
"gnome-terminal" "xfce4-terminal" "kitty" "xterm" )
# NOTE: When Flatpak Lutris is used, we don't have access to `dotnet-runtime` and
# `aspnet-runtime` packages on the host system. To work around this limitation,
# we use `flatpak-spawn --host` to launch the server outside of the sandboxed
# environment. (not supported with some desktop portals in Wayland e.g. cinnemon/xapp)
m_run() {
    if [[ -z "${FLATPAK_SANDBOX_DIR}" ]]; then "$@"
    else flatpak-spawn --host "$@"; fi
}
[[ $( m_run pidof "SPT.Server.Linux" ) != "" ]] && exit 0
for term in "${terms[@]}"; do
    if m_run command -v $term &>/dev/null; then
        cd "${root_path}"
        m_run $term -e "./SPT.Server.Linux"
        break
    fi
done
EOF
    m_chmod +x "${path}"
}


uninstall_eft() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${BSG_DIR}" ]] && msg "EFT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        # Warn user before continuing
        msg "${BOLD}This action will uninstall \"Escape from Tarkov\" from your system!${RESET}"
        msg "Prefix directory: ${UNDERLINE}${CONFIG[pfx_dir]}${RESET}"
        yesno "Do you want to continue?" || m_exit 0
    fi

    msg "Uninstalling \"Escape from Tarkov\"..."
    m_rmdir "${BSG_DIR}"

    msg "Removing \"BSG Launcher\" shortcut..."
    app_path="${APP_DIR}/BSG - Launcher.desktop"
    [[ -f "${app_path}" ]] && m_rm "${app_path}"

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_spt() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${SPT_DIR}" ]] && msg "SPT is not installed" && return 0
    # Ask for confirmation
    if [[ "${no_prompt}" != 1 ]]; then
        msg "${BOLD}This action will uninstall \"SPTarkov\" from your system!${RESET}"
        msg "SPT directory: ${UNDERLINE}${SPT_DIR}${RESET}"
        yesno "Do you want to continue?" || m_exit 0
    fi

    msg "Uninstalling \"SPTarkov\"..."
    m_rmdir "${SPT_DIR}"

    msg "Removing \"SPTarkov\" shortcuts..."
    local apps=( "SPT - Launcher.desktop" "SPT - Server.desktop" )
    for app in "${apps[@]}"; do
        local app_path="${APP_DIR}/${app}"
        [[ -f "${app_path}" ]] && m_rm "${app_path}"
    done

    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


uninstall_prefix() {
    local no_prompt="${1:-$NO_PROMPT}"
    [[ ! -d "${CONFIG[pfx_dir]}" ]] && msg "Prefix directory does not exist" && return 0
    msg "Removing Prefix directory..."
    m_rmdir "${CONFIG[pfx_dir]}"
    [[ "${no_prompt}" != 1 ]] && msg "${GREEN}Done!${RESET}"
}


# # # # # # # # # # # #
#   Option functions  #
# # # # # # # # # # # #


opt_patch() {
    local progress_total
    local target_path="$(realpath -m "${1%/:-"${SPT_DIR}"}")"
    local source_path="$(realpath -m "${2%/:-"${SPT_DIR}"}")"
    msg "Started \"SPTarkov\" patcher..."
    # Fail if the target director does not exist
    [[ ! -d "${target_path}" ]] && err "Target directory \"${target_path}\" does not exist"
    # Make sure hpatchz is installed
    if ! command -v "hpatchz" &>/dev/null; then
        install_dep "hpatchz" "${URL[hpatchz]}" || err "Missing dependency \"hpatchz\". Please install it & try again"
    fi
    # Search in optional SOURCE directory
    if [ "$( find "${source_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        msg "Using \"SPT_Patches\" found in \"${source_path}\""
    # Search in TARGET directory
    elif [ "$( find "${target_path}" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null )" ]; then
        msg "Using \"SPT_Patches\" found in \"${target_path}\""
        source_path="${target_path}"
    else
        # No "SPT_Patches" directory found
        err "Unable to locate \"SPT_Patches\" directory in \"${source_path}\""
    fi
    # Print debug strings
    msg "Source path: ${source_path}"
    msg "Target path: ${target_path}"
    
    local progress_start=1
    progress_total=$( find "${source_path}/SPT_Patches" \( -type f -printf x \) | wc -c )

    find "${source_path}/SPT_Patches" \( -type f \) -print0 | while IFS= read -r -d '' source; do 
        # progress_current
        local progress_current="[${progress_start}/${progress_total}]"
        # Isolate the operation extension
        local extension="${source##*.}"
        # Isolate sub-directories of SPT_Patches
        local formatted="${source#*SPT_Patches/}"
        # Remove operation extension to get actual file name
        formatted="${formatted%.*}"

        local output="${target_path}/${formatted}"
        local target="${output}.decoded"
        local dir_path="${output%/*}"

        case "$extension" in
            "delta")
                msg "${progress_current} (*) Patching: ${formatted##*/}"
                hpatchz "${output}" "${source}" "${target}" 1>/dev/null || return 1

                # Remove old file and replace with .decoded file
                [[ ! -f "${target}" ]] && return 1
                m_rm "${output}" || return 1
                mv "${target}" "${output}" || return 1
            ;;
            "del")
                msg "${progress_current} (-) Deleting: ${formatted##*/}"
                m_rm "${output}" || return 1
                if [[ -z "$( m_ls -A "${dir_path}" )" ]]; then
                    msg "${progress_current} (-) Deleting directory: ${dir_path##*/}"
                    m_rmdir "${dir_path}" || return 1
                fi
            ;;
            "new")
                msg "${progress_current} (+) Adding: ${formatted##*/}"
                if [[ ! -d "${dir_path}" ]]; then
                    msg "${progress_current} (+) Adding directory: ${dir_path##*/}"
                    mkdir -p "${dir_path}"
                fi
                cp "${source}" "${output}" || return 1
            ;;
            *)
                return 1
            ;;
        esac
        progress_start=$((progress_start+1))
    done

    if [[ "$?" -ne "0" ]]; then
        # Failed patching
        m_rmdir "${SPT_DIR}"
        err "Patching failed"
    fi
    
    # Clean up patcher files
    if [[ "${target_path}" == *"${source_path}"* ]]; then
        msg "Cleaning up patcher files..."
        [[ -d "${source_path}/SPT_Patches" ]] && m_rmdir "${source_path}/SPT_Patches"
        [[ -f "${source_path}/patcher.exe" ]] && m_rmdir "${source_path}/patcher.exe"
    fi

    msg "Done patching game files!"
}


opt_install() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov install spt 
    local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) install_eft ;;
        spt|sptarkov) install_spt "${INSTALL_MODE}" ;;
        help|-h|--help) opt_help "install";;
        "") opt_guided_install ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_uninstall() {
    # SYNTAX: spt-additions -p ~/Games/sptarkov uninstall spt 
    local option="$1" && shift
    case "${option}" in
        eft|tarkov|bsg) uninstall_eft ;;
        spt|sptarkov) uninstall_spt ;;
        all)
            # Ask for confirmation
            if ! [ "${NO_PROMPT}" = 1 ]; then
                msg "${BOLD}This action will remove the installed wine prefix!${RESET}"
                msg "The following directory will be deleted ${BOLD}permanently${RESET}:"
                msg "${UNDERLINE}${CONFIG[pfx_dir]}${RESET}"
                yesno "Do you want to continue?" || m_exit 0
            fi

            uninstall_eft 1
            uninstall_spt 1
            uninstall_prefix 1

            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        help|-h|--help) opt_help "uninstall";;
        "") err "Option \"uninstall\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_guided_install() {
    local input

    # Overview
    echo
    msg "${BOLD}${BLUE}Welcome soldier!${RESET}"
    msg "This cli installer will perform the following steps for you:"
    msg "   - Install latest Proton-GE / UMU-Proton to the Steam compatibility tool directory (if not already installed)"
    msg "   - Setup the wine prefix & install all required dependencies"
    msg "   - Install the BSG Launcher"
    msg "   - Install SPTarkov using a native Linux installer script"
    msg "   - Add application shortcuts"
    msg

    while true; do
        # Choose a custom prefix install location
        msg "${BOLD}${BLUE}Where do you want to install the prefix? (Current path is \"${CONFIG[pfx_dir]}\")${RESET}"
        input="$(read_input)"
        [[ -n "$input" ]] && set_prefix "${input//[~]/"$HOME"}"
        # Install EFT
        opt_install eft
        msg "The \"BSG Launcher\" has been installed successfully!"
        # Interactive - Users need to manually install the game client inside the BSG Launcher
        msg "${BOLD}${BLUE}Please log-in to your BSG account, install Escape from Tarkov & close the launcher to continue...${RESET}"
        opt_run bsg-launcher
        # Update EFT path
        EFT_DIR="$( get_eft_path )"
        # Install SPT
        opt_install spt
        # Ask to add Faugus shortcuts
        if check_faugus; then
            msg
            msg "Looks like you have \"Faugus-Launcher\" installed on your system."
            yesno "${BOLD}${BLUE}Do you want to add EFT/SPT shortcuts to it?${RESET}"
            case $? in
                0) opt_shortcut faugus ;;
                *) ;;
            esac
        fi
        msg
        msg "${BOLD}${BLUE}EFT/SPT is now installed! :)${RESET}"
        msg
        msg "${BOLD}${BLUE}You need more help or just wanna chat with other nerds? Go here:${RESET}"
        msg "   > ${URL[discord]}"
        msg
        msg "${BOLD}${BLUE}Find your favorite mods in ${GREEN}THE FORGE${RESET}:"
        msg "   > ${URL[forge]}"
        return 0
    done
}


opt_run() {
    # SYNTAX: spt-additions -e MANGOHUD=1 run spt-launcher 
    local option="$1" && shift
    [[ -z "${option}" ]] && err "Option \"run\" requires an argument"
    
    case "${option}" in
        eft|tarkov|bsg|bsg-launcher)
            set_arg "--disable-software-rasterizer"
            cd "${BSG_DIR}/BsgLauncher" && m_umu -q "BsgLauncher.exe" "${ARGS[@]}"
        ;;
        spt-launcher|launcher)
            check_eft_running
            cd "${SPT_DIR}" && m_umu -q SPT.Launcher.exe "${ARGS[@]}"
        ;;
        spt-server|server)
            check_eft_running
            cd "${SPT_DIR}" && "./launch-server.sh" "${ARGS[@]}"
        ;;
        winetricks) m_umu winetricks -q "$*" ;;
        help|-h|--help) opt_help "run";;
        "") err "Option \"run\" requires an argument" ;;
        *) cd "${CONFIG[pfx_dir]}" && m_umu "${option}" "${ARGS[@]}" ;;
    esac
}


opt_env() {
    # SYNTAX: spt-additions env add MANGOHUD=1
    local key value
    local option="$1"
    local keyval="$2" && shift 2
    key=$( echo "${keyval}" | cut -d "=" -f1 )
    value=$( echo "${keyval}" | cut -d "=" -f 2- )
    [[ "${key}" == "${value}" ]] && unset value

    # If the key begins with a - we actually wanna unset it!
    if [[ $key == -* ]]; then
        key="${key:1}"
        opt_env unset "${key}"
        return
    fi

    case "${option}" in
        set|add)
            if [[ "${ENV[$key]}" ]]; then msg "Updating environment variable: \"${keyval}\""
            else msg "Adding environment variable: \"${keyval}\""; fi
            set_value env "${key}=${value}"
        ;;
        unset|remove)
            [[ ! "${ENV[$key]}" ]] && msg "Environment variable \"${key}\" is not set" && return
            msg "Removing environment variable: \"$keyval\""
            unset_value env "${key}"
        ;;
        list|-l)
            for key in "${!ENV[@]}"; do
                local var="${key}=${ENV[$key]} "
                msg "${var}"
            done
        ;;
        help|h|-h|--help) opt_help "env" ;;
        "") err "Option \"env\" requires an argument" ;;
        *) err "Invalid switch \"${option}\"" ;;
    esac
}


add_app_shortcut() {
    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "app-shortcut" ]] && err "Failed to load shortcut data from cache array"
    msg "Updating \"${CACHE[name]}\" shortcut..."
    # Get env string
    local env="$( get_env_string )"
    env+="WINEPREFIX=${CONFIG[pfx_dir]}"
    [[ "${env}" != *"PROTONPATH"* ]] && env+=" PROTONPATH=GE-Proton"
    # Remove existing shortcut
    [[ -f "${CACHE[path]}" ]] && m_rm "${CACHE[path]}"
    # Generate the exec string
    local exec_string
    case "${CACHE[executable]}" in
        *exe*|*bat*|*msi*) exec_string="Exec=env $env "${UMU_PATH}" \"${CACHE[executable]}\" ${ARGS[*]}" ;;
        *) exec_string="Exec=\"${CACHE[working_dir]}/${CACHE[executable]}\" ${ARGS[*]}" ;;
    esac
    # Write desktop file
    {   echo "[Desktop Entry]"
        echo "Categories=Game;ActionGame;Simulation"
        echo "Path=${CACHE[working_dir]}"
        echo "${exec_string}"
        echo "Name=${CACHE[name]}"
        echo "Icon=${CACHE[icon]}"
        echo "Type=Application"
    } > "${CACHE[path]}" && m_chmod +x "${CACHE[path]}"
}


add_faugus_shortcut() {
    local config_dir json_path

    if ! check_faugus; then
        msg "Faugus-Launcher is not installed"
        return 0
    fi

    # Check if our cache array is prepared
    [[ "${CACHE[_id]}" != "faugus-shortcut" ]] && err "Failed to load shortcut data from cache array"
    # Create Faugus config dir if not already there
    mkdir -p "${config_dir}"
    # Create games.json if it doesn't exist
    [[ ! -f "${json_path}" ]] && jq -n '[]' > "${json_path}"
    # Check if the game ids already exist
    if cat "${json_path}" | grep "${CACHE[gameid]}" &>/dev/null; then
        warn "A shortcut for \"${CACHE[title]}\" already exists, skipping"
        return 0
    fi
    # Add shortcut
    local prefix="${CONFIG[pfx_dir]}"
    local launch_args="$(get_env_string)"
    local game_args="${ARGS[*]}"
    local runner="GE-Proton"
    msg "Adding \"${CACHE[title]}\" to Faugus Launcher..."
    jq --arg gameid "${CACHE[gameid]}" --arg title "${CACHE[title]}" --arg path "${CACHE[path]}" \
    --arg prefix "${prefix}" --arg launch_args "${launch_args}" --arg game_args "${game_args}" --arg runner "${runner}" \
    '. += [{ "gameid": $gameid,"title": $title,"path": $path,"prefix": $prefix,
    "launch_arguments": $launch_args,"game_arguments": $game_args,"runner": $runner,
    "lossless_enabled": false,"lossless_performance": false,"lossless_hdr": false }]'\
    "${json_path}" > "${TMP_DIR}/games.json" || err "Failed to add Faugus shortcut"
    mv "${TMP_DIR}/games.json" "${json_path}"
}


opt_shortcut() {
    # SYNTAX: spt-additions -p "" -e "" -a "" shortcut spt-launcher
    local name executable working_dir path icon
    local option="$1" && shift

    case "${option}" in
        eft|bsg|bsg-launcher)
            set_arg "--disable-software-rasterizer"
            CACHE[_id]="app-shortcut"
            CACHE[name]="BSG - Launcher"
            CACHE[executable]="BsgLauncher.exe"
            CACHE[working_dir]="${BSG_DIR}/BsgLauncher"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="bsg_launcher"
            add_app_shortcut
        ;;
        spt-launcher)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Launcher"
            CACHE[executable]="SPT.Launcher.exe"
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_launcher"
            add_app_shortcut
        ;;
        spt-server)
            CACHE[_id]="app-shortcut"
            CACHE[name]="SPT - Server"
            CACHE[executable]="launch-server.sh"
            CACHE[working_dir]="${SPT_DIR}"
            CACHE[path]="${APP_DIR}/${CACHE[name]}.desktop"
            CACHE[icon]="spt_server"
            add_app_shortcut
        ;; 
        spt|sptarkov)
            opt_shortcut spt-launcher
            opt_shortcut spt-server
        ;;
        faugus)
            if [[ -d "${SPT_DIR}" ]]; then
                # SPT - Launcher
                CACHE[_id]="faugus-shortcut"
                CACHE[gameid]="spt-launcher"
                CACHE[title]="SPT Launcher"
                CACHE[path]="${SPT_DIR}/SPT.Launcher.exe"
                add_faugus_shortcut
            fi
            if [[ -d "${BSG_DIR}" ]]; then
                # BSG - Launcher
                set_arg "--disable-software-rasterizer"
                CACHE[_id]="faugus-shortcut"
                CACHE[gameid]="bsg-launcher"
                CACHE[title]="BSG Launcher"
                CACHE[path]="${BSG_DIR}/BsgLauncher/BsgLauncher.exe"
                add_faugus_shortcut
            fi
        ;;
        all)
            opt_shortcut bsg-launcher
            opt_shortcut spt-launcher
            opt_shortcut spt-server
        ;;
        help|-h|--help) opt_help "shortcut";;
        "") err "Option \"shortcut\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_clean() {
    # SYNTAX: spt-additions clean all --no-prompt
    local option="$1" && shift

    case "${option}" in
        cache)
            msg "Removing Cache directory..."
            [[ -d "${CACHE_DIR}" ]] && m_rmdir "${CACHE_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        config)
            msg "Removing config directory..."
            [[ -d "${CONFIG_DIR}" ]] && m_rmdir "${CONFIG_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        data)
            msg "Removing data directory..."
            [[ -d "${DATA_DIR}" ]] && m_rmdir "${DATA_DIR}"
            [[ "${NO_PROMPT}" != 1 ]] && msg "${GREEN}Done!${RESET}"
        ;;
        all)
            if [[ "${NO_PROMPT}" != 1 ]]; then
                # Warn user before continuing
                msg "${BOLD}This action will remove all configs & cached files!${RESET}"
                msg "The following directories will be deleted ${BOLD}permanently${RESET}:"
                msg "    > ${UNDERLINE}${DATA_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CACHE_DIR}${RESET}"
                msg "    > ${UNDERLINE}${CONFIG_DIR}${RESET}"
                yesno "Do you want to continue?" || m_exit 0
            fi
            export NO_PROMPT=1
            opt_clean data
            opt_clean config
            opt_clean cache
            msg "${GREEN}Done!${RESET}"
        ;;
        help|-h|--help) opt_help "clean";;
        "") err "Option \"clean\" requires an argument" ;;
        *) err "Invalid option \"${option}\"" ;;
    esac
}


opt_selfupdate() {
    if [[ "${NO_PROMPT}" != 1 ]]; then
        msg "> The script will attempt to install the latest script from:"
        msg "> ${UNDERLINE}${URL[installer-script]}${RESET}"
        msg
        msg "> This feature is ${BOLD}NOT${RESET} fully implemented yet & won't validate the new script file!"
        msg
        yesno "Do you want to continue?" || m_exit 0
    fi
    msg "Updating script..."
    cd "${SCRIPT_PATH}" && m_curl -LO "${URL[installer-script]}"
    m_chmod +x "${SCRIPT_PATH}"
}


opt_help() {
    local option="${1}"
    case "${option}" in
        install)
            msg "${BOLD}Available options:${RESET}"
            msg "[eft|bsg|tarkov]               - Install the BSG Launcher"
            msg "[spt|sptarkov]                 - Install SPTarkov"
            msg
            msg "${BOLD}SPT Install modes:${RESET}"
            msg "native|proton"
            opt_help switches
        ;;
        uninstall)
            msg "${BOLD}Available options:${RESET}"
            msg "eft|spt|all"
            opt_help switches
        ;;
        shortcut)
            msg "${BOLD}Available options:${RESET}"
            msg "[eft|bsg|bsg-launcher]         - Update BSG-Launcher shortcut"
            msg "[spt|sptarkov]                 - Update SPT.Server and SPT.Launcher shortcut"
            msg "spt-launcher|spt-server        - Update SPT.Server or SPT.Launcher shortcut"
            msg "all                            - Update all shortcuts"
            opt_help switches
        ;;
        run)
            msg "${BOLD}Available options:${RESET}"
            msg "[eft|bsg|bsg-launcher]         - Run the BSG Launcher"
            msg "[spt-launcher|launcher]        - Run the SPT Launcher"
            msg "[spt-server|server]            - Run the native SPT Server"
            msg "winetricks [*]                 - Run \"winetricks -q [VERBS]\" inside the prefix"
            msg "[*]                            - Run a custom command/executable inside the prefix"
            opt_help switches
        ;;
        env)
            msg "Set/unset environment variables"
            msg 
            msg "${BOLD}Usage:${RESET}"
            msg "$TITLE env [set|unset] [key|key=value]"
            opt_help switches
        ;;
        patch)
            msg "Patch game files using hpatchz"
            msg 
            msg "${BOLD}Usage:${RESET}"
            msg "$TITLE patch [target dir][source dir]"
            opt_help switches
        ;;
        clean)
            msg "${BOLD}Available options:${RESET}"
            msg "cache|config|data|all"
            opt_help switches
        ;;
        switches)
            msg
            msg "${BOLD}Available switches:${RESET}"
            msg "${BOLD}-m${RESET}              - Change SPT install mode (Default is \"proton\")"
            msg "${BOLD}-p${RESET}              - Set a custom path for the wine prefix"
            msg "${BOLD}-e${RESET}              - Set[*]/Unset[-*] a environment variable"
            msg "${BOLD}-a${RESET}              - Add a custom launch argument"
            msg "${BOLD}--no-prompt${RESET}     - Disable interactive prompt messages"
            msg "${BOLD}--no-ansi${RESET}       - Disable ansi codes in messages"
        ;;
        "")
            msg "A Standalone EFT/SPT installer script using UMU-Launcher and Proton."
            msg
            msg "${BOLD}Example usage:${RESET}  ${YELLOW}spt-additions -p ~/Games/tarkov install eft ${RESET}"
            msg "                ${YELLOW}spt-additions -e MANGOHUD=1 shortcut spt-launcher ${RESET}"
            msg
            msg "${BOLD}OPTIONS:${RESET}"
            msg "${BOLD}install${RESET}          - Install EFT/SPT into a prefix"
            msg "${BOLD}uninstall${RESET}        - Uninstall EFT/SPT from a prefix"
            msg "${BOLD}patch${RESET}            - Downpatch EFT game files"
            msg "${BOLD}shortcut${RESET}         - Create/update EFT/SPT shortcuts"
            msg "${BOLD}run${RESET}              - Run EFT/SPT or custom commands inside the prefix"
            msg "${BOLD}clean${RESET}            - Clean installer and prefix files"
            msg "${BOLD}help${RESET}             - Get help for a command (e.g. 'help install')"
            msg "${BOLD}--self-update${RESET}    - Updates this installer script"
            msg "${BOLD}-h | --help${RESET}     - Print the help message"
            msg "${BOLD}-v | --VERSION${RESET}  - Print the VERSION info message"
        ;;
        *) msg "Invalid option: ${option}" ;;
    esac
}


opt_version() {
    msg "${BOLD}Version: ${RESET}${VERSION} (${DATE})"
}


# # # # # # # # # # #
#  Entry functions  #
# # # # # # # # # # #

handle_opts() {
    while getopts ":p:e:a:m:h-:" subopt; do
        case ${subopt} in
            p) set_prefix "${OPTARG}" ;;
            e) opt_env set "${OPTARG}" ;;
            a) set_arg "${OPTARG}";;
            m)
                case "${OPTARG}" in
                    native|proton|lutris) INSTALL_MODE="${OPTARG}" ;;
                    *) err "Invalid value: ${OPTARG}" ;;
                esac
            ;;
            h) opt_help "${option}" ;;
            -*)
                case "${OPTARG}" in
                    no-prompt) export NO_PROMPT=1; msg "\"NO_PROMPT\" option set" ;;
                    no-ansi) export NO_ANSI=1; msg "\"NO_ANSI\" option set" ;;
                    *) err "Invalid option: --${OPTARG}" ;;
                esac
            ;;
            :) err "Switch \"${OPTARG}\" requires an argument" ;;
            *) err "Invalid switch \"-${OPTARG}\"" ;;
        esac
        # Shift for the switch and it's value
        shift 2
    done

    local option="${1}" && shift

    # Install umu if needed
    case "${option}" in
        install|run|patch)
            [[ ! -f "${UMU_PATH}" ]] && install_dep "umu-run" "${URL[umu-launcher]}"
        ;;
    esac

    case "${option}" in
        install) opt_install "$@" ;;
        uninstall) opt_uninstall "$@" ;;
        run) opt_run "$@" ;;
        patch) opt_patch "$@" ;;
        shortcut) opt_shortcut "$@" ;;
        env) opt_env "$@" ;;
        clean) opt_clean "$@" ;;
        self-update) opt_selfupdate ;;
        version) opt_version ;;
        help) opt_help "$@";;
        -*)
            case "${option}" in
                -v) opt_version ;;
                -h) opt_help ;;
                --self-update) opt_selfupdate ;;
                --version) opt_version ;;
                --help) opt_help ;;
                *) err "Invalid option: ${option}" ;;
            esac
        ;;
        "") opt_version ;;
        *) err "Invalid option: ${option}" ;;
    esac
}


main() {
    # Remove tmp files
    if [[ -d "${TMP_DIR}" ]] && [[ -n $( m_ls "${TMP_DIR}" ) ]]; then
        m_rmdir "${TMP_DIR}/"
    fi
    
    # Create dirs
    local dirs=( "${DATA_DIR}" "${RUNTIME_DIR}" "${CACHE_DIR}" "${CONFIG_DIR}" "${TMP_DIR}" "${ICO_DIR}" )
    for dir in "${dirs[@]}"; do [[ ! -d "${dir}" ]] && mkdir -p "${dir}"; done

    # Set default config variables
    if [[ ! -f "${CONFIG_PATH}" ]]; then
        set_value config "pfx_dir=${DEFAULT_PFX_DIR}"
        set_value config "spt_dir=${DEFAULT_SPT_DIR}"
    fi

    # Set default environment variables
    if [[ ! -f "$ENV_PATH" ]]; then
        set_value env "PROTON_USE_XALIA=0"
        set_value env "DOTNET_ROOT="
        set_value env "DOTNET_BUNDLE_EXTRACT_BASE_DIR="
    fi

    # Remove old log file
    [[ -f "${LOG_PATH}" ]] && m_rm "${LOG_PATH}"

    # Load config files
    [[ -f "${CONFIG_PATH}" ]] && load_array config
    [[ -f "${ENV_PATH}" ]] && load_array env

    # Update prefix paths
    check_prefix_path "${CONFIG[pfx_dir]}"
    check_spt_path "${CONFIG[spt_dir]}"
    SPT_DIR="${CONFIG[pfx_dir]%/}/${CONFIG[spt_dir]%/}"
    BSG_DIR="${CONFIG[pfx_dir]%/}/drive_c/Battlestate Games"
    EFT_DIR="$( get_eft_path )"

    # Export paths
    export PROTONPATH="GE-Proton"
    export WINEPREFIX="${CONFIG[pfx_dir]}"
    export PATH=$RUNTIME_DIR:$PATH

    # HACK: Just for debugging purposes rn
    export WINEDEBUG="-all,err+all,fixme+all,debugstr+all"

    # Handle command line arguments
    handle_opts "$@"
}

# Main entry
main "$@"
m_exit 0
