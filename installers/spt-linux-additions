#!/bin/bash

# MIT License
# Copyright (c) 2025 MadByte

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to
# do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# ERROR CODES:
# 0 = normal exit (Success)
# 1 / 256 = General error
# 2 / 512 = Subshell error
# 3 / 768 = User aborted manually

# TODO LIST: 
# TODO: Enable verbose output for more commands
# TODO: Add ability to clean up backups
# TODO: Add ability exclude files/directories from restore or backup


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Global variables #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

TITLE="spt-linux-additions"
VERSION="2025.1-2.1"

# ANSI codes
readonly BOLD="\e[1m"; readonly UNDERLINE="\e[2m"; readonly RESET="\e[0m"
readonly RED="\e[31m"; readonly GREEN="\e[32m"; readonly BLUE="\e[36m"
readonly YELLOW="\e[33m"; readonly GRAY="\e[90m"

# Common paths
readonly CONFIG_PATH="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly CACHE_PATH="${XDG_CACHE_HOME:-${HOME}/.cache}/${TITLE}"
readonly BINARIES_PATH="${CACHE_PATH}/binaries"
readonly LOG_PATH="${CACHE_PATH}/spt-linux-additions.log"

# Script variables
readonly SCRIPT_UPDATE_URL="https://raw.githubusercontent.com/MadByteDE/SPT-Linux-Guide/refs/heads/main/installers/spt-linux-additions"
readonly SCRIPT_ROOT_PATH="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# Mod variables
readonly MOD_RELEASE_JSON_URL="https://spt-releases.modd.in/release.json"
readonly MOD_RELEASE_JSON_PATH="${CACHE_PATH}/json/release.json"
readonly MOD_FILE_PATH="${CACHE_PATH}/SPT.7z"

# Patcher variables
readonly PATCHER_MIRRORS_JSON_URL="https://slugma.waffle-lord.net/mirrors.json"
readonly PATCHER_MIRRORS_JSON_PATH="${CACHE_PATH}/json/mirrors.json"
readonly PATCHER_FILE_PATH="${CACHE_PATH}/Patcher.7z"

# SPT variables
readonly SPT_USER_DATA_DIRS=("user" "BepInEx/config" "BepInEx/plugins" "BepInEx/patchers")
readonly SPT_USER_CONFIG_DIRS=("user/sptSettings" "user/profiles" "user/launcher" "BepInEx/config")
readonly SPT_DEFAULT_INSTALL_PATH=${SPT_INSTALL_PATH:-"drive_c/SPTarkov"}
readonly SPT_DEFAULT_BACKUP_PATH=${SPT_BACKUP_PATH:-"drive_c/spt-backups"}
readonly SPT_LATEST_BACKUP_FILE="${CACHE_PATH%/}/latest_backup"


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Helper functions #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

m_echo() {
    # Echo to console
    local filtered_str=$(echo -e "${@}" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g')
    
    case ${NO_ANSI} in
        # Remove ANSI codes
        1) echo "${filtered_str}" ;;
        # Use ANSI codes
        *) echo -e "${@}" ;;
    esac

    # Echo to log file
    echo "${filtered_str}" 2>/dev/null >> "${LOG_PATH}"
}


m_sleep() {
    local sleep_time=${1:-2}
    [[ ${NO_WAIT} -eq 0 ]] && sleep "${sleep_time}"
}


m_exit() {
    local status=${1:-0}
    # Make sure some stuff is only run when we're not in a subshell env
    if [[ ! -v ${BASH_SUBSHELL} || ${BASH_SUBSHELL} -eq 0 ]]; then
        if [[ "$status" -ne 0 ]]; then
            # This is a workaround for Lutris closing the installer cli immediately after
            # encountering an error & just showing the -not so useful- error code
            if [[ "$status" -ne 3 ]]; then
                [[ "$PATH" == *"lutris"* ]] && m_sleep 10
                # open the error log using the default text editor 
                m_run xdg-open "${LOG_PATH}"
            fi
        fi
        # Remove temp files before exiting
        if [ -d "${TEMP_PATH}" ]; then
            m_dbg "Removing temp files in '${TEMP_PATH}'"
            rm -r "${TEMP_PATH}" || m_warn "Failed to remove temp files"
        fi
    fi
    # Exit the shell / subshell
    exit "${status}"
}


m_msg() {
    m_echo "${FUNCNAME[1]}: $*"
}


m_success() {
    m_echo "${FUNCNAME[1]}: ${BOLD}${BLUE}$*${RESET}"
}


m_warn() {
    m_echo "${FUNCNAME[1]}: ${BOLD}${YELLOW}$*${RESET}"
}


m_dbg() {
    if [[ -z ${DEBUG_OUTPUT} || ${DEBUG_OUTPUT} -le 0 ]]; then return; fi
    m_echo "${GRAY}m_dbg: ${FUNCNAME[1]}: $*${RESET}"
}


m_err() {
    local status=${2:-1}
    m_echo "ERROR: ${FUNCNAME[1]}: ${BOLD}${RED}$1 (⊙＿⊙')${RESET}"
    m_exit "${status}"
}


m_subshell_err() {
    local status=${2:-2}
    printf "${BOLD}${RED}$1${RESET}\n"
    m_exit ${status}
}


m_cp() {
    local source_path="${1}"
    local target_path="${2}"

    # Check exists
    [ ! "${source_path}" ] && m_err "Source '${source_path}' does not exist"

    # Check if file is within the prefix directory
    [[ "${target_path}" == *"${PREFIX_PATH}"* ]] \
    || m_err "Target '${target_path}' is not inside the prefix directory"

    # Create dir(s) & copy to new location
    mkdir -p "${target_path}" 1>/dev/null || m_err "Failed to create directory in '${target_path}'"
    if ! [[ -z "$( ls -A "${source_path}" )" ]]; then
        cp --reflink=auto -r "${source_path}"* "${target_path}" \
        || m_err "Failed to copy files to '${target_path}'"
    fi
}


m_run() {
    case "${FLATPAK_ENV}" in
        1) flatpak-spawn --host "$@" ;;
        *) "$@" ;;
    esac

    # Raise warning & echo error code
    local err_code=$?
    if [ $err_code != 0 ]; then
        # Prevent messages when in a subshell to not break return values
        if [[ ${BASH_SUBSHELL} -eq 0 ]]; then
            m_warn "Failed to run command:"
            m_echo "    > $@"
            m_echo "    > ${BOLD}Exit code:${RESET} $err_code"
        fi
        return $err_code
    fi
}


m_ask() {
    m_echo "$* [y/n]"

    # Skip check if user prompts are disabled
    if [[ $NO_PROMPT -eq 1 ]]; then
        m_msg "'NO_PROMPT' environment variable set! returning 'y'."
        return 0
    fi

    while true; do
        read -p "> " yn
        case $yn in
            [Yy]*) return 0 ;;  
            [Nn]*) m_dbg "Aborted"; m_exit 3 ;;
        esac
    done
}


m_download() {
    local url="${1}"
    local output_path="${2}"
    local max_redirs="${3:-0}"
    local filename="${url##*/}"

    [ "${filename}" == "" ] \
    && filename="${output_path##*/}"

    # Download the file
    m_dbg "Download url: ${url}"
    m_dbg "Download output path: ${output_path}"
    m_msg "Downloading '${filename}'"
    m_run curl -f -L --connect-timeout 60 --max-redirs $max_redirs --create-dirs $url -o "${output_path}"

    case "$?" in
        0) m_success "Downloaded '${filename}' successfully" ;;
        *) m_warn "Failed to download '${filename}'"; return 1 ;;
    esac
}


m_extract() {
    local archive_path="${1}"
    local target_path="${2}"
    local filename="${archive_path##*/}"
    m_msg "Extracting '${filename}'"
    m_run 7z x "${archive_path}" -o"${target_path}" 1>/dev/null || >&2

    case "$?" in
        0) m_success "Extracted '${filename}' successfully" ;; 
        *) m_err "Failed to extract '${filename}' - Error code ${$?}" ;;
    esac
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# EFT helper functions #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

get_eft_install_path() {
    local prefix_path="${1:-"${PREFIX_PATH}"}"
    prefix_path="${prefix_path%/}"

    # Check exists
    [ ! -d "${prefix_path}" ] \
    && m_err "Directory '${prefix_path}' does not exist"

    # get windows formatted path
    local registry="${prefix_path}/system.reg"
    local reg_entry=$(sed -n '/Uninstall\\\\EscapeFromTarkov/,/^$/p' "${registry}")
    local path=$(echo "${reg_entry}" | \
    grep -o "\"InstallLocation\"=\"[^}]*" | cut -d "\"" -f4)

    case "${path}" in
        '') m_err "Looks like EFT is not installed" ;;
        *)
            # Replace backslashes with slashes
            local path="${path//\\\\/\/}"
            # Finally assemble the full path
            local path=$(echo "${prefix_path}/${path//C:/drive_c}")
            printf "${path}\n"
        ;;
    esac
}


get_installed_eft_version() {
    local eft_install_path="${1:-"${EFT_INSTALL_PATH}"}"

    # Check exists
    [ ! -d "${eft_install_path}" ] \
    && m_err "Directory '${eft_install_path}' does not exist"

    # Check if main exe exists
    local exe_file="${eft_install_path}/EscapeFromTarkov.exe"
    [ ! -f "${exe_file}" ] \
    && m_err "File '${exe_file}' does not exist"

    # Extract metadata
    local tmp_dir="${TEMP_PATH}/exe"
    m_extract "${exe_file}" "${tmp_dir}" 1>/dev/null

    # Finally get the EFT version from the version.txt file
    # make sure to remove null byte and -stupid- windows \r -_-* (learned it the hard way!)
    local version_file="${tmp_dir}/.rsrc/0/version.txt"
    local version=$(m_run cat "${version_file}" | head -1 | tr -d '\0\r' | cut -d "," -f4)

    # Check returned value
    case "${version}" in
        ''|*[!0-9]*) m_err "Failed to get version info" ;;
        *) printf "${version}\n" ;;
    esac
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Patcher helper functions #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

get_patcher_urls() {
    local mirrors_json_path="${1:-"${PATCHER_MIRRORS_JSON_PATH}"}"
    local mirror_index="${2}"
    local urls=$(cat "${mirrors_json_path}" \
        | grep -o "\"Link\":[^}]*" \
        | cut -d "\"" -f4)

    if [ "${mirror_index}" ]; then
        echo "${urls}" | sed "${mirror_index}q;d" 2>/dev/null
        return 0
    fi

    # Check returned value
    case "${urls}" in
        '') m_err "Failed to fetch mirror URLs from '${mirrors_json_path}'" ;;
        *) printf "${urls}\n" ;;
    esac
}


get_patcher_target_eft_version() {
    local mirrors_json_path="${1:-"${PATCHER_MIRRORS_JSON_PATH}"}"

    local url=$(get_patcher_urls "${mirrors_json_path}" 1)
    [ $? != 0 ] && m_subshell_err "${url}"

    # Split filename to get version infos from it
    local formatted_filename=$(echo "${url##*/}" | tr "_." " ")

    # get target EFT version
    local version=$(echo "${formatted_filename}" | cut -d " " -f5)

    # Check returned value
    case "${version}" in
        ''|*[!0-9]*) m_err "Failed to get version info" ;;
        *) printf "${version}\n" ;;
    esac
}


download_patcher() {
    # Get all mirror urls
    local urls="${1:-${PATCHER_MIRROR_URLS}}"; [ "${urls}" == '' ] && m_err "Missing mirror urls"
    m_dbg "Got mirrors: '"${urls}"'"
    
    # Try to download from first to last
    echo "${urls}" | while read url; do
        m_msg "Using mirror: '${url}'"
        m_download "${url}" "${PATCHER_FILE_PATH}"
        # Success
        [ $? == 0 ] && break
    done
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Installer helper functions #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

get_json_value() {
    local json_file_path="${1}"
    # Check if json file exists
    [ ! -f "${json_file_path}" ] \
    && m_err "File '${json_file_path}' does not exist"

    local value_name="${2}"
    # Check if the value name is provided
    [ ! "${value_name}" ] \
    && m_err "Missing argument 'value_name'"

    # Fetch the value
    local value=$(cat "${json_file_path}" \
        | grep -o "\"${value_name}\":[^}]*" \
        | cut -d "\"" -f4)


    # Check returned value
    case "${value}" in
        '') m_err "Failed to fetch value '$value_name' from '${json_file_path}'" ;;
        *) printf "${value}\n" ;;
    esac
}


check_hash() {
    local file_path="${1}"
    local expected_hash="${2}"

    # Check arguments
    [ ! -f "${file_path}" ] && m_err "File '${file_path}' does not exist"
    [ ! "${expected_hash}" ] && m_err "Missing 'expected_hash' argument"

    # use file to calculate MD5 hash and ENCODE in base64
    m_msg "Calculating checksum of file '${file_path##*/}'"
    file_hash=$(md5sum "${file_path}" | cut -d ' ' -f 1 | m_run xxd -r -p | base64)
    [ $? != 0 ] && m_subshell_err "${file_hash}"
    m_dbg "File hash: ${file_hash} Expected hash: ${expected_hash}"

    # Check if a hash is returned
    [ ! "${file_hash}" ] \
    && m_err "Failed to calculate hash"

    # Check if they match
    m_msg "Comparing hashes"
    if [ "${file_hash}" != "${expected_hash}" ]; then
        m_warn "Mismatch with expected hash (File: '${file_hash}' != Expected: '${expected_hash}')"
        return 1
    fi
    
    # Success
    m_success "OK"
}


check_flatpak_env() {
    # Check for flatpak env
    if [ ${FLATPAK_SANDBOX_DIR} ]; then
        m_echo "${BOLD}${YELLOW}Flatpak environment detected!${RESET}"
        m_echo
        m_echo "    > It looks like you're running the installer from a containerized environment."
        m_echo "    > Flatpak support is ${BOLD}EXPERIMENTAL${RESET}!"
        m_echo
        FLATPAK_ENV=1
        m_sleep
    fi
}


check_eft_running() {
    case $(pidof "BsgLauncher.exe") in
        '') m_success "OK" ;;
        *) m_err "Please close the BsgLauncher and the EFT client before installing (and playing) SPT!" ;;
    esac
}


check_dependencies() {
    local cmds=("7z" "xxd")
    local downloadable=("hpatchz")
    local missing_pkgs=()

    # Check each cmd and error out if something is missing
    # We need to handle packages as well - different ones for Fedora (who would have guessed :/)
    for cmd in "${cmds[@]}"; do
        local pkgs=()
        if ! m_run command -v $cmd &>/dev/null; then
            case ${cmd} in
                "7z")
                    if [ -f "/etc/fedora-release" ]; then pkgs+=("p7zip-plugins")
                    else pkgs+=("p7zip"); fi
                ;;
                "xxd")
                    if [ -f "/etc/fedora-release" ]; then pkgs+=("vim-common")
                    else pkgs+=("xxd"); fi
                ;;
            esac
            m_dbg "Found missing package(s): '${pkgs[*]}'"
            missing_pkgs+=("${pkgs[@]}")
        fi
    done

    # Fetch downloadable dependencies if needed
    for dep in "${downloadable[@]}"; do
        if [ ! -f "${BINARIES_PATH}/$dep" ]; then
            # TODO: Move this section to the top & improve handling & syntax for more deps
            case ${dep} in
                "hpatchz")
                    local url="https://github.com/sisong/HDiffPatch/releases/download/v4.8.0/hdiffpatch_v4.8.0_bin_linux64.zip"
                    local bin_path="linux64/$dep"
                    fetch_dependency "${url}" "${bin_path}"
                ;;
            esac
        fi
    done

    # Show all missing pkgs and raise an error
    if [ "${#missing_pkgs[@]}" != 0 ]; then
        m_warn "You are missing the following packages:"
        m_msg "   ${missing_pkgs[@]}"
        m_msg "Please install all missing packages and try again (e.g. using 'sudo apt install ${missing_pkgs[*]}' or 'sudo dnf install ${missing_pkgs[*]}')"
        m_err "Missing dependencies"
    fi

    # Success
    m_success "OK"
}


fetch_dependency() {
    local url="${1}"
    local bin_path="${2}"

    # Ask for permission to install dependency
    m_msg "'$dep' will be downloaded from:"
    m_echo "    ${url}"
    m_ask "Do you want to continue?"

    # TODO: Check if the URLs target file is an archive or an executable!

    local temp_path="${TEMP_PATH}/$dep"
    local archive_path="${temp_path}/build.zip"

    # Download
    m_download "${url}" "${archive_path}" 1 || m_err "Failed to download '$dep'"

    # Extract
    m_extract "${archive_path}" "${temp_path}"

    # Install
    m_msg "Installing '$dep'..."
    m_run mv -f "${temp_path}/$bin_path" "${BINARIES_PATH}/" || m_err "Failed to move '$dep' to '${BINARIES_PATH}'"
    chmod +x "${BINARIES_PATH}/$dep" || m_err "Failed to make file executable: '$dep'"
    m_msg "'${dep}' has been installed successfully!"
}


check_disk_space() {
    local path=${1:-${PREFIX_PATH}}
    [ ! "${path}" ] && m_err "Missing path argument"

    # Get required values
    local free_kb=$(df -k "${path}" | tail -1 | awk '{print $4}')
    local free_gb=$(echo $free_kb | awk '{ free = $1 / 1024/1024 ; printf("%.2fGiB\n", free) }')
    local eft_kb=$(du -cs "${EFT_INSTALL_PATH}" | head -1 | cut -d$'\t' -f1)
    local overhead_kb=$((1024*1024*10))
    local total_kb=$(($eft_kb + $overhead_kb))
    local total_gb=$(echo $total_kb | awk '{ total = $1 / 1024/1024 ; printf("%.2fGiB\n", total) }')
    m_dbg "Free disk space: ${free_kb} kb (checked in ${path})"
    m_dbg "EFT install size: ${eft_kb} kb"
    m_dbg "Total required free space: ${total_kb} kb"

    # Check if there's enough space
    [ $free_kb -le $total_kb ] \
    && m_err "Not enough free disk space! ($free_gb available < $total_gb needed)"

    # Success
    m_success "OK ($free_gb available > $total_gb needed)"
}


check_mod_install_path() {
    # Reinstall mode - use some common files to validate that this is a game directory
    if [[ ${REINSTALL_SPT} -eq 1 ]]; then
    
        [ ! -d "${SPT_INSTALL_PATH}" ] \
        && m_err "SPT install directory at '${SPT_INSTALL_PATH}' does not exist"

        # FIXME: Not the best way to verify the game directory.. hmmm...
        local try_paths=( "SPT_Data" "BepInEx" "EscapeFromTarkov.exe" )
        for path in "${try_paths[@]}"; do
            local full_path="${SPT_INSTALL_PATH}/${path}"
            [ ! -e "${full_path}" ] \
            && m_err "Directory is not a valid SPT install directory"
        done

    # Check if install dir is empty
    elif [[ ${REINSTALL_SPT} -eq 0 ]] && [ ! -z "$(ls -A "${SPT_INSTALL_PATH}" 2>/dev/null)" ]; then
        m_warn "SPT install directory not empty!"
        m_echo
        m_echo "    > Install path: '${SPT_INSTALL_PATH}'"
        m_echo "    > Please make sure the path is correct and there are no files inside the directory!"
        m_echo
        m_err "SPT install directory not empty"
    fi
    # TODO: Check for weird paths passed to the installer
    m_success "OK (Path: '${SPT_INSTALL_PATH}')"
}


verify_cached() {
    local cached_path="${1}"; [ ! "${cached_path}" ] && m_err "Missing cached path argument"
    local expected_hash="${2}"; [ ! "${expected_hash}" ] && m_err "Missing expected hash argument"

    # Make sure the path actually is in CACHE_PATH
    [[ "$cached_path" == *"${CACHE_PATH}"* ]] \
    || m_err "Given file isn't inside the scripts cache directory"

    # Verify the file is there and valid
    local filename=${cached_path##*/}
    m_msg "Checking for cached file '${filename}'"
    if [ -f "${cached_path}" ]; then
        m_success "Found '${filename}' in cache directory"

        # Check hash
        check_hash "${cached_path}" "${expected_hash}"; status=$?

        # Hash mismatch? Get rid of that sh*t
        if [ $status != 0 ]; then
            m_msg "Removing cached file '${filename}'"
            rm -f "${cached_path}" \
            || m_err "Failed to remove file '${filename}'"
            return 1
        else
            return 0
        fi
    else
        m_warn "File not cached"
        return 1
    fi
}


remove_spt_install() {
    # Remove old spt installation
    m_msg "Removing old/corrupted SPT files"
    # Make sure to remove only stuff inside the prefix directory
    if [[ "${SPT_INSTALL_PATH}" == *"${PREFIX_PATH}"* ]]; then
        rm -rf "${SPT_INSTALL_PATH}" || m_warn "Failed to remove SPT install directory"
    fi
}


cp_eft_files() {
    local source_dir="${1:-${EFT_INSTALL_PATH}}"
    local target_dir="${2:-${SPT_INSTALL_PATH}}"
    m_msg "Copying EFT game files to '${target_dir}'"
    # In case of failure, remove the created SPT directory to prevent the next install
    # attempt to fail because of existing files
    m_cp "${source_dir%/}/" "${target_dir%/}"
    if [ $? != 0 ]; then
        remove_spt_install
        m_err "Failed to copy EFT game files"
    fi
}


set_prefix_path() {
    local absolute_path="${1:-"${SCRIPT_ROOT_PATH}"}"
    # Check if the path is valid
    if [ ! -f "${absolute_path}/system.reg" ]; then
        m_warn "'${absolute_path}' is not a valid wine prefix directory"
    fi
    # Update global variable
    PREFIX_PATH="${absolute_path}"
}


set_spt_path() {
    local relative_path="${1:-${SPT_DEFAULT_INSTALL_PATH}}"
    local absolute_path="${PREFIX_PATH%/}/${relative_path}"
    # Check if the path is valid
    if [[ "${absolute_path}" != *"drive_c"* ]]; then
        m_err "The path must be installed inside the 'drive_c' directory"
    elif [[ "${absolute_path}" != *"${PREFIX_PATH}"* ]]; then
        m_err "The path must be inside the correct wine prefix directory"
    fi
    # Update global variable
    SPT_INSTALL_PATH="${absolute_path}"
}


set_backup_path() {
    local relative_path="${1:-${SPT_DEFAULT_BACKUP_PATH}}"
    local absolute_path="${PREFIX_PATH%/}/${relative_path}"
    # Check if the path is valid
    if [[ "${absolute_path}" != *"drive_c"* ]]; then
        m_err "The path must be inside the 'drive_c' directory"
    elif [[ "${absolute_path}" != *"${PREFIX_PATH}"* ]]; then
        m_err "The path must be inside the correct wine prefix directory"
    fi
    # Update global variable
    SPT_BACKUP_PATH="${absolute_path}"
}


validate_metadata() {
    local file_path="${1}"
    # Check if file exists, if not - fail the check
    [ ! -f "${file_path}" ] \
    && m_warn "File does not exist" \
    && return 1

    # Calculate time elapsed since last modified
    # default is 1 hour
    local ttl="${2:-"3600"}" 
    local current=$(date +%s)
    local modified=$(date -r "${file_path}" +%s)
    ((elapsed = current - modified))
    m_dbg "Elapsed since modified: $elapsed seconds. File: '${file_path}'"

    # If elapsed time >= TTL - fail the check
    [[ $elapsed -ge $ttl ]] \
    && m_warn "File is outdated" \
    && return 1

    # Check passed
    m_success "File is valid"
}


fetch_metadata() {
    local url="${1}"; [ ! "${url}" ] && m_err "Missing expected url argument"
    local path="${2}"; [ ! "${path}" ] && m_err "Missing expected path argument"
    local name="${path##*/}"

    m_msg "Downloading '${name}'"
    m_dbg "Metadata URL: '${url}'"
    m_dbg "Metadata PATH: '${path}'"

    validate_metadata "${path}"
    if [ $? != 0 ]; then
        # (Re-)Download json file
        m_download "${url}" "${path}"
        [ $? != 0 ] && m_warn "Couldn't download latest metadata. The Installation might fail!"
    fi
}


get_cached_backup_path() {
    if [ ! -f "${SPT_LATEST_BACKUP_FILE}" ]; then
        m_dbg "File '${SPT_LATEST_BACKUP_FILE}' does not exist"
        return
    fi
    CACHED_BACKUP_PATH=$(cat "${SPT_LATEST_BACKUP_FILE}")
    [ -z "${CACHED_BACKUP_PATH}" ] \
    && m_warn "Failed to get cached backup path"
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Option functions #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

opt_patcher() {
    m_msg "Launching patcher..."
    local target_path="${1:-"${PATCHER_TARGET_PATH}"}" 
    target_path="${target_path%/}"
    local source_path="${2:-"${PATCHER_SOURCE_PATH}"}" 
    source_path="${source_path%/}"

    local patcher_cmd="${BINARIES_PATH}/hpatchz"
    local patcher_args="";

    # Check for the patcher binary
    m_run command -v ${patcher_cmd} &>/dev/null \
    || m_err "Missing dependency 'hpatchz'. Please install it & try again"

    [ ! -d "${target_path}" ] \
    && m_err "Target directory '${target_path}' does not exist"

    # Search in optional SOURCE directory
    if [ $(find "$source_path" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null) ]; then
        source_path="${source_path}"
        m_msg "Using 'SPT_Patches' found in '${source_path}'"
    # Search in TARGET directory
    elif [ "$(find "$target_path" -maxdepth 1 -type d -name "SPT_Patches" 2>/dev/null)" ]; then
        m_msg "Using 'SPT_Patches' found in '${target_path}'"
        source_path="${target_path}"
    # No 'SPT_Patches' directory found
    else
        m_err "Unable to locate 'SPT_Patches' directory in '${source_path}'"
    fi

    local progress_start=1
    local progress_total=$(find "$source_path/SPT_Patches" \( -type f -printf x \) | wc -c)
    # Process each file in source directory
    find "$source_path/SPT_Patches" \( -type f -print0 \) \
    | while read -d $'\0' source; do
        # progress_current
        local progress_current="[${progress_start}/${progress_total}]"
        # Isolate the operation extension
        local extension="${source##*.}"
        # Isolate sub-directories of SPT_Patches
        local formatted="${source#*SPT_Patches/}"
        # Remove operation extension to get actual file name
        formatted="${formatted%.*}"

        local output="${target_path}/${formatted}"
        local target="${output}.decoded"

        case "$extension" in
            "delta")
                # Start patching
                m_msg "${progress_current} (*) Patching: ${formatted}"
                m_run "${patcher_cmd}" $patcher_args "$output" "$source" "$target" &>/dev/null \
                || m_err "A patch failed to apply"
                # Success - remove old file and replace with .decoded file
                if ! [ -f "${target}" ]; then m_err "Decoded file not found!"; fi
                rm "${output}" || m_err "Unable to remove file"
                mv "${target}" "${output}"
            ;;
            "del")
                m_msg "${progress_current} (-) Deleting: ${formatted}"
                rm "${output}" || m_err "Failed to delete file"
                local dir_path="${output%/*}"
                if [[ -z "$(ls -A "${dir_path}")" ]]; then
                    rmdir "${dir_path}" || m_err "Failed to remove empty directory: ${dir_path}"
                fi
            ;;
            "new")
                m_msg "${progress_current} (+) Adding: ${formatted}"
                local dir_path="${output%/*}"
                if [[ ! -d "${dir_path}" ]]; then
                    mkdir -p "${dir_path}" || m_err "Failed to create new directory: ${dir_path}"
                fi
                cp "${source}" "${output}" || m_err "Failed to add file"
            ;;
            *)
                m_err "File '${source}': Invalid or missing operation extension"
            ;;
        esac
        progress_start=$((${progress_start}+1))
    done
    
    if [ $? != 0 ]; then
        remove_spt_install
        m_err "Failed to patch game files"
    fi

    # SUCCESS! ※\(^o^)/※
    if [ "${source_path}" == "${target_path}" ]; then
        m_msg "Cleaning up ..."
        if [[ -d "${source_path}/SPT_Patches" ]]; then
            rm -rf "${source_path}/SPT_Patches" || m_warn "Failed to remove 'SPT_Patches' directory"
        fi
        if [[ -f "${source_path}/patcher.exe" ]]; then
            rm -rf "${source_path}/patcher.exe" || m_warn "Failed to remove 'patcher.exe'"
        fi
    fi
    
    m_success "Done! ※\(^o^)/※"
}


opt_installer() {
    m_msg "Launching installer..."
    
    set_prefix_path "${1}"
    set_spt_path "${2}"

    # Check EFT installation
    m_msg "Checking for EFT inside the prefix..."
    EFT_INSTALL_PATH=$(get_eft_install_path)
    [ $? != 0 ] && m_subshell_err "${EFT_INSTALL_PATH}"

    # Check if the game directory from the install path actually exists
    [ ! -d "${EFT_INSTALL_PATH}" ] \
    && m_err "Vanilla game directory at '${EFT_INSTALL_PATH}' does not exist!"

    #  The directory exists!
    m_msg "Found vanilla game directory at '${EFT_INSTALL_PATH}'"

    # Pre-Checks
    check_eft_running
    check_dependencies
    check_disk_space
    check_mod_install_path

    # Check & get installed EFT version
    m_msg "Getting installed EFT version"
    INSTALLED_EFT_VERSION=$(get_installed_eft_version)
    [ $? != 0 ] && m_subshell_err "${INSTALLED_EFT_VERSION}"
    m_success "Found EFT version: '${INSTALLED_EFT_VERSION}'"

    if [[ ${REINSTALL_SPT} -eq 1 ]]; then
        # Backup user files
        m_msg "Creating backup of user files"
        opt_backup
    fi

    # Get required metadata for mod and patcher releases
    fetch_metadata "${MOD_RELEASE_JSON_URL}" "${MOD_RELEASE_JSON_PATH}"
    fetch_metadata "${PATCHER_MIRRORS_JSON_URL}" "${PATCHER_MIRRORS_JSON_PATH}"

    # Set global variable for patcher mirror urls
    PATCHER_MIRROR_URLS=$(get_patcher_urls)
    [ $? != 0 ] && m_subshell_err "${PATCHER_MIRROR_URLS}"
    m_dbg "Patcher mirror urls: Got '${PATCHER_MIRROR_URLS}'"

    # Fetch latest mod release URL
    MOD_RELEASE_URL=$(get_json_value "${MOD_RELEASE_JSON_PATH}" "DownloadUrl")
    [ $? != 0 ] && m_subshell_err "${MOD_RELEASE_URL}"
    m_dbg "Mod release url: Got '${MOD_RELEASE_URL}'"

    # Check & get latest SPT version
    MOD_VERSION=$(get_json_value "${MOD_RELEASE_JSON_PATH}" "AkiVersion")
    [ $? != 0 ] && m_subshell_err "${MOD_VERSION}"
    m_dbg "Mod version: Got '${MOD_VERSION}'"

    # Check & get required EFT version
    REQUIRED_EFT_VERSION=$(get_json_value "${MOD_RELEASE_JSON_PATH}" "ClientVersion")
    [ $? != 0 ] && m_subshell_err "${REQUIRED_EFT_VERSION}"
    m_dbg "Required EFT version: Got '${REQUIRED_EFT_VERSION}'"

    # Mod hash
    MOD_EXPECTED_HASH=$(get_json_value "${MOD_RELEASE_JSON_PATH}" "Hash")
    [ $? != 0 ] && m_subshell_err "${MOD_EXPECTED_HASH}"
    m_dbg "Expected mod hash: Got '${MOD_EXPECTED_HASH}'"

    # Patcher hash
    PATCHER_EXPECTED_HASH=$(get_json_value "${PATCHER_MIRRORS_JSON_PATH}" "Hash" | head -1)
    [ $? != 0 ] && m_subshell_err "${PATCHER_EXPECTED_HASH}"
    m_dbg "Expected patcher hash: Got '${PATCHER_EXPECTED_HASH}'"

    # Patcher required EFT version
    PATCHER_TARGET_EFT_VERSION=$(get_patcher_target_eft_version)
    [ $? != 0 ] && m_subshell_err "${PATCHER_TARGET_EFT_VERSION}"
    m_dbg "Patcher targeted EFT version: Got '${PATCHER_TARGET_EFT_VERSION}'"

    # Check for cached mod archive
    verify_cached "${MOD_FILE_PATH}" "${MOD_EXPECTED_HASH}"

    # Mod archive not valid, re-download
    if [ $? != 0 ]; then
        m_download "${MOD_RELEASE_URL}" "${MOD_FILE_PATH}"

        # Make sure the file is good to use
        check_hash "${MOD_FILE_PATH}" "${MOD_EXPECTED_HASH}"
        [ $? != 0 ] && m_err "Downloaded mod archive is corrupted"
    fi

    # Check if we need to patch the game files
    m_msg "Comparing installed EFT <--> required EFT versions (latest SPT release is '${MOD_VERSION}')"
    if [[ "${INSTALLED_EFT_VERSION}" != "${REQUIRED_EFT_VERSION}" ]]; then
        m_warn "Latest SPT / installed EFT versions not compatible"
        m_msg "Checking for a compatible downpatcher"

        # Check if target EFT version is lower, greater or equal to required EFT version
        if [[ "${PATCHER_TARGET_EFT_VERSION}" -lt "${INSTALLED_EFT_VERSION}" ]]; then
            # No patcher available yet!
            m_warn "Looks like there's no patcher available for your EFT version"
            m_echo
            m_echo "    > This usually happens when EFT has been updated recently."
            m_echo "    > Please wait for the SPT team to generate a new patcher."
            m_echo "    > Usually, this will take less then 24 hours."
            m_echo
            m_err "No patcher available"
            
        elif [[ "${PATCHER_TARGET_EFT_VERSION}" -gt "${INSTALLED_EFT_VERSION}" ]]; then
            # EFT is outdated!
            m_warn "Looks like your installed EFT version is out-of-date"
            m_echo
            m_echo "    > Please update your live EFT installation & try again"
            m_echo
            m_err "EFT is out-of-date"

        elif [[ "${PATCHER_TARGET_EFT_VERSION}" -eq "${INSTALLED_EFT_VERSION}" ]]; then
            # Downpatcher is compatible!
            m_success "Patcher is compatible with your installed EFT version"

            # Check for cached patcher archive
            verify_cached "${PATCHER_FILE_PATH}" "${PATCHER_EXPECTED_HASH}"; status=$?

            # Download patcher archive if needed
            if [ "${status}" -eq 1 ]; then
                download_patcher
                check_hash "${PATCHER_FILE_PATH}" "${PATCHER_EXPECTED_HASH}"
                [ $? != 0 ] && m_err "Downloaded patcher archive is corrupted"
            fi

            # Extract downpatcher to temp directory
            local patcher_temp_path="${TEMP_PATH}/patcher"
            # HACK: Running native 7z while using Flatpak Lutris is a workaround for the bundled lib
            # throwing an E_FAIL error on large archives.
            m_extract "${PATCHER_FILE_PATH}" "${patcher_temp_path}"

            # Remove old SPT install if needed & copy EFT files
            [[ ${REINSTALL_SPT} -eq 1 ]] && remove_spt_install
            cp_eft_files

            # Move patcher files to install directory
            m_msg "Moving patcher files to '${SPT_INSTALL_PATH}'"
            m_run find "$patcher_temp_path" -type d -name '*SPT_Patches*' \
            | m_run xargs mv -t "${SPT_INSTALL_PATH}" \
            || m_err "Failed to move patcher files to SPT install directory" 

            # Patch game using downloaded patcher files
            opt_patcher "${SPT_INSTALL_PATH}" \
            || m_err "Something went wrong while patching game files"
        fi
    else
        m_msg "Your installed EFT version is compatible with the latest SPT release"
        # Remove old SPT install if needed & copy EFT files
        [[ ${REINSTALL_SPT} -eq 1 ]] && remove_spt_install
        cp_eft_files
    fi

    # Extract mod archive to install directory
    m_extract "${MOD_FILE_PATH}" "${SPT_INSTALL_PATH}"
    
    # DONE! (⌐■_■)
    m_msg "${BOLD}${GREEN}All done! ※\(^o^)/※${RESET}"
    m_sleep
}


opt_version() {
    m_echo "${BOLD}~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~${RESET}"
    m_echo "${BOLD}| SPT-LINUX-ADDITIONS |${RESET}"
    m_echo "${BOLD}~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~${RESET}"
    m_echo "AiO setup tool for SPT"
    m_echo "${BOLD}Version: ${VERSION}${RESET}"
    m_echo
    m_echo "${RED}[!] This script is made by the SPT community & is NOT offically supported by the mod developers!${RESET}"
    m_echo
    m_echo "Report bugs over at:"
    m_echo "${BOLD}  -> https://github.com/MadByteDE/SPT-Linux-Guide${RESET}"
    m_echo
}


opt_help() {
    m_echo "${BOLD}Syntax:${RESET} spt-linux-additions [OPTION][ARGS]"
    m_echo "${BOLD}Example usage: ${GRAY}spt-linux-additions install --debug ~/Games/sptarkov drive_c/spt380${RESET}"
    m_echo
    m_echo "${BOLD}OPTIONS:${RESET}"
    m_echo "  ${BOLD}help${RESET} | --help                                       Print this help message"
    m_echo
    m_echo "  ${BOLD}version${RESET} | --version                                 Print the version info message"
    m_echo
    m_echo "  ${BOLD}install${RESET} [ARGS][PREFIX_PATH][INSTALL_PATH]           Automated installation of SPT into a given prefix"
    m_echo "      ${BOLD}PREFIX_PATH${RESET}                                     Full path to the root directory of a given prefix"
    m_echo "            ${GRAY}Example: '~/Games/tarkov'${RESET}                 Defaults to '~/Games/escape-from-tarkov'"
    m_echo "      ${BOLD}INSTALL_PATH${RESET} (optional)                         Path to install SPT to, relative to the prefix root directory"
    m_echo "            ${GRAY}Example: 'drive_c/SPTarkov'${RESET}               Defaults to 'drive_c/SPTarkov'"
    m_echo
    m_echo "  ${BOLD}patch${RESET} [ARGS][INSTALL_PATH][SOURCE_PATH]             Patch game files in INSTALL_PATH"
    m_echo "      ${BOLD}INSTALL_PATH${RESET}                                    Full path to game files to patch"
    m_echo "            ${GRAY}Example: '~/Games/tarkov/drive_c/SPTarkov'${RESET} "
    m_echo "      ${BOLD}SOURCE_PATH${RESET} (optional)                          Path to directory containing 'SPT_Patches'"
    m_echo "            ${GRAY}Example: '~/Downloads/patcher'${RESET}            If not set, the patcher looks for the files inside the INSTALL_PATH"
    m_echo
    m_echo "  ${BOLD}reinstall${RESET} [ARGS][PREFIX_PATH][INSTALL_PATH]         Backup user files and re-install game files using the latest SPT available"
    m_echo "      ${BOLD}PREFIX_PATH${RESET}                                     Full path to the root directory of a given prefix"
    m_echo "            ${GRAY}Example: '~/Games/tarkov'${RESET}                 Defaults to '~/Games/escape-from-tarkov'"
    m_echo "      ${BOLD}INSTALL_PATH${RESET} (optional)                         Path to install SPT to, relative to the prefix root directory"
    m_echo "            ${GRAY}Example: 'drive_c/SPTarkov'${RESET}               Defaults to 'drive_c/SPTarkov'"
    m_echo
    m_echo "  ${BOLD}backup${RESET} [ARGS][DIRS]                                 Create a custom backup for user files"
    m_echo "      ${BOLD}DIRS${RESET} (optional)                                 List of files/directories relative to the SPT install directory"
    m_echo "            ${GRAY}Example: 'user/profiles BepInEx/plugins'${RESET}  Defaults to all 'SPT_USER_DATA_DIRS'"
    m_echo
    m_echo "  ${BOLD}restore${RESET} [ARGS][DIRS]                                Restore files from the latest backup directory"
    m_echo "      ${BOLD}DIRS${RESET} (optional)                                 List of files/directories to restore - relative to the SPT install directory"
    m_echo "            ${GRAY}Example: 'user/profiles BepInEx/plugins'${RESET}  Defaults to all 'SPT_USER_CONFIG_DIRS'"
    m_echo
    m_echo "  ${BOLD}clear-cache${RESET}                                         Remove all files in the script's cache directory"
    m_echo
    m_echo "  ${BOLD}self-update${RESET}|--self-update                           Fetch the latest installer script version from the repo"
    m_echo
    m_echo "${BOLD}ARGUMENTS:${RESET}"
    m_echo "      ${BOLD}--debug${RESET}|-d                                      Enable debug output"
    m_echo "      ${BOLD}--verbose${RESET}|-v                                    Enable verbose output"
    m_echo "      ${BOLD}--no-wait${RESET}|-nw                                   Disable all wait times in the script"
    m_echo "      ${BOLD}--no-prompt${RESET}|-np                                 Disable user prompts (accept all)"
    m_echo
    m_echo "For more details and help, visit the 'Linux-Guide' repository or join the SPT Discord server:"
    m_echo "${BOLD}  -> https://discord.com/invite/Xn9msqQZan${RESET}"
    m_echo
}


opt_backup() {
    # TODO: Add feature to exclude unwanted sub-directories (e.g. ! prefixed)
    local dirs=("$*")

    # if no args given, restore all defined user data directories
    [ "$#" -eq 0 ] && dirs=("${SPT_USER_DATA_DIRS[@]}")

    # Get installed SPT version (if any)
    # TODO: Move to be able to use it somewhere else
    local core_json_file="${SPT_INSTALL_PATH}/SPT_Data/Server/configs/core.json"
    INSTALLED_SPT_VERSION=$(get_json_value "${core_json_file}" "sptVersion")
    [ $? != 0 ] && m_subshell_err "${INSTALLED_SPT_VERSION}"
    m_dbg "Installed SPT version: Got '${INSTALLED_SPT_VERSION}'"

    # Prepare backup directory
    printf -v timestamp '%(%Y%m%d-%H%M)T' -1
    local backup_name="spt-${INSTALLED_SPT_VERSION}-${timestamp}"
    local backup_path="${SPT_BACKUP_PATH%/}/${backup_name%/}"

    m_msg "Creating backup in '${backup_path}'"

    # Copy required directories from the SPT install path to the backup path
    for dir in "${dirs[@]}"; do
        local source_path="${SPT_INSTALL_PATH%/}/${dir}"
        local target_path="${backup_path}/${dir}"
        local formatted="${source_path#*"${SPT_BACKUP_PATH}"/}"
        m_dbg "Backing up: ${formatted}"
            if [[ -d "${source_path}" ]]; then
                m_cp "${source_path%/}/" "${target_path%/}/" \
                || m_err "Failed to backup '${source_path}'"
            else m_warn "File or directory '${source_path}' does not exist"; fi
        done

    # Final check if exists
    [ ! -d "${backup_path}" ] \
    && m_err "User backup directory at '${backup_path}' does not exist"

    # Cache path to the latest backup
    echo "${backup_path}" > "${CACHE_PATH}/latest_backup" \
    || m_warn "Failed to create cache file '${SPT_LATEST_BACKUP_FILE}'"

    # Update global variable for the cached backup path
    get_cached_backup_path

    m_msg "A new backup has been successfully created at:"
    m_echo "    > ${backup_path}"
}


opt_restore() {
    # TODO: Add feature to exclude unwanted sub-directories (e.g. ! prefixed)
    local dirs=("$*")

    # if no args given, restore all defined user config directories
    [ "$#" -eq 0 ] && dirs=("${SPT_USER_CONFIG_DIRS[@]}")

    # Check for backup directory
    [ ! -d "${CACHED_BACKUP_PATH}" ] \
    && m_err "Backup directory at '${CACHED_BACKUP_PATH}' does not exist"

    # Check for spt install directory
    [ ! -d "${SPT_INSTALL_PATH}" ] \
    && m_err "SPT directory at '${SPT_INSTALL_PATH}' does not exist"
    m_echo "${YELLOW}Restore triggered${RESET}"
    m_echo
    m_echo "    > This command will attempt to restore the following files and/or directories:"
    m_echo "    > ${UNDERLINE}${dirs[*]}${RESET}"
    m_echo
    m_echo "    > from the following backup directory:"
    m_echo "    > ${UNDERLINE}${CACHED_BACKUP_PATH}${RESET}"
    m_echo
    m_echo "    > and override existing files in the SPT install directory at:"
    m_echo "    > ${UNDERLINE}$SPT_INSTALL_PATH${RESET}"
    m_echo
    m_echo "    > ${BOLD}${YELLOW}RESTORING OLD FILES CAN BRICK YOUR INSTALLATION!${RESET}"
    m_echo "    > ${YELLOW}If you restore files other then basic configs, you're on your own!${RESET}"
    m_echo "    > ${YELLOW}Don't report issues on the guide repo or Discord!${RESET}"
    m_echo
    m_ask "Do you want to continue?"

    # Array of directories and files to restore
    # TODO: Rework this to look for existing files in the source backup directory!
    for dir in "${dirs[@]}"; do
        local source_path="${CACHED_BACKUP_PATH%/}/${dir}"
        local target_path="${SPT_INSTALL_PATH%/}/${dir}"
        local formatted="${source_path#*"${CACHED_BACKUP_PATH}"/}"
        if [[ -d "${source_path}" ]] then
            m_msg "Restoring: ${formatted}"
            m_cp "${source_path%/}/" "${target_path%/}/" || m_err "Failed to restore '${source_path}'"
        fi
    done

    m_msg "All files have been restored successfully"
}

 
opt_self_update() {
    local script_path="${SCRIPT_ROOT_PATH}/${TITLE}"

    # Display warning for not fully implemented feature
    m_echo "${YELLOW}Not fully implemented yet${RESET}"
    m_echo
    m_echo "    > The script will attempt to download the latest version available from here:"
    m_echo "    > ${UNDERLINE}${SCRIPT_UPDATE_URL}${RESET}"
    m_echo
    m_echo "    > ${BOLD}This feature is NOT fully implemented yet & won't validate the new script file!${RESET}"
    m_echo
    m_echo "    > If you have issues running the script after doing 'self-update', please"
    m_echo "    > download & reinstall the script manually to the root prefix directory!"
    m_echo
    m_ask "Do you want to continue?"

    # Download and replace the script file
    m_download "${SCRIPT_UPDATE_URL}" "${script_path}"
    [ $? != 0 ] && m_err "Failed to update script!"
    m_msg "Script has been updated! Run './spt-linux-additions version' to see the updated version info!"
}


opt_clear_cache() {
    # Skip if directory is missing
    if [ ! -d "${CACHE_PATH}" ]; then
        m_warn "Directory at '${CACHE_PATH}' does not exist, skipping"
        return
    fi

    # Prompt user
    m_echo "${BOLD}${YELLOW}Cache clearing triggered${RESET}"
    m_echo
    m_echo "    > This action will remove ${BOLD}ALL${RESET} cached files in:"
    m_echo "    > ${UNDERLINE}${CACHE_PATH}${RESET}"
    m_echo
    m_echo "    > ${BOLD}Examples for cached files:${RESET}"
    m_echo "    > Last downloaded mod / patcher archives, server metadata, latest log file, and more..."
    m_echo
    m_ask "Do you want to continue?"

    m_msg "Clearing cache"
    rm -r "${CACHE_PATH}" || m_err "Failed to clear cache directory"
    m_msg "Cache has been cleared successfully"
}


set_reinstall() {
    m_echo "${BOLD}${YELLOW}Re-install mode for SPT enabled${RESET}"
    m_echo
    m_echo "    > This mode will backup the following files/directories:"
    m_echo "    > ${UNDERLINE}${SPT_USER_DATA_DIRS[*]}${RESET}"
    m_echo
    m_echo "    > to a new directory in '$SPT_RELATIVE_ROOT_BACKUP_PATH' and attempt a re-install of the EFT and"
    m_echo "    > SPT game files using the ${BOLD}LATEST${RESET} SPT version available."
    m_echo
    m_echo "    > ${BOLD}ALL OTHER FILES IN THE SPT INSTALL DIRECTORY WILL BE LOST!${RESET}"
    m_echo
    m_ask "Do you want to continue?"
    REINSTALL_SPT=1
}


set_debug() {
    local value=${1:-1}

    case $1 in
        '0') return 0;;
        '1') DEBUG_OUTPUT=$value;;
        '2') DEBUG_OUTPUT=$value;;
        *)
            m_dbg "Invalid setting used for 'set_debug' - defaulting to 1"
            DEBUG_OUTPUT=1
        ;;
    esac

    m_msg "Debug logging enabled"
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# Main entry #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# Remove old log, otherwise we just append more lines to it
if [[ -f "${LOG_PATH}" ]]; then
    rm -f "${LOG_PATH}" || m_warn "Failed to remove old log file in '${LOG_PATH}'"
fi

# Apply launch arguments
for arg in "$@"; do
    case "${arg}" in
        "--debug" | "-d")
            # Use debug output
            set_debug 1
            shift 1
        ;;
        "--verbose" | "-v")
            # Use verbose output for commands
            set_debug 2
            shift 1
        ;;
        "--no-wait" | "-nw")
            # Ignore sleep times
            m_dbg " > Sleep times disabled"
            NO_WAIT=1
            shift 1
        ;;
        "--no-prompt" | "-np")
            # Disabled user prompts
            m_dbg " > User prompts disabled"
            NO_PROMPT=1
            shift 1
        ;;
        --* | -*)
            m_warn "Invalid argument '$arg'"
            shift 1
        ;;
    esac
done

# Create directories (temp / cache)
readonly TEMP_PATH="$(mktemp -d -t "${TITLE}.XXXXXXXXX")"
[ ! -d "${TEMP_PATH}" ] && m_err "Failed to create temp directory"

if [ ! -d "${CACHE_PATH}" ]; then
    mkdir -p "${CACHE_PATH}" || m_err "Failed to create directory at '${CACHE_PATH}'"
fi

if [ ! -d "${BINARIES_PATH}" ]; then
    mkdir "${BINARIES_PATH}" || m_err "Failed to create directory at '${BINARIES_PATH}'"
fi

# Set default prefix path
set_prefix_path

# Set/update spt install path
set_spt_path

# Set/update backup path
set_backup_path

# Update global variable for the cached backup path
get_cached_backup_path

# Reserve first argument which always has to be the option command
OPTION="${1}"
shift 1

# Apply launch option
case $OPTION in
    "patch")
        opt_version
        check_flatpak_env
        m_echo "A log file will be generated at:"
        m_echo "  ${BOLD}-> ${LOG_PATH}${RESET}"
        m_echo
        m_sleep
        opt_patcher "$@"
    ;;
    "install")
        opt_version
        check_flatpak_env
        m_echo "A log file will be generated at:"
        m_echo "  ${BOLD}-> ${LOG_PATH}${RESET}"
        m_echo
        m_sleep
        opt_installer "$@"
    ;;
    "reinstall")
        set_reinstall || m_exit 3
        opt_version
        check_flatpak_env
        opt_installer "$@"
    ;;
    "backup")
        opt_version
        check_flatpak_env
        opt_backup "$@"
    ;;
    "restore")
        opt_version
        check_flatpak_env
        opt_restore "$@"
    ;;
    "")
        opt_version
        opt_help
    ;;
    "clear-cache") opt_clear_cache "$@" ;;
    "self-update" | "--self-update") opt_self_update ;;
    "version" | "--version") opt_version ;;
    "help" | "--help") opt_help ;;
    *) m_err "Invalid option '${OPTION}'" ;;
esac

# Exit properly & clean up temp files
m_exit

